// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /account/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /account/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /accounts)
	SearchAccounts(ctx echo.Context, params SearchAccountsParams) error

	// (GET /asset/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /asset/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /asset/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /block/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /blocktimes)
	LookupBlockTimes(ctx echo.Context) error

	// (GET /transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "assetParams" -------------
	if paramValue := ctx.QueryParam("assetParams"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "assetParams", ctx.QueryParams(), &params.AssetParams)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetParams: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchAccounts(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// LookupBlockTimes converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlockTimes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlockTimes(ctx)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "noteprefix" -------------
	if paramValue := ctx.QueryParam("noteprefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "noteprefix", ctx.QueryParams(), &params.Noteprefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter noteprefix: %s", err))
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := ctx.QueryParam("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sigtype" -------------
	if paramValue := ctx.QueryParam("sigtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sigtype", ctx.QueryParams(), &params.Sigtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sigtype: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/account/:account-id", wrapper.LookupAccountByID)
	router.GET("/account/:account-id/transactions", wrapper.LookupAccountTransactions)
	router.GET("/accounts", wrapper.SearchAccounts)
	router.GET("/asset/:asset-id", wrapper.LookupAssetByID)
	router.GET("/asset/:asset-id/balances", wrapper.LookupAssetBalances)
	router.GET("/asset/:asset-id/transactions", wrapper.LookupAssetTransactions)
	router.GET("/assets", wrapper.SearchForAssets)
	router.GET("/block/:round-number", wrapper.LookupBlock)
	router.GET("/blocktimes", wrapper.LookupBlockTimes)
	router.GET("/transactions", wrapper.SearchForTransactions)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
