// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /account/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /account/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /accounts)
	SearchAccounts(ctx echo.Context, params SearchAccountsParams) error

	// (GET /asset/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /asset/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /asset/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /block/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /blocktimes)
	LookupBlockTimes(ctx echo.Context) error

	// (GET /transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "assetParams" -------------
	if paramValue := ctx.QueryParam("assetParams"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "assetParams", ctx.QueryParams(), &params.AssetParams)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetParams: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchAccounts(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// LookupBlockTimes converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlockTimes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlockTimes(ctx)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "noteprefix" -------------
	if paramValue := ctx.QueryParam("noteprefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "noteprefix", ctx.QueryParams(), &params.Noteprefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter noteprefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sigtype" -------------
	if paramValue := ctx.QueryParam("sigtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sigtype", ctx.QueryParams(), &params.Sigtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sigtype: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "gt" -------------
	if paramValue := ctx.QueryParam("gt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "gt", ctx.QueryParams(), &params.Gt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gt: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------
	if paramValue := ctx.QueryParam("lt"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/account/:account-id", wrapper.LookupAccountByID)
	router.GET("/account/:account-id/transactions", wrapper.LookupAccountTransactions)
	router.GET("/accounts", wrapper.SearchAccounts)
	router.GET("/asset/:asset-id", wrapper.LookupAssetByID)
	router.GET("/asset/:asset-id/balances", wrapper.LookupAssetBalances)
	router.GET("/asset/:asset-id/transactions", wrapper.LookupAssetTransactions)
	router.GET("/assets", wrapper.SearchForAssets)
	router.GET("/block/:round-number", wrapper.LookupBlock)
	router.GET("/blocktimes", wrapper.LookupBlockTimes)
	router.GET("/transactions", wrapper.SearchForTransactions)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9f2/cNtLwVyH2PaBJ3107Sa8HNC8Oh7S5vA0uyQWxmwOeOA+OK83uspZIHUl5vc2T",
	"7/6AM6RESZR27bhOgvqvxCv+GA7n9wzJD7NMlZWSIK2ZPf4wq7jmJVjQ+BfPMlVLuxC5+ysHk2lRWaHk",
	"7HH4xozVQq5n85lwv1bcbmbzmeQltG1c//lMw39qoSGfPba6hvnMZBsouRvY7irX2o/08eN8xlcW9MIK",
	"N0p/4ucyK+ocmAZTF9YwbMvsBthaXIBkrtcRe1kby5bAuGRvnv3Evvvuux/YSumSWwu5B/ooQP2fGvQu",
	"ArudPQaTus8ez3JuIXxOwG4MpFH2xH1hz5+OTRs6JnAjpIU1aJxgCSul4UDsUOMbRU88/zXws7ZDqN94",
	"aM1G1UXONvwCQeMlkthaA6c95pLZjTDsghc1jMG3tvswWIhSJKB4yS9FWZdM1uUSNFOrBotWMQ221nJs",
	"Thpx37RXXnkBxhy67GLv/CW/XGhVy/wAprJM6Zh4TAWZWAnIWTPKGCDtNPvgEfJq8LSsHoETBhkFp5ll",
	"DzhqtTKQ2KJfDORMSJYp+WstM/cr2wq7YbjpjjYqvnZY0qpebwLIY+D4WfbAciBaVqqPjklUHIQGbLQg",
	"HkjQq/vqOSQt9Dv9DxD78dxGrBf0c3/eE7E+3VXAVqJw2on96gRYQENthFz3EOGGcSxsxFpyW2t4fCa/",
	"dX+xBTuxXOZc5+6Xkn56WRdWnIi1+6mgn16otchOxHoEmQ2s8ZpA1uXs8Tv3cTaflfSPG2/2PiUL7WWz",
	"3NQU4XNqhoq7huew0+Dm4NkK/7lcIdb5Sv+WmtLtL5hKSQOo4Z+Qhn7jf3M/ZUpakMgHvKoKkXG3Bce/",
	"GrcPHyJI/qRhNXs8+z/HrQlxTF/NsR+XZuzu5D0oK7u7P/s4D7Oba01faVWBtgJiUwX/LyyU5mAIGyRx",
	"rfluNs58RPrcsu1GZBskt0Y8aXDCWeRH7NQJai/NlyQ7S4W0moG0xJ9zZpQT65btVM0yJ96hKNhGbZkq",
	"csZZxrONY2Ycngnjh10JKHKWKzDyG8ssPwcmpFUs2GJc7px4pkk8q8zdHN8UBZPguMIpshJQvzkAjloV",
	"3fDhfGaV5cUQAafu56F2nLPa0NAXoMVqx7YbsBvXRDOpLKLAai4NJ9mJeGbCMKtrmXELeQqKj7HoeNfu",
	"77yRYgRlS+Rq+Stke0nOGVk/8oLLDG6C7pZ+qH3k9lJIgXP/rIocefHT6OxK++Y2IL13bKVVyezGCIay",
	"p93L3HkBpZCQ2s6w6uvtZYOzm9jLmxddbtRDZr4RsYUDHS60CLY7kfVViCza208k8h8LlZ3fOJHjqIfM",
	"fCrKG5GTiIMuoScapMzC+cy5ksbyskrsryhRQEm2dNCyLTfOTl8JXY7uUQ/7fWb6eLX9+bvWSn8CYiD0",
	"H1qHMTFRsyvSzmlLwje2h3dC5vMKmfks6nO45ohI4RNJ/mPwRmIHIhHs8rgXkuJCuELLuA9DkZ96Js/k",
	"U1gJKdz3x2cy55YfL7kRmTmuDWhvqR2tFXvM/JBPueVncjbvq9I812DMEBKH50AJVb0sRMbOYTeMTc1n",
	"FHUZjnB29o4Xa3V29n5gR70UmVZPirUyTEgWTZXcOppgsRV2o2q7qEA6W3ChYct1ngA9uLOGRqag0NSs",
	"c+bHxh/9+MyPnyan1gQZLtp9cqumNmzj2Gy5o2CUnxH38JWyxNKabxnRkCN+w/5d8uqdkPY9W5zVDx58",
	"Byw2gv/tAxiO5ncVRbYONoMiQ7pvDWUYMMwXU0uruHYrawPeDq9+nb7/6FIfN2sNdDW12E9aZWp5FddW",
	"ZKLitJyD/NzXnT5ukH20l6Q2teoTFRFghKQkkVHjxZIbSG4HuC9uP1BkcuP2BecmbUIzudXVFldwxP4p",
	"ix3z2mtZOAcnQGC8InLKJ0IVBbTHQEtTCWjZMn0Ao4uRWLpsuEF9Ji4gnzOBwTqHqoP4cES7OufN6y2l",
	"GxUrTEewCjdvARd8DP/Gclun16hk4daYQwFrGo0aB+z7xX1jolWfyW/ZP1erwrmHCyZk7kwIlFKcJA83",
	"RmUCmSggR5gwBzjB/y1zW+gGOHiEFG1EYFdKFTQwe6VigpfrqwApQaCW5mFsVNfR33CU0h3psOXzZtYt",
	"ztoPSroJcVk9UTNnpc/QKOl6hOBliFiGMOVsftWQY8dD8Sqz0Xx7NdRQbrQM1Do6ntreJ2ztpDgaMx46",
	"rRg1WXplGAnuFAJ9wN6ANLVhlVZWZao4GlgNBgpAq2jRkaoLZyGkuMUAcstJ6BZZFOyeWDlT8z7Laq1B",
	"2mLHNKyFsaAhb5VAE6JvEmbLnQUHGbcWtJvov+/97fG7J4v/4ovfHix++L/H7z/8+eP9bwc/Pvr417/+",
	"T/en7z7+9f7f/pQi0AtlYbES2tgFmuTJ5blGzwzq/GeuaVr0dFDFKDE1FpPCac9ht8hFUad328/7j6du",
	"2leNaWXq5TnsUMEAzzZsyW22QQ3Umd61mZi64HsX/IIW/ILf2HoPoyXX1E2slbK9Ob4Sqkp502S2DBM4",
	"jSm7VJa8xFqK/9TARA7Suk+acZn3mdstkEuyzAbcK2QOl8O5/MDYJxo+uV841WG22Gtq2peiBEQz0vsx",
	"nASDdQDu00awhYU2lrb7ITI+r+ArxTMOXKUJP8cRZOve1FJ4u3/CeZgsdgiKekOwpIdBg1sl0o1PSEOR",
	"zg5mOcl5N773/4U3w3zj7QZ81rpHR21HDC4sga0o7ODojhcYfOgPU8stl2giYD9CiO9tgBSN67VVTlxm",
	"3KTNA2EWK61+g7T4WzmsJ8IDHmlugdQ7GnupVAFcDpV6o8rbepKA31HafN1wQWIX6SPrOqMjLIpkGvlX",
	"GJsLBhuXRJc/KbkS6zj4MULdcajjmMZvqdvD3CfurODbJc/Ok4jOHEyBqBxEsWlpFQudA+a9FdzSG3u+",
	"YhgJmbdtndHoJDjoUthu2KYlgFESP41I7qsn8xwyUfIi7WnkiH233lbA5GItqMCmNhAVePiBWKWEtERF",
	"uTBVwXeU6m9R83zFHsyDPQ827EYuLoQRywKwxcO5z1sZVDuN+9B0ccsDaTcGmz86oPmmlrmG3G4MIdYo",
	"5vzS06ZQpzHhl2C3AJI9wHYPf2D30DU04gLuOyyWVHc0e/zwByyKoT8epARlDiteF3ZKluQoTP7lhUma",
	"jtE3pjGclvGjpoTLfLbSAL/BuNia4CbqeggvYUsv6fbzUsklX6eqU87O3pV7YKK+uJtoXfbwIn3y01it",
	"dkzY9PxguZNPiw03m7QaJTBYpspS2NIxkFXMqNLRU1ukQpOG4Y6QN8h+a+AKH9FTrNwoSIht2P72PQmq",
	"TkmtGqMlr3gJXbTOndduagdz8NSAeYGYRLAGA/oiPYke2eCgK31fdk8quSgd7+T3vTzr0l/Si09H+M/O",
	"3tkgu/oR4OmhI951DRejuKs7uOOR2Lk2FmudXgqv3VS/vHnhZX+pNHTj9MsQQe5oEQ1WC7hIMmXPCAna",
	"LtII4/lPn2ocwoo/x5CNGcFKnZ8DVEKujzEPSFYCjdq3D9YgwQgzzrvrjUOP++y4LXIDKcW4hELJtbl9",
	"tguAj3iya0AKev50H9SDgdOY+IncTd8f29z2iivQQiVW+xp/Z0pGKccD87+OGuBCqNossMc4Gbh2DqGv",
	"ffsIEbe/946ElYF9HpJvlkc7PyJfm5j33iqBN77teIjaCWWZO1wFmqEoSrQ/DR26DeJVBTIndYwybMOF",
	"HIlbA+QjcTjAGU+UtoKi1gCfIao2UZvglIZxMJIYQ5HoAG26OCvSQKZkbpgRMgMGlUI225/0HU51KXGy",
	"QhjSG1EHlilNZZ+oIa3qpWEPzUhNJpG7MC60UnYMUFSlcW2CUpbx2m5A2iZI7/yO4Uoc7XCNlqJs+f6I",
	"vXQ6zBtWGS+K3ZwJ+w2Ng/E1VKol6PMCmNUAbLtRBlgB/AKoUKEZ7RvDTi9FbuZujgIuRabWmlcbkTGl",
	"c9BH7Jmvu0brlTr5+R4cMZ8M9UmG00uJy8sVkGkbr5OWGZIBxnFMryrAzJmSxW7ws/uhNFBcgDlip1tF",
	"QBgqTMdRnSXR6bGs0YvjLBerFSCf4nLQ6MV+7YcIpq0oCjqX0Azr1/QZuO1SLtDaGzH+LXmYl/InasR8",
	"QtB2fM4ea5TkaQSCKiBfg56HykhAfm3LW5wBprRtHe0VUCbHSTYhrVZ5nQGVNpx06DECSwxAcn/Bpe0U",
	"hCANIfqXEMEZnORGwjP2HJ3SB+QnS9VdIe4dXIBmS+eFtgPdI6ETwWUs15j4BsdhfqmQ3x8xaKu15jks",
	"jOUWDtIlv1CPE+wQjXChrjbAW9e+b3N2DLuOueRNnMagSBsBkZaNUllOAcViPiXmRk3aN2O55WcCihyT",
	"tpSfxPojbDsfGKwrgIURMh3QWgGg2OdZBpWj9Ih+3DcnltB+RylinOINatdtvrTiAihzOmEnLDJeZHVB",
	"2YwJI2Cb8UJ3A8gFrKxytBelzKMoj3BzLTEvRJVTNJ92sjHq4ZjNUfDOtyDvyDMs8k2jyEYT/IsCLiDt",
	"EAGnPP/PastKLnfNXrgpWjDmxErIRQ3kZMZggop2+xfvuEXgE595gpwG0m3FCHLzeJ+JkkXGhPwVPKM3",
	"EitQDEr2TEkrZO1kENPQwk0qhGHJQr8sYUgB2rP4EC5OSaw2bydh29ntPDL1ulkug6V6CHYorvBa89A9",
	"1WBEXo9EpzTPupBdjRg9877hFo51s7XmhuiyJ7waJp9iuj4t98imt1tDLI3KqY5cPkRY8SalzrwMH6bW",
	"fb5yEVqOeFnKqhBa8T3asS9AGx/iGkah4HLP2K5FZ3zckcZHuvosC15VWl2Mxbdd2x2J45bmgl1GJUnY",
	"H3ySM4HBIaV3ATBbYbPNYiSL7tpSCwfDm74TNpySrAvkQlitILOHwIAZbjoaOgoFfXZQPAWeY5lPm1mn",
	"nHoflHuvFHNDm8jkkUaggdpaPDjK/QMYakB9+4j/rTqQ9i8U/g+zXgewQbBx/N6ng3/UxhNPWzTE2Q4M",
	"YqU56hnxSKUML9JB+zBpDgXfTU2JDbqTNjZvyFuQzuFOhzmFApeQ1bbLMAmr0PPZ1OSuSX/BDXsOuWKq",
	"6mBwvmoYKGFGlFVBgXfP8o5B415sqqp4olx4iAVhnjUpmn0J22EVVtM7RbSvFEnqVD1f+w31PhfkKSai",
	"u5xJlYOv9RvKbm6zTV2NXDLwE33FwxdCMsml8nGMJEVsuFmYncwgX6AltEA3o06ETH7m5gQbnrh2J9Qs",
	"Kt0LKXLupcmGU1VoAXhtAZpZYfAUW2Ax0IgB+4IbSyJTdFihaMuCDIBMrpCKjIim0iO/9QSXGLstUwtU",
	"2TheoxppdK5XcNnMpVaJEjifat038hiWovE9skKMZXAIBLXtcHEo3XlVFbtxXROAaBExBchJaJWglAlA",
	"hGkR3ZQPOqZIko6xqqogX3C7qGXTbwxNJ9T6if2lbTskrmDsOkZs4kMhwECQbwmzBiWvI3cPByv5OZYW",
	"a7X20mMIs+Nez3JTlO/4GBkuZoE9XN3XtrG8mOD4DgvuQeoY/CmZ6EigSCg6+p1pqDQYCKGgoEMNfU0e",
	"qDA7Y6EcCEaFNcsvlUzV9P0z+niFEu83YbnpA0cjk5223/Zuj+oA1jmPSD8OcDqfXS7WalHx7Jyv8VYV",
	"YTf18ihT5TEv1kpzmR+v1aL5f86hVBK/5ce8Esemguz44mHvHFpCmQQ9xYuCTnJRUE5JdDScfdoJAKMc",
	"1hi0xYI5kBdQqAqSrfHAxQG1RUasJeT2UlLm8AT/PL2UqbZx2RK2jpaXOpeEZViYlFovbBcTBwbbo6Kp",
	"tuiOiis+ZcRnVNnRjIhDrUB/ypinfgwseSqUgcXU+QqNDnrj+/vUNtZhUdeSC5k7iNT0+RLXXsj1YqKy",
	"McPSRt8wnKVCqzraz/TgIaG4mDwBicHX/qG+AxKSndNKi5GS1rZ8tqkRxZbs3vOn9xmWCPufcUZfQuaz",
	"AcLsX+QKYCzA2EvXsBWM+Kr7qstXF21hObbqO4V7oTwwef8zN1gp7pu3mdAvMWPfAZI9f5qMQ6y1qtM5",
	"xrVGH+pHbuAvf2YgM5WjPWPBnyjFzJfZ8O8fPjp+9P1fWC7WYOwR+xeWZpJeHJol3d1goj12wzsfELCm",
	"cJsK37xNGM258RsySGMJn+bAYW5/h1I7E5M6XtZ2uyDRlT7XlMH/oPuAGpdklBWLi+bIw/U4sYCxs3zF",
	"ZYIev3u0aEnyiL1wvRk4rzQDw8ra1rxgcIllkeS6xGRCtYK2PeuNlrr8DbTCSk3JlHP9+sJXRLIXEyE8",
	"Q5vIO18IQ3M8oCmpuncCTufMCcj7rOJCJ2iX1dKKAn9FBy/CYuUksQP6XxtRwJCZKuW+mxiOOZOKKXJZ",
	"opaU0W5rXglmX4/V0Su3XAKoRtIB0p9pcbYFljIyrGy8/YIZvitB2muy0WvqjQMpVSyaSxp6dUhBIjqj",
	"lz15/RyzbGhv9sJpPYsALkTm9LPP2Hi/85s+lagCT/9IJRd0+v6IsSftn+y1UgXeP9F6j+uaay4tRBUI",
	"nckF3nhAyeA2Ffz/POk5KAwr+Q7H8oljAnVwW4HMsaHbxbLC8lYajrUZkFVtaw0jeSU8JqunzUM9Yh6G",
	"3nsOHeNNdOkQVntxSFs8llJ64iATzqDESBcqUWUUyZRvTCi7TyKFhplGiRlBCfWdRkhT1XEFVjhp+owe",
	"cj07e+c+dCO5nfOu3aoGPMpwxJ421Sauma9TaEtQyBVEZiLZiq2o1r45+iB0cBm5Bmas0pDjWdmzs3cV",
	"BbYTksA3IE3r2gx1rm/Cs9W6uQAh4cSFZpcr0G27lCMVWq70b23DhA83/8Qb/gZpxVnXLkebp2MeNOQb",
	"E4gfOBVrGXFMx1InmCeh4vqiUFSzPmcaPDZr7X9x+4p193V7IuhMPmFOyXu7shlqIeJAmi9S9vV1R4lO",
	"zSEZM+jWn/KKh5Bo8aeXklY74v2PGGGXXOS+ZrdzwITKbwJ+IGdK+1IzsfLrHDtJd73jjHv3+NnIIZB4",
	"j4MD6k99fOLpLppxArFj1704P5Pnee+UQHxNA1X+NWd5CNv+NAwSC9+OHDyZ3M3V5G5OjN+Jfm+DUJi4",
	"siEIkVMfIvYYpx6HHBFsM07tGcHh1IcwfxPvOYg0gmD8VOIIs06Qx8QRV17iYY4nzQUnHjjVwHfEvAjx",
	"YaLwuw66tlgFaRY85hCT6d2ZQTcFspJXVz1Au1c+RECNB8VgYVUaC/i1n/nl8bGP9rYuDSWWLTQVRqkF",
	"+mNwTaCqPZ9IcTwMu9Hp5nAgLLoPLFoMY8/dyLzY8p0/ax9vzvhwoZ6cDp8kbKGh/ZnGjc7QPX4DmaiE",
	"M0Z4V5I0dDJuxY1cqETWIF4p7TijOUPaLfnterqx7DL+KplVLXM6q+jtKaotjhTf3KOeF12PkuzEcDbR",
	"tfkpABFW2WxzpCf2n/lJHTxu0LxHlvi4xaQQ8VbaVWUH9SLhQdOMSw3ZvwdkxMeVrpHbyJdcn3f2h5vu",
	"nUN0mrszakd1xxnGq19Fcg5o4r5ub4vAY45NEfhb0BTaeMNlrkr2LNxffu/tm2f3wz16ea3J3iBvEFgD",
	"yRd8S8lqeEtJ4q4Oh5Kbup/kPP9M95MUg/tJrr/Sw28mCbQ1di9J7a/Fd/+nC0m0P98SB+6+gAtJOnGd",
	"9DUHgybd6pnofD2qyA0UFeMsK1A3ZEqSC3EmOZpjvdhpr7Im1CG8HSvh+KnXolczkijp8BUNZ5KjhmrS",
	"+En1lEz0PIM2al+v12Aw5NPN+ZxJ30rI9tBrKTKtFpQ5r0Bj3uGIWpZ8x1aYkVWklpa17Qb/UQkZ2xww",
	"4W4aplZnklsMdVr2UkgnrmFYACfBbpU+79ztNJowev50uOb/Hz65NXHprKxCmOgkyCB7NJbgSWej/PiY",
	"i/K4jdMgnzk3VQQiudlKqFK4zUrfcuGvNujTFbvnT/wj8TitRDZF2PEzaS+xFgBlG7fXI4V+wUqfDec+",
	"VtISTHd7Y4zdWrVEiENP20U+wnVVw8h3I8vIz3Q9h4r8qZFLUW1z1rNn5k/4LGOTvUpNQceknK9h/D0L",
	"SBuJCoL2xhPZFALQQcP9sdPheOkqg+BV4SR4aj9R8RWs+Maqb/wg7J/7m1qKyNVBg7+HQlqrmA4qT3o6",
	"3tEJbSbj02Pm/qE2/kkcfe5C8pY4G/2T5mrE6HpGNGjx9gy6JwMv/6SbEftHKFtUVlpdiJwIrUvLhVqL",
	"zFDM8qph8BehrxN2dWHFNcd5GfpSXD5t4QsMPofnahjkj77//uEP7XK/MPNqiKRkftgv67VWa81LbkXW",
	"9VCb1R0gxMJWHq3VUGTp9Uj8TCMACCXjel070WfmeN9Pm7PuHIseue+zPfyMgKTXGy2WUaEZXu0Wkbpy",
	"DnlhRfvT3P3mFE8rOqM7m/AuLc68vOrn2k///uQFFYby8vYNi8AUi0/KNvXYY0xwtEzyJfBGLB6JHg4V",
	"iS8jSTK80sgvkbwMRy/hrhvEdVU4o33ZysAh32R6V1l1HLaGVH6Yk5646l2LGo2Xxjo2wItSlLNEKi7o",
	"Cu3IQ8RwYAvVNW4ZGODnJIYrdQXBRoNxEKWzlBt9dvY+7RyPeWPOG053+njFvT3p4bSLccLbqEdenRMQ",
	"t8vLe2jg9kFK4XzUkW4vYtgC41IqS1cuCCodZqXKoWienChgzbOdd+rNmcy4ZLnQkNlix0SJNfmcmS1f",
	"r0Gj96bRNgleOo42tDWWtSBqnCJ5P8aP2DZR5vg5yxa7n72n4x+oa1zoiIW6b1JM683uaG/DAIMHoxAv",
	"88kT/s3sv5dzRjXpEcH9GHZ2+NxEcEypMAjBb4+dRNdZDalFc5ltkojDUaJ3GRMuyoZLSUfch9dPYnD3",
	"MxFUyX9VIzCXQqY/9UmAENNDQ7vm7grDlGH89Ls5bifCczg8Q3fTU+ITTwozf4nabGNtZR4fH2+326NA",
	"J0hAayzZXlhVZ5vjMNDg8ZQwnr9cxBlvxc6KzLAnr5+jqyVsAXRfPFyCZo/Yg1mklGYPjx64UVUFkldi",
	"9nj23dGDo4e0cRuknGPvSx5/aF9d/kj3nSUc6RdKnddVdFl6hyYdReIfz/Omrb+S/ccdRkbid6Lf3ebT",
	"0Lf/Iur73pOZjx48uNVnMp3M5M6RcTal24nZe/dbcr+P+9dEHbL5/Xj9xO7Hlzbto4LP8ITvl/Cq8Vf3",
	"IPdX9r76h/G306+4M7cppj7DG9K3/Lr5533S/fM9q/6p6uHuib27J/auqPLHNfsJcJ1tKC3k2w41OjV6",
	"0j6ofJAabx7XCrGnrv4MAnhUOJMInRSZo32bm/6vIHFvWdx9AQL+TuLePRx/J71/n4fjI4lsUHwGiezE",
	"0/GHIOH2O9y+Sni/u43v1Ced7ZSZGldc7jFSb8mz3fuK+qiS66H0OH5ifwq3WKLibz+OnoJUqLHiRx4m",
	"Ud6+TT+pFv946uX3j7T8YTXa/Ati6l48OuK9KXYfXL/2idrwStol8ShHQ6RUyW4Ewy1pNU7uGLsUElJK",
	"J6z6ehpn2YqQm9E40+LxKiG/TvVl59muKZl4lajfLcvFuyDj1xGz+8pjonfe3Z0uvPPu7mJz+/TyYZE5",
	"bDkWl3umNB2p3KdpP69AuGU9/wyJlv3qNALhrz3kRiqjOfTZ1i+nJm8fJrtCLHH/7G70sSnxnxuer5b0",
	"NGFqPvftavOFt3qvEb/93cJyDTsdFpSjcMNdSO6rCMkF+fY7BOTwNNXxB7r6h5a3NyjXnMBKeUDNI4KT",
	"shg3qSlKShgwMUBfTpSOFncddYc4w1dx9mF3I4xVWmThkiXXZxLZpzjqzZtuXWkyYtslGGj8hbf2EqkD",
	"Xx9Mla/+DrbIQSGByCKZrgBq7JKrxAGi+0pZpWElLr2oDRcP+AO27WlLia8cCP/UfFKRKgs0Vtql87WM",
	"B2YW7eUCW8ZDfeLVSwP68NdftQc9gnR1v/SF6bzBDZ1swnusjD/74/4fyvfd/5sjTGlUGbEeLG4vuFEc",
	"Pbyk1xH2y52/nTSNzp6BcMC2fPYA8xcYVv+DRrBuxAQdjPp3mancP9ZScusdk+i6f5A5vjB/xJ7SG+jO",
	"lnHaZGx9nqpTQgOV0HxWmnXlhESxVvlBUuIzh0zvChJvNrj5BwrU9VS+WKPCI1/FkPsaNq02w5oh21eP",
	"pPHEmi2aM6+o9+gnPEd14tUf/YQnOE+mtOC4jiflWdI/brwUs95FEO8iiDcdQZzPvu9T0aAxXTic9nLx",
	"qih9Eezu7gEVuORlVQCeTbl4OHME7EdoDrd4V8ExcOATGvvj+4//GwAA///ULcdeEKwAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
