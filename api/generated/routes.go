// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/assets", wrapper.SearchForAssets, m...)
	router.GET("/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
