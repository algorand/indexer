// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /account/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /account/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /accounts)
	SearchAccounts(ctx echo.Context, params SearchAccountsParams) error

	// (GET /asset/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /asset/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /asset/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /block/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /blocktimes)
	LookupBlockTimes(ctx echo.Context) error

	// (GET /transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "algos-greater-than" -------------
	if paramValue := ctx.QueryParam("algos-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "algos-greater-than", ctx.QueryParams(), &params.AlgosGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algos-greater-than: %s", err))
	}

	// ------------- Optional query parameter "algos-less-than" -------------
	if paramValue := ctx.QueryParam("algos-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "algos-less-than", ctx.QueryParams(), &params.AlgosLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algos-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "assetParams" -------------
	if paramValue := ctx.QueryParam("assetParams"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "assetParams", ctx.QueryParams(), &params.AssetParams)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetParams: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "algos-greater-than" -------------
	if paramValue := ctx.QueryParam("algos-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "algos-greater-than", ctx.QueryParams(), &params.AlgosGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algos-greater-than: %s", err))
	}

	// ------------- Optional query parameter "algos-less-than" -------------
	if paramValue := ctx.QueryParam("algos-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "algos-less-than", ctx.QueryParams(), &params.AlgosLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algos-less-than: %s", err))
	}

	// ------------- Optional query parameter "address-greater-than" -------------
	if paramValue := ctx.QueryParam("address-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-greater-than", ctx.QueryParams(), &params.AddressGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-greater-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchAccounts(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "asset-greater-than" -------------
	if paramValue := ctx.QueryParam("asset-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-greater-than", ctx.QueryParams(), &params.AssetGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-greater-than: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// LookupBlockTimes converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlockTimes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlockTimes(ctx)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "noteprefix" -------------
	if paramValue := ctx.QueryParam("noteprefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "noteprefix", ctx.QueryParams(), &params.Noteprefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter noteprefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sigtype" -------------
	if paramValue := ctx.QueryParam("sigtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sigtype", ctx.QueryParams(), &params.Sigtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sigtype: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "algos-greater-than" -------------
	if paramValue := ctx.QueryParam("algos-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "algos-greater-than", ctx.QueryParams(), &params.AlgosGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algos-greater-than: %s", err))
	}

	// ------------- Optional query parameter "algos-less-than" -------------
	if paramValue := ctx.QueryParam("algos-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "algos-less-than", ctx.QueryParams(), &params.AlgosLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algos-less-than: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/account/:account-id", wrapper.LookupAccountByID)
	router.GET("/account/:account-id/transactions", wrapper.LookupAccountTransactions)
	router.GET("/accounts", wrapper.SearchAccounts)
	router.GET("/asset/:asset-id", wrapper.LookupAssetByID)
	router.GET("/asset/:asset-id/balances", wrapper.LookupAssetBalances)
	router.GET("/asset/:asset-id/transactions", wrapper.LookupAssetTransactions)
	router.GET("/assets", wrapper.SearchForAssets)
	router.GET("/block/:round-number", wrapper.LookupBlock)
	router.GET("/blocktimes", wrapper.LookupBlockTimes)
	router.GET("/transactions", wrapper.SearchForTransactions)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
