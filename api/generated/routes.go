// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
