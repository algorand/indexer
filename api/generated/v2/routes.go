// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
