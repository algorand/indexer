// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//babPg9dWAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
