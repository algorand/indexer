// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDandName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDandNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDandName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDandName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDandNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDandName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDandName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
