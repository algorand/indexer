// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"KrMzI8xPTh5PPv2/AAAA//+qYl2PHIcBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
