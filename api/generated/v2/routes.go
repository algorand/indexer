// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
