// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
