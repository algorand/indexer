// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
