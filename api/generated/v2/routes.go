// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//+D/yVUYnoBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
