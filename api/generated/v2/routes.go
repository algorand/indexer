// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"header-only": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------
	if paramValue := ctx.QueryParam("header-only"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9eZPbNrYo/lVQ+t0q2/mJ3Y6z1J2uSt3yMn5xjZ1J2U7uEue9gUhIwjQFMADYLSXP",
	"3/0VzgFAkAQpqje3J/rLbhE7Ds6+/DHL5aaSggmjZ2d/zCqq6IYZpuAvmueyFibjhf2rYDpXvDJcitmZ",
	"/0a0UVysZvMZt79W1Kxn85mgG9a0sf3nM8V+q7lixezMqJrNZzpfsw21A5tdZVu7kT5+nM9oUSimdX/W",
	"v4tyR7jIy7pgxCgqNM3tJ00uuVkTs+aauM6ECyIFI3JJzLrVmCw5Kwt94hf9W83ULlq1m3x4ifPZNqPl",
	"Sioqimwp1Yaa2dnsqev3ce9nN0OmZMn6e3wuNwsumN8RCxsKl0OMJAVbQqM1NcSuzu7TNzSSaEZVviZL",
	"qfZsExcR75WJejM7+2WmmSiYgpvLGb+A/y4VY7+zzFC1Ymb26zx1d0vDVGb4JrG1V+7mFNN1aTSBtrDH",
	"Fb9ggtheJ+RNrQ1ZMEIFefvyOfnqq6/+QvAYDSscwA3uqpk93lO4hYIa5j9PudS3L5/D/O/cBqe2olVV",
	"8pzafSefz9PmO3n1Ymgz7UESAMmFYSum8OC1Zum3+tR+GZnGd9w3QW3WmQWb4Yt1L16TXIolX9WKFRYa",
	"a83wbeqKiYKLFTlnu8ErDNPc3gtcsKVUbCKUYuMbBdN4/k8Kpwu5zXBNPaAhC7kl9pvFpCtJy4yqFeyQ",
	"PGAil/Yezy5oWbMHJ+SlVIQLo+furplryIU5+/LJV1+7JopeksXOsF67xbdfnz397jvXrFJcGLoomTvG",
	"XnNt1NmalaV0HRwy649rP5z913//z8nJyYOhy4B/DiNQea0UE/kuWylGAeOsqeif4VsHQXot67Iga3oB",
	"4EI3QDpdX2L74vOA0zwhb3iu5NNyJTWhDvAKtqR1aYifmNSitKjejuaeL+GaVEpe8IIVc3tnl2uer0lO",
	"3YFAO3LJy9JCba1ZMXQg6d3twQ6hk13Xlc4DNnR/D6PZ156TYFvAH/3t/3XrsGRRcPsTLQk3bKOJrvM1",
	"odqtai3LAoE+IgCklDktSUENJdpIi1iXUjmOB7Hu3PVvmDiSwwUWZLHrthRFa/T9fez5sG1VSruzJS01",
	"S5+X3318SLDLmLegZTlzFMsyWm7KLPxAq0pnsONMG2pY3KaqbAshBUswIOEHqhTd2b+12VkuC1DrrLmd",
	"LC+lZpmRexgwz1PBgUUsU3xiB7Fj5P2aEZjcfkBWFCBbWCxdljti3AVYgCCe+ZoTviQ7WZNLeDolP4f+",
	"bjcWpjfEXj5cWYtTtNhsCLh7h5EA7YWUJaMCQNux3pm9v2EmoPRwjc0tvYcJisAfzEnBSgabbIAQftVG",
	"yR1s3oLCnMjKXrqsTf9xiMINi5+7bwUAZ5DLj3eyZ9Ml33DT3+4buuWbekNEvVkwZS/cMwxGEsVMrQRc",
	"tmIkhztbtF5+RVdME2b5CY4iCsxjEZeQhihG8/UwVsI17UFEG7rNlKxFMYETN0SqmNPRFcv5krOChFGG",
	"1tJMs289XBy2nkY+iJbjBxlcTphlz3IE2yau1T5P+wUuKLrVE/KTox3w1chzJgKJQWTJSKXYBZe1Dp2G",
	"WA479TiLIaRhWaXYkm/7i3znjsNiCGzjCNzGMaW5FIZywQpL+2DR0jDENoNriiY8lPNeUM2+/XqI7Wy+",
	"KnbOdkmk2wUA3E4Q9df2C/Yd30WYYc+jngiHSGNj+BuFvUlwB40yRBsJHsl+dUglrVZp9Z/At8Zzo1Cf",
	"XUvBgmN48jZ0FJ2Zbk+W03yV4Yi9V8JX7y0tXvIS6PQ/7ePwN1trS5fad+spt+YrQU2t2NkH8YX9i2Tk",
	"naGioKqwv2zwpzd1afg7vrI/lfjTa7ni+Tu+GjoUv9akwgW6bfAfO15awWK2YbupKfzn1AwVtQ3P2U4x",
	"OwfNl/DPdgmARJfqd+S9gCSaajm0gJSS4bWU53UVH2jeUrotduTViyFggSHH8CHgDl1JoRlA7VNkJN66",
	"3+xPFuUxARg94gVO/6klSCLN2JWSFVOGs1jJaf/7b4otZ2ez/++0UYqeYjd96iacBUnHDJEyfMDUOBSG",
	"qMshNWQGNlVtkLSnsEN4zr+EtXXnbK5FLv7JcoMH1F7GQ7apzO6RXbBbu76509Itrn7iuXU581s8RyTu",
	"GRDp/sg/aSc9VXTFBWx8Ti7XTJANPbdYgQpp1kwRexdMG0/mEf0h5Q/aWccrOIb7ZJZ6MYk71de+1ObW",
	"Xlt29x2wuzdxxR3Z64C7Ti3pePPh5nsHe5MgsLqhux9VW3/48AutKl5sP3z4tSVxcVGwbfo+bvWyS7nK",
	"Cmro1WB09cJ2TQDofYahtkngpgDoZoHngFu4W4p6U8d1w4/tSjj2iFkTr+L6SFVrZp7Rkor8Rsjpwg01",
	"+YbfcMFhEd+jqut4zf6aw1HexBW7072Rh4xq68lP+Hi5qTccjAHXvtqbutJJF3nHEiFMeROH9KkA/wjx",
	"Nwvxz0qZn1/pLseuCkbdN7Pc3vy8cpua9ZncEi5Q++c4n2dyy+6ryLOwa5v8LJ7J7Qs3pVSftzSCG58C",
	"wc+cc4kGS6mIT9Zu+a9KSXUDt+tlw8565rMN05quWNr2Eu/RN5yyKb9guBBmtwAa6u8ZLc36+ZrdwkON",
	"xt7zXN83ytgbONhbRdmR3njf/qNd7RH22sMeiGWjafR9P737gy5aRz4dIbbutIsOp9+xPuySP3r7Q2xg",
	"SPjFOcfniBzZm6LONxDNgx/EB/GCLbkAa//ZB2Hx0OmCap7r01oz5QTMk5UkZ8QN+YIa+kHM5l0CNWSr",
	"Az8mt5qqXpQ8J+dsl7oFdLBK07ZyJS1lM9LQMvJliNyunAW5MUb0QQ4nyCxkyNpkzsszU+ySqiKxdB3s",
	"1zAy+n+NzTonbmw0szsvUjd++hn0fIgGSHvZIew64WrFRdsXyt7vD9I4wzS9JAhfpNZMk39saPULF+ZX",
	"kn2oHz/+ipGnVdUoxP/ROG7ZRYNJ7Ea167BxuM+MbY2iGbiaJLdvGK3g9teM6HoDtLgsCXRr+4cpuVJ0",
	"47xWup5nIxeA65hGy6IdwubeYa+P80jQ6N+g/QRXCG3ImpV937VD7yuS0K98XXuk/BFv6g8ffgFHaX8z",
	"wQdtRbnQnipovhL2EThnygUjueUCWHFCXi0JYLV5q7uLhHAYM6AOrtH/kby3ewTnCpJTAX6RVQGeaFwQ",
	"KnZdc65mxngb+lt2znbvI9+MA238zpGL7iGJRW2HC2SxuWFySTXZSLDv50yYcud8wxKgmV5MzYVBJ5WW",
	"p+EA0oBXE7kA2ocTo5ABJ8rII45WFVmVcuEwTQDRswCjvs8wUvnRLkDfAEJJCuVtp8z0QVCVOAh8iEN+",
	"pIdv1I53rWc4ur0rg9ySKw1+h4w6GkHjJ3IFyHNOkf2l/OeaAVcmFTgHtkFK+yedAvrg8zSfVVQZnvNq",
	"moUGR/+x1ccOso+0J4m5XHZpdo+kJkkINs4WVKfJN7NfLATWGh1m7R49ovMzIbcMOzgh4ODknuqiBB/a",
	"ELSCd0wVOPf6bWMQx9DS0u+CKdHwVH4Z7ROJmbc11d7PF5zVPYqYxOYMAO97ewAAwPbdRNAb863czluy",
	"Czp0/sO+Va9EYXEH022f5+A55clK3/XcuyhicJ73sPJuVd6Xyv5rob0uS8KXpBbnQl5a5vgQb6n5zHJ+",
	"dfqSpADOz765FR4HNvbg4xb8QEfXZlf19+Wy5IKRjPBwBgbOAOMKZM7Rfbt5n24OZgWDL4iFQTvA5BFS",
	"wB0tu5KyxIHJDzJ+sWJ1yCIF44BjqB8bkE30N0tLeMDgAa+HvtpcpKEx93jBcpgtYgkLg2CQBWMCXb4J",
	"F3Ni5bwLWlpuxUhkXsIg6dCIhy1W27F5+tEQH5/WPuCOgIodtCeke1fZTcws+kWnOdmRFS/kNoPgqv5a",
	"IUaqqrKA6qQodxiK0BX8YAS7H5kDhHgP2HO2wygIiMuBVwLaPodbFqyUlheUPQhrLmrP4q+78BtczTgL",
	"mIJmDaCHDFkDdiOxNHunHmC7hsDuIcDQNRbQ1e0Gx12nPdgr5feZg4ZKzhvXaMTIacQx9Pj6IN6Gm+S9",
	"DZxoXykUPCR/7HJISdVPqxXBJgunyog44RT1swgol0IzoWsIUDMyl+VJT+ejWcmAicxaTFt2znZpcZEB",
	"LXvnu0X6IPKQL6309ijiEhVbcW1YK4gs+LU3bvs7CLyqqDFM2Yn+98P/OPvlafY/NPv9cfaX///01z++",
	"/vjoi96PTz5+993/bf/01cfvHv3Hv80GCDTLKiXlcnh3plJLu7+3UgYCCB0JdGxt8853cCENy0AWyC5o",
	"OWBCso1eatBTvASxIcmbtS6bYAwkH9DywrTnbJcVvKzT8Orm/dsLO+0PAVHqegHInAvCqEWW1ORrYNFb",
	"09s2I1OXdO+GX+OGX9Mb2++012Cb2omVBZf2HJ/Ju+jg4jF0kADAFHD0b23wSEcQJHBVL1iJRrXhlAb4",
	"OAvb8GRMod17TIUfe0w2jVYxTLVwpORe2n6Kw7sACy/wPNxEQZW6t6OpugQwtCA9iKa5pEFZcus6g3h3",
	"sd7AjZJWHLiP19hef/ip27spkzzc3iEqMeSkegAGD8cNtge4Ii19PzTJyiPe0oCvJeJSMfJYdLnVDtCF",
	"2NdpF+NZEBeKK+tASseZ4psDQJaQ2nDvKVgkSyU38PL6TGsEnHxA+dECwYbkdGZ1CXL68GKRJ0g6e42V",
	"jJZ/Y7ufbVu4VdvbM65Tn0yjC/LiohddrnU11zO7pCDfjbgX8tGzfgjsIZUK6r5bZtQDX0ApV2nVTrkC",
	"vkOumgDOGBwWzIrZbMvy2jSxux3VbdAu3y032VVTp4PtIgs55vUZ5x/goNxYe67ux4Anb/PmaFUpeUHL",
	"zNkVh3C8khcOx0Nzb4a8Y3Ys/cze//Xp6x/d8sGCxajKgjgzuCtoV302u7J8iVQDKNYnuFhTEzQNXfrv",
	"7Ipct2yRl5AXoSMxW07LARci6MbOHL1eZ5tcer78QEujM4njFkdM46wKlvHGpIGG8bYxnF5QXnpbgl9t",
	"mqjg5hp3hIPpSjzAtY3qkW9EdqOUove6069jDyaKZxhJgLDBNByaSJfoIMi5INyCYQIAdEN3Fm5QE9xH",
	"SaLegGop0yXP09YmsdAWJAQ6StjGBBoPiMl2REuL02PVPBrLNtMTlHKdRUZzJA/TO7EPnd1COk+uWvDf",
	"akZ4wYSxnxS8xc7ztK/Rp1i6sgiUMKdiKqY7FIJgwkPEH5eU5lqbC6NcRQiyck1/Undrbj/h7q4j/zQ6",
	"5D7/B4sYF35in5fecl8ETamHomDioKLlHnCA61w8Y4/LGHF7c4/PoYpacGdwucLt7E+86AUtl7wojS4O",
	"kqPiXEjXkp50tlTyd5bWHoLS9bI/fTQx9k4PPlkK6rybAWmIdxKkXeGqQjap6y4pSM/XXlSXdgZjS5OV",
	"s7mkwUc3xLbHRqG20+UAYof3F7n2gIDqDc9U4IN7Dtk9WxJT+tnG3rinOH7zbN2a+3oNermg+Xmae7Zr",
	"eto4tLVM5EYS3znkCWvf0gmJfONCW5dyq2Jqw02bDDSC2VU5YZx2Mg/csLwAVTGz67L2lVomhqnFJRXG",
	"J05zCM311gwtT7bXpVTaQB7E5C4LlvMNLdMscQGn/77FZBV8xTHlWa1ZlLDLDUQqyYVBKCq4rkq6Q5fB",
	"5mheLcnjeYTV3G0U/IJrvigZtPgSWyyoBmalUV35LnZ7TJi1huZPJjRf16JQrDBrl0tOSxKkFdD8BE+V",
	"BTOXjAnyGNp9+RfyEHx0NL9gj+wpOhZ0dvblXyDJGf7xOI3kIXXlGNItAOt6pJ+GY3BSwjEs+XSjprEw",
	"5mwexu8jrwm7TnlL0NKRhP1vaUMFXbG05+tmz5qwb+OS0DkXUWA6RmC2CDfp+ZmhFj9la6rXaf4Al0Fy",
	"udlws3E+G1puLDw1CaNwUj8c+iUghg/r8h/BIaoiab3e3eqY0gl/7a7Bbe0HumHtY50Tqomu7ZobfZlD",
	"iCfE5UwrwDcj0mjC2WACYXTCQ73zMkrvW5tl9u8kX1NFc4v+ToaWmy2+/bq/5GeQWI5ANmJW4FzTF37n",
	"566YZuoiffRqAOw9q+X6kodCimxjMUrxyGH59qsc9NFKBwB4jN71phkfeiq/ZUfJBsGtboEbjTD1tQBP",
	"jAx4TVAM+zkIHg/e2Z1DZq3S4EFre0M/vX3tuIyNVKyt+F34mJwWv6KYUZxdQCxC+pLsmNe8C1VOuoXr",
	"rP7Tmv09yxmxZf4tpwQBjNnuH4f9Od72kIgt5fk5YxUXq9OF7YOsOo7aZdJXTDDN9TABXa0t5NjPluRF",
	"GhEY2jno6buHdL/wAbvyigFOevVi36p7A7f9KDByZq++peVK9pPrYwdzeWQzmHf4lG07u94ffd5ZXKdt",
	"/ynIW/CI35ta4K1rO+zAbmkihkA9dwFL6ELUNufifi8pKN2ZKJBHBFy6pnzAx1MzVgy40TGY8Z1UhqMj",
	"C2Of2CnOKJqfJ/Vp7+0XHZzh0HM9covTk4NkQNX+o+3z3s+WMkXyDdOGbqo0JwG6cUQ2gLjs8YUuVuDS",
	"LJei0ERzkTPCKqnX+6K/B6IWtwImK7lGqhrnqc2lwkyhwDYZ2YnMnXokozHI7TVmSkoztFDgr+LgcSkN",
	"obVZM2GCXz6D1O3dnWBkEQhVSDMRK5M3loz5HKu0LHdzws0DHEc5D0lKNkydl4wYxRi5XEvNSMnoBWuq",
	"KMBoDzR5v+WFhhoJJdvyXK4UrdY8J1IVTGF5DdscBD3s5OZ7fEJcTKWLK3i/FbC9QjKUAuN94jZ9eEgw",
	"18Q7niOP0P0ZkttrVl4wfULeX0pchG7i0LXls1o9FrXBeKyCL5cMsAdsB+RD6Nd8iNYE9SDAdT8M6/Z0",
	"9zigB2GZXtMn33w7BGhPvvk2BWvvvn/65JtvLatFBaH1lpecql3czLaak0XNS+OSIlNywXIjVSz9cqEN",
	"o0UPtlB34mYBcr+sRe68sUKXuGrHu++ffvPlk//z5JtvnbIlmsXHnQJHKAgTF1xJYT95PVeAEDdlmI1t",
	"uTafgKEwW5GBqDagzzCoNNuK59iIuECGtq2yg8I2qDzxD79kxYqpOer04XnwDWvyQ1gxQirT6A6XDGOw",
	"LF3kwihZ1DnDrATvWngjWhbvLSmkuo+cTeCt+7IpzTq93s9T5BNCXoGs9Rg5fiHbO4Q3xi6YwhiZZqCH",
	"SByidWlDFXjpgNOO2yorHqVJe12tFC3YNBM7EKufsEeIpvcjXMjDBvjZtu9y8C02ucV8pnm8KEzC8igx",
	"zU3RnBEsMSggvB2KW3yJpUgUKzF0DKpYQNt5j/1fMpZpLtI6+iVjQJ5pnrPKQnpceo8xS2vwpcNbhkh3",
	"z7TZyxeGXzAMahvhMrOclnldIrc9wkJe5rRUbWNfyZZGWtiLSws1imtu51qA1zSWf8D5lKVhUQ9I8XPB",
	"1M61QBnfV1uw70Z1PFT6waNZyS5YWvJmFGNIv5eXZEPFLtyFnaJZxjyKNAsrRyYY3B/wtn9y6odo+fjO",
	"HECOL9JexcDhFvE9V0xxWfCccPFP5h56wFgeYrBsixSGixqq3SjWrBtJPYFw2G7Iax8C1FBSD/uhHfIg",
	"2GXrtotIUGgHCGhDzxku2wfuOu5m6p0qpnlRDyjcFc3bKzsMGN3jfUsNO1XhavUNwWUHeYVHPvbourDc",
	"AZvObfVPaRBPtfDyFGRFQzwVcTg84TPtsgX5lgNCtTTS60V9toww9gVTuu2NG2mq2XbP2LZFa3zMoaQk",
	"asEOnyXzzlZ6cL4douMG5jz/jOHu0J85b5/ECQ4kmAoL0Jfc5OtsIADJtsUWGMDVEeH7UyJ3Aa+QLZcs",
	"N1PWAJEsWL1ocBX42a7iBaMFRGA3QUkYjtRdysMfJLFD64jlEZqDINFwPDDKowOSTwcI2Qf8P8uJsH8h",
	"4X9gyJ/wDDyP4+4+rZzHNg54mnB/SnZMw6kE3+rojVRS0zJth/STFqyku7EpoUF70sDzelMs0hxqaZgl",
	"KOjLPRjU66d272xsctuku+HwPPuvIi6L0rtJmfDZ8nkPQ1iRyyCXcEgcMpvYD3aJvj7nnCxaGu+7j4D0",
	"cRL9SDz7xa8V/ugu9hOr2F3tT9zBr+lLjJJzJq+zCN+jYGD0gId9+8xl1JW0nHjTHTOGv+17cF6pc/rr",
	"BS0HAgPfskoxDTI8Je//+vS1c68YCg/MB6NZqXEZOwwlg0l2Ps5nA1kQPnz4BT14McdBuI2+aWnIaxed",
	"du3nXu+reXsNJaOMDtQ7gfcX9Dcfo0Qqyp3vUBMb2T9ZFy87/H7HZN3mgrubcFGog0/oe6rXL2lupNr1",
	"M2FasXcgxYwzTx9yxF9+m0bFdgnpScD27ZLXtNVXwaUM3Lk8ryKXvQw2BFLYrKnTavk/rRQepasJ361w",
	"35XRm7uI87kmajKv4TNmeiO+Ilb/pgfT3haLLMQrpCrjzWcubW2cq3NvkBLX2YavFLAj6VGH0+1GBqBE",
	"0DeywYkarY7lGOaTO0Da2nhnxc3yGv2LnzkF0K9EwbZMNVaTN83uOsUfULXDaMGUzhpFZxo3IbDfLe3G",
	"uHE7hTasGNGkLA98iugAUloWatL45dXGFxmwsCK7ZHy1Th/sj1ca2rK4+y/t4u4vLYXg3oBG/ql9kACR",
	"A4h22aDh0aTSEcYG07YZMD+bNW7/vgRLKmbli2pguaY4EBD+feCwuxVaEoha801VopOgQyW9PE8HJUZo",
	"YhluPzTmpuMKbj0ygF3ZQe3mAwKuupb96ZfGwwD+Lp7LTVWyYea5QvdOLFWOMjXk7ouKUnv7jMzzWjUG",
	"1q6j/8+05FgtVUP+PiFlBQn7KsOF/Q/kGJC1wf8zqux/0Cem/T+EqohPskPN4F4g7ZMfyIcQzqwwX6Aq",
	"0fVNcVFJv5reobQTOfn7BGddsHMJxgpwbW9y657S3KBt0rnsCWYupTrvs2BsW9m77ORXietn9tEpVaau",
	"CrXBoOfg3yAxX2DIgdZfnBQXTDm9v3T5CVHDb9aMq35mH+KW1/KH2INfU6jwiglhJrlg9CWgBMpvmDBU",
	"iw1kU4Z0QLEcGvnJ9P3hcrWrjDyFNtDkVBtV50ajS1wzZ+/W7UGj487+Ol9dkm0prdQcbXlGZopdMDqk",
	"osZ0X7/VzF4ymKlsYxIGSF3sVKTYPWMcWw/7LcduIBjnQnOD5h2XeJHaM9/Q6hec5VeSkbe44pDn3XYg",
	"G72qDvdawqFSS9e0NNmgFOH4N/KOliYm03ZBzscheIcMJ0hFDnEwXOnuvcf46hogaDfMijF2+vIK7PQg",
	"7oB5AyJGDqf9pC6YwrDWyeDws+/xcT670328DS+2jxWi/U3bRXwoEWpIqzD8V/+cmjy8VBQkml8TeBsJ",
	"Pzl4ukwYtbtKphm+ynQpD9jeO756ZzvsOVLfrHempbxkKrPzjlxx2Q5vwJatPMWh0ASOh14CrCB2M/pq",
	"B4EDH3QSrsv+s2jG7jhk0DKXImvNfrdYB/FlBtCVhYD1PadHN+3Tq7zseijWAiSx42I1nBTwnO3uh6ye",
	"8Lbt3SeYN4eVJRg4E4z5UV7FS2dARQNZm9HZk53eikPAabqiHSPvajBsaMNzJSk4IjTpi1mPg3XCFPjx",
	"hdMYc65IK28xyTN2fr+rWHBI7Rf52NDKyzMg51om+OQ2lUIhWWnKmzKXwlAO5TuSzD06orKyAkTV6J5P",
	"7hX4/hxR5o6fxfj55BsAoMgwFPsu2//3j8woxu7eu/Oc7bKSL5nhA8bYEmJo/8Z2xDc7uTGeYij5Tcug",
	"BpJ9if7wTUIfIhV+WcGXOG8QQTwKwara/6VJwQxTGwuKa3lJNnW+Bt6drpjPnAMGEfCq7kzUGt0nE2hn",
	"gHLBV7qiOQ6EAdolVSumiIuZJq7AbzCwbCiHd9J4wnbDIsFJiqaMXfvy+bzBoO0Id4FpMsrqk0gb5Jdx",
	"znanaHmD36+ASIaTAw0sDFIE3eKSrpVpKE5WtQdez1tGSywt1MrvFZZ/g8ZLuz6nQjjQeNlPwzV1e7AP",
	"eA61Zv19To9Eic82IeI2e5tqee8f7rDB3CymGMyHDbiA6PFAoG4PgaWSf3z5D6LYkilQYX3xBUzwxRdz",
	"1/QfT9qfLeB98UXat+eubPUh77wdw82bhJh28cqO3RIJPxRYwGJZ6O4vBbgwlmUnBEgUBOK+gWWhEBHB",
	"SlmxZGs84OjSIb+XYqu6pBj6woVgqtVpSuIWVAmYrXDqL/jz/Vak2sYsJrSOjiNV3DCqIHu1qp+dKlaY",
	"NieHBDVXHbFJcdOMiKkwrjPiS8zDEUaEoZZMXWfM926MCQXlVkJhPkNU0HEflg1MMd5wG5pCqLYvNOcT",
	"zoTwLvZbTUsXviYgWOw9JF3Jz5nAGnIW87nKoYQJXSunJrRrhfHsUtwwMibwumly1Wpy2ViFJpWjRth5",
	"eLswfEgghF0t61HYy5HjRTtseyt2juQayyHZmGvok0mC7+Q+cQzAWG2G7eadJMJxpAUk1PP9B4ZvqmU0",
	"ZZzTqeaanIEdao050h++evGI8G4h5zipXyR87d92XLBj2oowt0NvLd3UgoesYsnYUHhLJ9COLNmAenhf",
	"WYjlRVMRAlp1XZL3rnJiIP73VEOJB9fcRWnd0+j71iLJqxdJlqOVCvXgsgHz2UrJOh3JvML0vF3/SysY",
	"ANOFQj06dJ0++eZbUvAV0+aE/CfkSkPi26+71b5Nwpt6Xq2ygQQWFvJvIj/kgvOiOdfuQnvBstwF6cEw",
	"d3/DV8lWPZ8BX5KZbSrg+1WPZyGVi2iE1JERvmm5gd9EmDcXRlFEvplcLpPpVP8OvzeuCMrjZMX6tz4B",
	"K5+znWJX5V3+Bp3R82oU85QXoTTL1RBPyYaKMpbbxPP56knWvKAT8tr2JkwspbKS9qYG6x/bQlo1Z4SL",
	"uVTINWaaArWQZkz8zpQERYIg0hm7u28sHDZEHdIc+HntomrtGkLe1KCsfPgOuJk5LvIRyqn9p0ZqYTiy",
	"P/YYf45OsbKExy76P9e8TEBBJe13Ha9jToQkWHo9bolh/k3OPFyzC5NuAdLdPvM4d3SRNv9bSCgwD39T",
	"cqHRUuRrKppa0vsT9Pdhclr9117hmsQzv8lCAiPr/LTOcUIOhEsKVy7JCiiQvS5o1O52wRXdbZgwV8R8",
	"P2Jv9FeAWqpqXAJQAxKA772vMu0522VGpsdmaGxCzjyIWqA7RWwb7XE+IPeEmDNfhbvhXfEFWRZhWYOR",
	"NzJnet2pE+mCD9c52zUeMHFlOhSbriBlIVlMa8bf8w1r5BJk5FIsEJ9EElG8TMu1mCMIUfaDke2EYcah",
	"Qg9ABfYdh4nJtt8IbCPjby/vzxVeQeSaBLkpRkIrdhVrB7q1Cvm2kz6AzuCEvAhJU8D3D2PPm0wqqM/q",
	"eghihpCQ7JYrr/eiyuuwwYkQHOB2WE68hwhcA+SNbJs+l+Sa0HwJDYYUQb7ZdslU0y6ljPEtl+r3pmFf",
	"D+SbVVXZqUeVaKVNBQajoZtuHCErupt5ZnA2n9lt2X/ssu2/S/W7/aeqSqipWS37fpDpB+xgIoN5EiHf",
	"s7bU2mIkw0tsQGuPBnS01poLZF1ijddAVQ9VT8ZKdcwu3fzwnJbl+61wvoH9ULMRb0xaYbjZa+eFGTC0",
	"RePOZdZrrRx2iK0zNM8ti1c0KRCidT7QpFskAxMj9MtkjHho7sXQXRYghk2qVoP7BoVVnw3lOaFqVWM6",
	"njvY354dDJaG44XL4devb+ZYNkQLtWIFkcqltuJLl7dsKEH/xKJFtHI8I88b1rDJyjAA6XMr/LDKpcqW",
	"IsuDN7elk1bCNJJ8QC/oD7MT8gpzqChGC0SwihuWKp/T2j+kHb1kUDbYQ3QWbjcqjnZiX1GrPJEGyFYM",
	"fCoSBbM+14JMtNL1wI0NYSXkqtqX9Alu6LmdqXHwwUvKqRDSfEb3dGBBpnYVgzh2oapCZaaS2XP/rYag",
	"M4uwYdgBHa1UjK/EQK1vAJAl9YRAd68rSQ7aWMql34svXveoRGDHr4ZEwfKCg1l0YWEug1LpI27gCfQa",
	"zmKg+DgiuJB8UTfxLtrtMiplMG2LHs38GO0QANuzsje5vyvUz7p20azOAC2ssa9vK6gnUWYrpoXdofdx",
	"ZpGVc5Qzw7z6pd044ifFMk8/PcYSBabcr5sYoQ/iKfmdKemE1TCUfRCNbtzlXXb5Qk8SnUJ9DN3r1p3y",
	"wPojuPkR7nCwrs+HD79saY/LgDVdg7+4WommvXf8cqD+Q3zH3lTmCj5cs7ALzjhysE2cY98iRouikwo/",
	"9vtCJBNSueNpu0IYACz0cqDmxOhtLkdvc2T8VkaiSy8dYjreNPp00iTmfrr0J449UrGUw3GBTYGg/tRT",
	"Hn9wHpgEGl5Cvi5w+FlHwGOkbBdFz9GnoSKjW5wM6zshDoU4Q7v/XXk9Trn02Mzb5rz1OIY0S5mQrm1o",
	"daNFwfYij2jFwz4HbNDjoMnz5QizHy/KjQ0DNK4NltX0xsgEx3jg1v3o6RuEr93sTjTOwq/Xsi4LTMS/",
	"gdRkjYiZuBxXvSewhU1ZJfTiAKeLOK5ZRzPEZ03IKzsyLS/pTns9bQNYw8P5U8V0/QkdYZy7EJXL6bNR",
	"OXqOs5xXnAkTXG7ie7EwPqzdTA/stKQW6WBSNX4RlBbOF5829bDaljdveHOVfWhEoOfumGnZ1hbgwF4T",
	"bds892P7HYUrjejZ/iweqepo4Uj34DxnGh1Fdk6teCiOw16I5HCaYewmpGjHBA/YZIRtZC/tDVXnLRro",
	"HqsbQKwwgr81aovFiOLuNSsxM2cnLHkoaEaz0lkyfqwXJc/BigB+4MGu4IIACvKWikJuyEufP+fhz29f",
	"PiKK6bo0Hsh8ol8LfG4lnza7/uDGK7V0O38XBdCE7XPhDCorro1K6C3vPgmbNCzb529kGy21aZyO0F6N",
	"2Q97MeLcYcE0FYIJz9kuK3hZDwKybXVetPNP6noBpbu4wCS1C2pycGbpLUGPTL3HwcG2KXGr4OVw3Z1O",
	"ezCwXfdiWrNUnfdz3wBojyThravj2NMZbg5Fn64b4k8309XYQ+QOm8iJKC+uvU9fH6RD+K/FZEVTYOiW",
	"5T60KxjXMFttj9KmdKMIjqGRHWGvx2l7vIE6847Pgkmg4hTvc1x2QqD+jrY0nBH0L1zJyTJifpa1KHTn",
	"CJvS5yPm11Hex7E+vs2oJXeIKZjKCbTiaNsrAbuli0NpQqi1ljlvbPBQBhAL/v1dlDuXB65b4KI5ykrJ",
	"C16kio6XcsVzjRqYQw3Gr33fj/PZpi4Nv+I4b3xftGCnySFfOVIoCqoKwoon33zz5V/a2RHuEbrqH1LS",
	"u8dtyykZqeF5m48Nu5uAxPxVnqxkH2UN2trUqjE9BNtaKkfqdBMZLGQ4Gt7rWZ1/yGJHaATq0rLtpeHN",
	"T3P725rqdYM6o+KzUBSYEoevuk5/EHIU2fnuOCLdAXZ2Lb+MzvMYQhzNI7kPbyNGjwgPU1HimwiT9Guz",
	"ui2i2tXCi4/DhLOuSmZ5uwYHDmbW8VeDJN/P+Y73a7jH46VPHRpAsTlpORFMhWqZyYbjAgVBs6orOAf3",
	"zuddvK5UKrq1YtquKO18s1bJ5CNjKS+bZIOJNOMH3e27zpl2kpXAuQ1yuNX5J8ppMwYD9yOxQ9oPa5xl",
	"HkrPQKbE5YX8VN28VMPcc5SIdQz0B1OctuXn6UlO3HK6Tm5D3mm68v5p771Dmitz5zMhkFcI/o1TI/Cx",
	"AlPYuCx3aPt1+fDb53X9KP2PECCwlJjwQBiamyab9+ypG2nmqqvO1sZU+uz09PLy8sRPc5LLzekKgpwy",
	"I+t8feoHgsyNrWxqrosrBmXJbrkzPNfk6Y+vgEnmpmQQLwFXF+WwPZs9OXmM2Q6ZoBWfnc2+Onl88iU+",
	"kTXAxSlmFp6d/fFxPju9eHIa+0atUnEP7xhV+RrB2LU9gcx9DMXZV0Vo9FKqp344Z+cCE/Hs7Jde0jhQ",
	"rUKUCLd//1YztZv5mtWx3q+xvvbx4f6YetRLaXT4NbXCLAWKkdxz7ZFrAXgPEHbBBOEIiSXf8FCqXjGa",
	"rx2bllgztD1wwU1pELpi0XpPyE+aRaW55DmEHKF84QMYfGWp0GlgYXaI1LoaHNcPKMdTc7IN+H9S4U0t",
	"KwiyAyuZiByVT1q1bZxu3leDwwSj+Y7UorQMpbc3gZlYh61B2SPMcJNTdwIuus97SevhG/CTZG6FmV3h",
	"gTfi6hiDMAzcg/PrBrWmk5UdjM9DstTYUWTuq9L7uvF6TkL60Y5JYe4cPeyw+DnyRAIXBHQjGdqwcznP",
	"aFmmthkZF7vb/OvWbbOBftytrvM1uCR1F9pdGSbQdMkpQjyRO5u56x+5ifjQzOAeElqK1gFO6GOPg22r",
	"UhZsdrakpWbp42G4ydbRBI7QO+Di2TlPmE5QqkbfW51F7iCzVkCtbSGkSKcn7WUpNDtA3ZbozA59dfBs",
	"7u+Ts1Nc6715t9vIp8LIJrIc6sfZR+gSOiWpRgiNH8Z2e51pxz8PLd/TGe/K4u2ULlQM66tWTMGQIgdr",
	"mgZs4VXVCPPem6rgmi5KTEELeqiWKw7QB+CD2h5osfPNkpfwhuAWkfZhoohgvxSFRUwZFw1hJy+hlx16",
	"sSMRemkNMzICHEBAi2i8hQceZvhBisx12lBBV3aNFnQthY1DaNDkiKcKus0YeMdAMpRWPAAK4xy2w0xJ",
	"1xFrZIZfrXCOZRsA2zx5/Njzj06/Ho12+k+NkmAz4LAD+yHhcCkk5KtTjaYaCDVHW7eAfNOmqs2wc8zW",
	"ZMCt9Ef+STtCUdEVF86lDG52Q8+RqcfASOfR6TGUzyxhWaBgjnRMk3s1E5THDV/aPoBfk/x+e+UPwbPr",
	"kd3g19e6x8F6HcN1Mzr78A2nLPutA0D0Ssd6Hx/ns28+9y1YoKYrDeVWQO6Y/fqxI82c/uFdqnnxcVC0",
	"eS3leV0Fo4gV8izCd9bqtoSDbd27erYDJDEq4QRTi6c7gFKgxkKDUcIiZ/EZGVWzg/j1qVToBjHmkU8+",
	"8sl3wyffCik9gIDeIsFME6kjjZp9/fjrI5m9P2S2BOK3h8ye9jDAProrIkfPLh6VFaLbcuc16D42ChMF",
	"jVDnp1UFuShAK63vE52+cTHjz0qWj4reKyl6b5iUdt77AeJpM0vzUo/CahTx1TnYI0dw5Ag+R44gxJd+",
	"Ej7Aiyb3h/7fitXzSPOPNP/OaH540dMIfVw+80jfPX0PSpQjUT8S9c+NqCfSSR9G4r22Mq3MvBbJf45D",
	"P42XdpT/j7zAkRe4Hfm/hQAOFf2PDEEixcuRLTiyBZ83W3C4zB8Ygo4t9EZYgaMS4Ej4j4T/kysBjsT+",
	"KP0fyfznT+bjyLSpjnXtREPvW5XvFHNomxVEsEv72IwksrTEaA+FjwfaR+CPdONmIoOiclx2liXfOuzs",
	"s0C5kseND7eQhmEq+MFVQN4VGOxgx32MoB/y2w9f/0hO7JObx5PeXF721OnxFcQ5et/8f9pD84BYN+lB",
	"gtumT9Mf4mIhhb7mK5KFLA32lw3+BJG/7/jK/lTiT5BzACOuU0eg+Wr4DDR02+A/drxJm3SPP9pIO93C",
	"YueY9/SVpDnfe+n76qekBiIvlhgUF0+94SIbnT40uJElLNhSuiigaA10u2cNvsGhQRO3Ksj4nUV7WnGL",
	"gKH4Nnnj8A0V5O3L5+Srr776C8F3bwUbBJehDeOQWNIkXlzAGwU14fMULPT25XNYwLvg0jqp1d5LDRB1",
	"UzuHEe/fxv/E8aZ/yqC/Txkbgbt2GggnVGKNp3EuJVSCGlVY3Kyg/ScRkOezrlRx/aKOHUGpfZKdCY8x",
	"YP9ScusUu3Sc1aJtfBlKbHGASfn2zbwYpovyQ6tKRXh0yDGESN0myV4SoWOzqzHeR43zUXNwNDX/GU3N",
	"/9KRxNE5nf7RRtb7I4qjUnVDOsymSTqaOMUSd0nGXrb4T2cwvDW0cyCyubug0WtakY4mmM+Ele0hodOF",
	"3A4iov8F7J+V/lu8KDzDhdwS+67mjn3RnTy0oQG0djqHZ+63pvKw0++vpCvKlltMQtUKa0s/gMG4WJ3B",
	"AA8wAw4HbFI7PgQbcmHOvnzy1deuiaKXZLEzTM/demB15NuvYTW264PFt18/8NYHCvnl7U9nT7/7zo1R",
	"KS4MXZTMaRh6c2qjztasLKXr4Phj1mtoP5z913//z8nJyYMpqFxuLTZ/Koof6IbdPVJ/2twdF3A12Y3e",
	"SLvdXR16kgHF852uGLouZRhD/s/kNvXc7ZuJkooczfZHmnFzNEPXmw1VO4vrmYFnH4Ga85ZDJUCHG70y",
	"sWH6UHLTUBgoDx9ICOR5pW0uUEtlOcySbXkuV4pWa24pyu5kkk7mGSzvzvHtUTlwv5QDw8WiK15sO3Xb",
	"CRcF26bl9wDukzQNz+T2hZtSJguSfg7qAHwNuPEpiOlZ/JzbT/9I6Y6U7jYpHYLdBBp3kFbntJQrfYBq",
	"h9j2E4SC13KlP42O50iebsbr7RO7NP1J/Yug6FIw1Pfq8mNaYFdJa9y+ha2ypqju7WQHvv9sza3aPEq5",
	"yjzFODwN0OqF7fpZ807XUMWOKQHHA6piSza0HBOYJgVDHQ27R+J4ALVq+SJgxu879ELYP7sdfY8W8Ubn",
	"qwU3Q/PZb7O7jxY8hn8dw7+Oouldeg/AJZ/+4Z/nfo8BeOZTMpDbhtOlybh++tFX4FZ9BQDNTcWFd5hU",
	"GqY8opujMu9+uzp0MebpgpZU5GyvRg5Zb21ADe3L0FyuJSAUlw8fEMwoRvWTHWWjo2x0LKR3DGyaGth0",
	"Y0zXzXIjMfKcJKW94YIfs3WmqN6iIQ1Hke3PxIAckuqiZZ4AXazDT2P5LjDLhSWpmPliVOY7Zrs4Zrs4",
	"Zrs4Zrs4Zrv4NNboY16KY16Ko/j2r52XYorHiTNi2oVKwdCVudUYyf8gF3LbTii9TT2XmwUXrBGA/A6a",
	"otNG2ouCRmtqAh32DY0kOngZ7NlXpmQ5QF/BCQeE4pzxC/jvUjH2O8sMVZa5nkJvW7vxC4TSmNH8cW3M",
	"g/ZmmWJUuBGfD8RXp1YbSENrQq5aQonfydzyyTtZk0t4LCU/h/6urqY99A2xQNyp9W0kMaoeNE677hms",
	"Z2/mkfldGICOSVSOSVSOSVT+BNqQRSnzc336B1x1hnqEvUZs6DSkxHhmP+5TXOBjxOnSaaHiBd2tgnU0",
	"AAQ2d4y1/owhfpK2L3K2nJrUtqvk8xxwmhPjGjjcLh8cJK/D0uUGx8+j8vCoPDwqD4/Kw6Py8Jgq96iS",
	"PKokjyrJo0ryqJI8qiRvXSX5KdWIt19+86ioPCoqj2qbTxppE1/t6R9WJtofa0Os+Fi2KOSQ1jKGuikB",
	"N04ou7u0ZHeIQqLjOuixTn+cx7CUI3q5L1rhj/OZZurCv/ValbOz2dqYSp+dnrIt3VQlO8nl5hTyPrj+",
	"fwS+X242QKjCL27k6BeHyj7++vH/BQAA//+wB0HnoHkBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
