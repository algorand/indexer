// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplication(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplication converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplication(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplication(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplication, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
