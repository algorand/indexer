// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
