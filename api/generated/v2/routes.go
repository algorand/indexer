// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
