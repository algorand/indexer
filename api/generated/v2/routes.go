// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"2ZkR5icnjycf/08AAAD//2KBnx2YhQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
