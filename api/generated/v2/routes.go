// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
