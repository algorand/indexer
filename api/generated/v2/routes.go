// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ffqfAAAA//98eiePXR8BAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
