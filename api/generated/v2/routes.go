// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDandName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDandNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDandName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDandName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDandNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDandName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDandName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wHRJ41RYgEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
