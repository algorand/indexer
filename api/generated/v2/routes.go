// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
