// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5OgXh8o+/vrx/wUAAP//PMNEZwh7AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
