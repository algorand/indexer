// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wXvm46qsQAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
