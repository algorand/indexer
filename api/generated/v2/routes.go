// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
