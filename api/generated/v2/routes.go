// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
