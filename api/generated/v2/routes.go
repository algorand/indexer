// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"L5/+XwAAAP//zhXvg6x4AQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
