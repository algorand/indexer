// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"PAnd/nL7/wMAAP//AQG+AV/sAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
