// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
