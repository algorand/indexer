// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"OJaEvRYBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
