// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
