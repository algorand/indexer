// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
