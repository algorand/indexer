// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
