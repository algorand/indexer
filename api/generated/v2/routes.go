// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"2NgFSD796I/nbgOXq921OwDaNpyuTcb1hY6mrTs1bWn3ss0kXniPccYw5ZHdHC1zX7Zlrs8xT91Dxjst",
	"cih694rbX60lMJT4SfWtHNVPdtSNjrrR4XSjzxDHegy7+72H3R1MzjusABTz60mK4RsuODDffyC/O+qI",
	"4Zns9jY6aol/JJlnn6yqjkckrnG9VXU8JlYdE6uOiVXHxKpjYtU9e7OPKVDHFKijLvb7ToGaErHiC6ly",
	"EZcRjlm+e1J0jNTvOIhlsKjnslpwwVptxq+grRdlpEUUNIrfU/UN4b0SH6WwY12ZkuXI/erf7AxVn+cz",
	"/zIpVVZSnnLfdlbjAYSa19H88fNfe60NnqYAgx3xqWdIy8Luc1luiIEjVcCreKH49dwKyBvZkCs4LCW/",
	"gP7wlDvms1X4MF+3TBe86tGMOrdd9yw8ZLLLBnj3DqRjvt4xX++Yr/cHMG3Aa+X69CO+b44GhJ1OcOg0",
	"Zr34m/24y2KBhxGnS2cgxwDdr7V02ynCxR1TC75iip9kuouCNbcXQwohm0d73dFed7TXHe11R3vdsRDS",
	"0Qp4tAIerYBHK+DRCni0At6dFfBzWu6+tncBjrbBo23waCnZMzmm84riR6sT7U6PIVZ9LAdPuqcMhTHV",
	"TcmRcUrZ9GqEXxELibZrr8M6/XAeM0mO7OVLMcTCy/Dq0p/17rN77JpWdcngxT0o1eD6hwf7cllVcFGF",
	"X9zI0S+OlX366dP/BAAA//8umLpebh4BAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
