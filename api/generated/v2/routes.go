// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9f28cN5LoVyHmHRD73ozkxJcDYmBx8NprrLFONrCULPCsPBynu2aGUTfZS7IlTfL0",
	"3R9YRXazu9k9PbIsO7f6y9Y0fxSLxapi/eLvi0yVlZIgrVm8+H1Rcc1LsKDxL55lqpZ2JXL3Vw4m06Ky",
	"QsnFi/CNGauF3C6WC+F+rbjdLZYLyUto27j+y4WGf9ZCQ754YXUNy4XJdlByN7DdV651M9LNaqtWfoiX",
	"NMTb14vbiQ88zzUYM4Ty77LYMyGzos6BWc2l4Zn7ZNi1sDtmd8Iw35kJyZQEpjbM7jqN2UZAkZuTsMh/",
	"1qD30Sr95NNL4sVWaS7z1Ubpklu3At/v9uBnP8NKqwKGa3ylyrWQEFYEzYKazWRWsRw22GjHLXPQuXWG",
	"hlYxA1xnO7ZR+sAyCYh4rSDrcvHiw8KAzEHjTmcgrvC/Gw3wG6ws11uwi1+WPcTcusVtLOiVFWViaW/9",
	"zmkwdWENw7a4xq24AslcrxP2fW0sWwPjkr1/84o9f/78O0ZotJB7Ah1dVTt7vKZmF3JuIXyes6nv37zC",
	"+c/8Aue24lVViIy7dSeP28v2O3v7emwx3UESBCmkhS1oQrwxkD7bL92XiWlCx4kJeofV9Uic4fZnXtvd",
	"ypHYOBF4bmJYpuRGbGsNuaPc2gCdY1OBzIXcskvYj253M82nO61r2CgNMymaGt8rScfzf1aazmqtQWb7",
	"1VYDx2O243KIkvceFWan6iJnO36F6+Ylyhffl7m+tM9XvKgdikSm1ctiqwzjHoM5bHhdWBYmZrUsHH9z",
	"o3maZcKwSqsrkUO+dCz/eieyHcu4oSGwHbsWReHQXxvIx9CcXt2BM9d0cnDdCR+4oC8XGe26DmACbvAg",
	"rLJCGVhZdUCuBVHFZc5iSdQKOXOclGPnO2A4uftAEh5xJx1BF8WeWdzXnHHDOAsybcnEhu1Vza5xcwpx",
	"if39ahzWSuaQhpvTEcBO6xlD3wAZCeStlSqAS0ReIUphhxj7nt+Isi6ZrMs1aLf2wGasYhpsreUYBDTi",
	"gT0r+c1Kq1rmMyS1ZUrH3M1UkImNgJw1o4zB0k5zCB4hj4On1R8icMIgo+A0sxwAR8JNYlMcnbkvrOJb",
	"iPbkhP3kjxl+teoSZHMa2XqPnyoNV0LVpuk0AiNOPS7SEDplYVVp2IibIZBnHh2O1KmN5wWlF0SZkpYL",
	"CbljEwi0skDHZhSmaMJjpe2aG/jP/xgTNe1XDZewT3KPPgHQcpqrwM59ob7Tq2hmOHAkZ9LhRvXpb5L2",
	"ZtEdNlrRoU+IE/fVs4T0Na3Tf8ZFLZ7biO2Kfh6QlNieOw68EQVy518dJQU01MYpal1EBH5txFZyW2t4",
	"cSH/3f3FVuzMcplznbtfSvrp+7qw4kxs3U8F/fRObUV2JrYjyGxgTd5esFtJ/7jx0rcVe9MsNzVF+Jya",
	"oeKu4SXsNbg5eLbBf242iHW+0b8t6B4wNnNKVX+n1GVdxZjMOlfX9Z69fT1GXTjk3Jv4+c1Qgaff8Bya",
	"SkkDeAX3V/P3/jf3k2MfIJE7RpeU01+NQgWohaDSqgJtBcQGCPfff9OwWbxY/K/T1mBxSt3MqZ+w1Tnt",
	"mFigw8CtZwfEBjyDAO3YXFnVlvSc1ElrjsaHBrb+nO3mqfWvkNnFrevZBeMJlJXdP3UAe9jN/WEL/y8s",
	"lOYIvHmQudZ8/4nxSIJyhQJvOPJPBnLkkhXfCokLX7LrHUhW8kvHNLhUdgeaub0AY4PIJI2LpGhjCfFy",
	"12thJ4vUuUrsqfnoTW137T72tW17cEejpg96Gu4LXeZ+8XXEWehi7vE84HmIMfmxZ8JdJv/MCy4zuI9d",
	"XvuhZu/w90IKBOKvqsi9ieJxm902N6i8jy2+jwPsxjl4YLHRw4p8nPI+kGTuC0tHMLiAr0eab/byoyn+",
	"z4XKLu+0l1NbhaMemPmvwAu7e7WDTzB/NPYBKM4jl9o9kPS/CCkuF7ErcvYJjpA9PMeT+lhvwqOI/DZc",
	"EOO7XcJn5P3BQpKZxl0+uWXcuzXIynEhL+Rr2Agp3PcXFzLnlp+uuRGZOa0NaK8fnGwVe8H8kK+55Rdy",
	"seyzvzGfL1quPTRVvS5Exi5hn9oFMqkPR7i4+MCLrbq4+IVZZXkRGVQjQ7s3hLX3wCHJ0QQrRxmqtivv",
	"oFppuOY6T4BuGjMcjkwW/6lZl8yPTdZC7wDz46ePAa8qsypUxouVsdxCevlVVbjlxwogw07MbRkzVulg",
	"CxQmQIP7+4Oy3r7GrxnRF6sNGPbfJa8+CGl/YauL+tmz58BeVtU7N+aZg+O/vW3Mnad9RabyIxX3drCU",
	"nMOF436u5rHBaGQc9Ix6BdepSWPOfULUYRu2g8Jbcz8CT5HWemc0HdB8JxywFxcf0LeK5yGKL+BbLqQJ",
	"3NiIrXTE591Wa2CZEyCQn7C3G4bcZNnp7gMtPKdqjqww5Gli526NaJtlGZfogapy9MgIybjc9+1cBqwN",
	"VsX3cAn788i0e6SLNyPfz8rRzNgBqRw+IveT2nSPix+jv/neBo1CparYtlBrf6oasnjR0EXoM36AfnQA",
	"mHs4PEnVMKBhgt4rrhOIIOIfQcEdFurG+yjSTy2v4tqKTFTzTCsE4Y+dPm6QQ0w9ycbVps+tB8w0yb2p",
	"8WrNTZpxg/vi9sOdIcbRB2nDUQszkZ6EKzhhGCLlCXddoDezibSgk801ulnDsinyYAy0NJWAlq00DWB0",
	"MRKL7R03weOKjulwYGYJuBHl8dwhABVIR0VBgxSmo7EIN28BV3wM/+P+jrcydycJTNf73HgzAmPrH4Zl",
	"42Oj6LPg9QiujuDfWCyP8lUsF0661+ntUBKlew4FbGnh1DgQigftKxNtkIPj75tNISSwFRPNai2ulqIF",
	"VCbIZd7ycj8HOOXv35mjNjfA7BFSZByBXSlV0MDsBxWfTbk9BkgJArV7HsZWmkkV/Q0zLpRNGKBXKw+q",
	"f0Pe0R6iZev6o20c6uyN7+DHPhtLauadVoyarL2mGTHvFIk61pS5q500NUaMWJWp4mSgkhsoAMXxqsNZ",
	"V079TmoVgGR4FrpF6jp7IjZOyD8N+kGxZxq2wljQ/qqGEDbe09Y5vLfgIOPWgnYT/d8n//Xiw8vV/+Gr",
	"356tvvvfp7/8/h+3T/998OM3t3/60//r/vT89k9P/+vfUjeHK2VhtRHa2NUVL1KOuYuLD67RG4PK4BvX",
	"NM1+OqhiFNIjRq6wOO0l7Fe5KOr0bvt5//baTftDc28x9foS9ihkgGc7tuY226EU6kzv2kxMXfCDC35H",
	"C37H722982jJNXUTa6Vsb44/CFX1+MnUYUoQYIo4hrs2itIke+n6ncYDUoXM4QZDs4SNop7MgEGM0A2v",
	"KpHf9O6bNGqaLnCKY5Rb0pIHOEaM+MEOYCC6Ww5DHdxtONyP8VIdyxmKX5Px2k5mYcZpLDFCokMUTyVM",
	"CNseIsqRA4YIHrQtAS/+BvufXVtczuJ2ufi4a3IK137EA7j+sdneJJ4xWJauTR1r05Eo51Wl1RUvVpVW",
	"W83LMdLU6sqTJjZnvvkDs4f0lfX8Ly/f/ejBd/e1Argms87kqrBd9YdZlbtFKj1yQEJ0p9Pwwn2TlJdo",
	"88mYIEzHAHG9Ax+cGOk/jot54qLj1QiF+Ch6g8QmyIkjzQs0QWt/O/pkxgN8tDUrMgau7vXID05YmkIP",
	"cIN4honAxZKCXw1TPkCx0X1Q4cH7GBJJyfdu78iEOWQLsi5XjvBXphBZ+pIt18adHVmXbnjXmGHjEdXJ",
	"jViLEUOzrEU0lmtmZngie0BGcySRGfypY7hbK++6qKX4Zw1M5CCt+6TxPPSOiDsRIYp8KMic1B7O5Qem",
	"iPJ2+I+R7m6oMbmOQEyL9tgeOgD3dXM9CgttDLnuh8iMdYQ7I55xIIwmXBGePjw111J4s3KCTtKcxxEG",
	"xcsezvkJl+wdAToyRzKHZ5RPvxzn0a73Edy5ZcYIbsyGl5QbUBiVGKaW11xSML/rRzj0vQ3QDdf1ulbu",
	"npZxA0m3nTCrjVa/QfretXEbdb0DNCWgBcHGqERFDXtHY3dCiGPW2dgQ2mSrgN8YjlHSHtOhoo+s624a",
	"OeFI5ZGhF72iwRzDJZH1K0zJii3yI4cj9kOe0vjt4fAw989GVvDrNc8u06qMg+ll61LoGI6sYqFz2AVv",
	"42ppL/JONG2Fwc2rQJfCdh3KLTHcVS35Y5F8DpkoeZG2I+aI/fOOtM3FVlDGSW0gyrjwA7FKCWmJinJh",
	"qoLvyWnToubthj1bRglIfjdycSWMWBeALb6mFmtuUGo1xsGmi1seSLsz2PybGc13tcw15HZnCLFGsUZ1",
	"xEtUY6ldg70GkOwZtvv6O/YEbdRGXMFTh0WviyxefP0dZqnQH89Sws6naU3xlRwZyz88Y0nTMRrpaQwn",
	"pPyoKUYTknLHWdjEaaKuc84StvRc7/BZKrnkW0j7HssDMFFf3E00cfXwInNKDDNWqz0TNj0/WO7402rH",
	"zS4thQkMlqmyFLZ0B8gqZlTp6KlNYqBJw3CUZUZyuIErfESHQIWpYd2L/sObM0mWp1aNbpsfeAldtC4Z",
	"N8zUDuY2WckzxCSCNRjQV+lJ9MgGB7np+7InUslV6c5O/tTzsy79JSNtlOVFclobeFc/xmN66Lmqlhtl",
	"NYrYuoNYHvGkO6O41ul18tpN9dP7d14wlEpD13CyDgEkHRGjwWoBV8kT2482ajSTRlwEzKcUFIpvG8CK",
	"P8eQjSnYSl1eAlRCbk/Xrg+pEDRqX3nYggQjzPjB3u4cetxndxQjGxsOzdZQKLk1D38mA+AjNtMtIAW9",
	"fX0I6sHAIadwhU3HEePauSl+DDmINLRr//DYiJzLByMn3/u2475gx3QonuWVjz4hV0XXyErrveZo+gGZ",
	"k7jBY7jjQo44iAHyEWcX4IxnSltBPleAz+C6sqIEY3lZpZkiWjboJOKpdoA2XZyWZCBTMjfMCJkBg0qZ",
	"XRIR/RDH4VQ3EicrhCHWF5dnyZSmnDKUAFb1Agnnhn5Mhkx2YVxppewYoCgq4lhXpSzjtd2BtI2LGTDz",
	"u78SRztcoyZECjexLPa9Y8MhZ48XxX7JhP2KxkEnFsqFEvRlAcxqAHa9UwZYAfwK2jR/HO0rw85vRG4w",
	"ib+AG5GprebVTmRM6Rz0CXvj805RO6NOfr5nJ8yHonkX+fmNxOXlCkh1i9dJywwxDY2xLV7xkilZ7Ac/",
	"Y268geIKzAk7v1YEhGnDZo0Thp0e6xpvKZzlYrMBPKe4HFTqsF/7IYIJCxZg2YRmWL+mz3DabuQKtZkR",
	"5dbSDepGvqJGzEfedC2YvaNRkiYdCKqAfAvaqdyqJLSLEtowaadDKG3bi+QGKCDFcTYhrVZ5nQEF5551",
	"6DECSwxAahLXoyg8pKFQL6KFM1wCA091FwW8dD2je6BU3RXi3sEVaLZ2t6x2oCfEdCK4jOUaI8wAYw9p",
	"qZA/TTPnutpqnsM8wzsywZ+oRxNUGka4UscN8LNr31ebOrpJR+KnpXQUFOKkTMzLU7xsVPV6Pxap9YbK",
	"YGgoKIQGy0Zg2+VAsdoArIyQaavMBgB5O88yqBw5x9W0AByjIj0TWQVGlwbZ6nZYWnEFFNwzoQysMl5k",
	"dUFO7AlJf53xQneNqAVsrHIEFhdOaU0Vws21Ric6VWyg+bRjgFEPd6Icme59C9LiQ4EEdzh0z0E0DJdb",
	"FXAFacUdOEXN/VVdu0vuvtkLN0ULxpLOCx6VBnLSVdDzQbv9k79gRODTYfJUNw2k24oR5ObxPleghcpF",
	"xoT8FfxpbthSoBhk35mSVsgaK61oaOEmOcEwALAf5DekAD0WwO4+dCNgJFx3djuP9LluvIix/BII7BCq",
	"6EXj3D3VYERej5hYNM+6kB1HjP7wvucWTnWzteae6LLHoZpDPnXo+rTcI5vebg2xNMqnOsx3DrPiTXAa",
	"84x66N8LmTGh5cjdR1kV7AMhQr0Z+wq08XaaoSkFbg6M7Vp0xqd8Ia0qZSC/wyyr4Gc1o/PtiR23NBeU",
	"Lwrwxf7gHX0JDI4kUzUAmGths91qJB7NtaUWDob3/ZvWcEpSIfAUwmYDmZ0DAwY2UcGhUSjos4PiNfAc",
	"I1HbGDWKTuuD8uQHxdzQJtJrpBGohbZqDY7y9Ig8+YZCDhH/z2om7V8p/B+6bmYcg6DI+L1PG6mojSee",
	"NsCZsz0YxEpTzyY6I5UyvEhbnsOkORR8PzUlNuhO2ii2wfhOMoc7GeYECtxAVtvugUmofv6cTU3umvQX",
	"3BzP4amIa7T0d/IvWisdJ0b2nHGSgWvBQv0UutUo/B5yrZoclu4Gum9RzZZ2zhKM4VtIV4GKaTE0TJHg",
	"X6548RoKy1P16SoNxmm6jLPzv7x8550juWueCLPKRgNVufVR6JYz7zVM7p27qaV5GwVi4HdfCi9pGR0L",
	"vqDYC/d50HuemXdQPwTHnkRoiOUZAvS3EKzHKi685w9l3+s0Zn0o7DA4eU7AX7vB/UX4AFMcJLWSODt4",
	"SNFsh58p+auh64cm3zZac4SILy4+bFFzfRdFUl7C/pQ2INtxuYW2XFcnsatUOTl7Qph87PZOhRkeUdnV",
	"S8UdR2FswEPm4RkxOWI0VR4WOrXrEUoman342q7RsCkcD+ppJIjBiLIqCFlenXHKR9yLTSX2TmTsHumN",
	"6URuHIq9GGZyTAdc/F2+UmVVwDijq8iRRuUpSZZhlhDPc+F5fTB+qCyrdWsV64dU/MwLQbXSDGYKSaUq",
	"96+TGdL9B2tIqtrS/4Fr9x/KnOz+L4cCUB8PaUVuqMVygSNhqB4NFKL2Fk6I5qTC+76ptKOpUxfTOhF2",
	"IzRmmXOHTDRh1J2MF+wIL9yZgozQbQwkU5q+bPFLHGrJCBB065rwl2E5WNCl0yZ37qpeZzuMLuRbCMGG",
	"6KtGU2Zvos7oIeymG7jqPXam4hkNRKEMBddb0MxHFzBfw6UJUSi56FVs7LtV8XLJU4LlUAjksM4oqgFR",
	"IGQi0jKA0TJZ/P0OntXxeMoRwDCq8hOC9FHBmXF87wF6vewoCJQG3QlLbsC/R0XBwefP2pGKwjByee7y",
	"cB14HGoDw3XOd//EuE2winZtc7XcIXLHlVO7nqOcprNJXXfUjgkhId85ca95KN2W1unH8PMmdz1yuSVq",
	"OiNTMowXRSi6nKmyVBLNN+7W3/GdyZxh7IfBKsySgbyCQlWQbI1ImhF2aMRWQm5vJMUNnOGf5zcy1TYW",
	"v9g6Wl6qKEmkRNkuIma6KXsZ+RT+SRXv7zpiG6DZjhgeZrj7iG8oiqwZEYfagP6YMc/9GDMKUmylDvaz",
	"EPcYAsLc/g50pybgsg6lfrCyb5sHjCGLIWO49YbSqxbNHLnI0SeanOMOdSaw4PdU5rxGY3Fjh/bhQBjY",
	"Sl2doM8d2tV05QDXXsjtaiLSPMNQc98wlJ/BK1BykfHgjrx0Cfl06Sb09vVfV7nm/kkH139k+LYcR3tH",
	"SScaRJWs5TCdkD15+/opwyTQbmodb4tVtC/DHF52XB9jHkQUbzqAhSrt3w2KDcCYE64Xt8A2MCJGDuUy",
	"b67aNGZs1TecHoRyZiDWX7nBvGTf3DuMv9Doqw6QvtDycKg4V+voW/pysdWqTgfrbCmH789YDp2BzBSV",
	"jrfAUMWhEBKz499+/c3pN9/+J8vFFow9Yf/AGH7Sb4ZVErq7yURbfYF3PiBgTYIQKSo+TiCac+c3dBAP",
	"Iny8AA7z8DuczLiNVofP3wx7Sas5MbmV2mySeVV/x9+ZkN67qAPv0zDE7gzuRyXD7yhX/0b1xm+XiwPJ",
	"+8VVk7d/twNewFhRmuImQabPv1m1lHrC3rneDORGaXd/LGtb84Le1Qhmo5h6KNbctiWiMMxc/gZa4fVY",
	"MuVuw31ZIyJkYwwCz1DDNT6QxsHQZKc1UbdPzlAJWBKQT+n2lXgnrJZWFPirQ+PPERYrx+Ad0P/YiSJB",
	"BZVy300Mx5JJxajoYNySIsbanAmC2YfsdgjpYY9TnETaMLlZl7S+rTZxT5NqxM0vfdUHp4xinH1j0XjY",
	"1Vd8X4K0dzyjP1JviiCgd2amdUI9ohOG3odqSI09muHGdh+bPC//Xoa3XRFfiNa4jA1LBgMFUVNu3wzy",
	"FdtabYbEhBMamxqj0KLAvWC7ogtaawO9hD3T4T4el6chRfoOejcx8PQTXeeihFZTJdGeEopiFvP2r+Il",
	"7zAUgkzM5auJ5TTDTFOFGaGKcIWZoolmF44g27OmT/dhjKElY19B16HaKZHVjSDEW9oJe91EdqKtm2Kc",
	"2nBP/yRjzyJOeVtNGp3Q8cNOZPNDo/nFxYeK/MuJg+sbkNR1bYby1zfh2WbblHpMXNJDs5sN6LZd6qIc",
	"Wm70b23D4R09NBtW5+xwnuV9vDmSPkN+m1c4QSJaaNG9Siyp7EenAk3zTmRLcy35HLAoTZak8UERaEWP",
	"7nYdtWFOVmpkaKTc1PaHV7wozm8kzZRwdbcPcKR8QFQZyYe7N1zTsVbvBgrxaP7ExhZrnmVOQcjbcLoI",
	"zq8M69daoCC7YbWFju30SK6ZqKja0B/X29F1o1lhqMSIjHG9rUsysn769R1YwWhxIpH7TJuQMxoRF8Ud",
	"Ry9SKu1j7MXGJ1CM1UucWX+GV+Sm3orMx7h4+xVF+I1Q+tKpzlD5RFslV1njoXSyC5+oU+yCPHsXixP2",
	"luJxNfCcmKgWFlKVUDrrxyS1aygKtM/6536b3Y2qFJ24U9SpNGOQsjVg4duEJe2PWluHV6Ye2bExruSj",
	"fjqb9Bl26JWbyY/UbFLGpVT2D7RPG6VBbOVU6d4ND4zYDKM7Euy4yyV8Hk6MeDPg0o2KejcmRnZtHIxq",
	"kvJ8pWSxT3G3OOeqx97uUCboo2sD9QboUPWhvp1AioMBKt2hD2kOkRdkUnOgrPHCLZzOj4ZV4O/hRMmc",
	"EsrrNi7jQr5kv4FW/oLTDIXPrLaBhJRg6xPrThKdmuoPZtCtP+WR1TVo8RPay2htmIuLDzd8IAURpo+Q",
	"f3cr83Nwj9+MVDeI9zgY3H05g48sW0IzTiB27KWCi4sPG57nvfT3OFaDWE1TpIKw7cs8ILHw65GKCpO7",
	"uZnczYnxO9HX1+GGMlFpONxoKM79OmCcesypg9PGYrWFcIZTzzn8jXNxFmmEW9rHEkeYdYI8Jko/8RLv",
	"DC+bEuIeONXAd8I8C/HuuvC7Dnf/YhO4WbDwBx9Ur9QzPUzESl7da2Gpg8wjgnjccwmjfss2p8EXnQ/j",
	"Rena/lnl5lj1CkpPm7YPLX38BWs0Ebiv/Uh2HpdbaB9M0FBiGkZ7BUpsjq9N0zgV26JB5AtG1y1VLAtV",
	"WtoZYlwz9taNzItrvjfBttcS1vhwAatU9CFhV4rztMggmcaNztDn8B4yUQl8A6LLBRsaH7eIjbzBQZY1",
	"x3QogURcNZfqvMZkbN5We+r6FYJbwdet4ZGAXno086J7m6WBg/XStXkVxg4rarY0kmczaoonqoA1KD3A",
	"87zjZ5LZedPWsTyOehGTo2nGuZvsFzAeseNL18ht2vdcX3ZkIDfd1weotFpn1I6KEeWb3KEgubd+/9jW",
	"jMaAkcYW/TNo8g295zJXJXtTS6KCJz+/f/PUv0cViCxkLjvi85B8wbXKN8Na5YmK3Q4l91Wl/DL/TFXK",
	"i0GV8ruvdH598kBbY9XJQ5Qw+Tu2wlidMGE+fFnyKTYTfFfTfMab2Y9lNL4bcRo/090UKdKjRt7xsk1x",
	"l56I/Ch1pPO2Cbf0RJ3xhcNataQbwdWW8JNNIFYchnYowqs73kjxZ6+R4CRYaSrxUIbxT60ELhw961Rg",
	"IhyVHiwiNWFTy9z0UEhrFdPOrUktwSsJoc2kn2xMfM6VmWexF6wLCXqZfJR186RLv+Q4loOjwm/4rA69",
	"6NKvmdKi0r8imMjuK9RWZIZsFce6496FvrfLRVkXVtxxnO9DX/IPpiWmQA9YeJ+fQf7Nt99+/V273C+M",
	"XQ2RlAxY8cvyZkVue6/qt6ubwcTCVp5s1ZBljXpN9LY1IjdekiUWsGyDaI5zdiAg6fVGiw3e9/We8YjU",
	"lVNwCyvan5butx03u5Z1dl9345Izz6/6wT8YUP95Ss5Hh2L1UV7v3vEYYxztIfkSzkbMHoke5rLE7yNO",
	"MqzR6ZdIBkpHLyHLCHFdFeB0u5YHDs9NpveVVadha0jkhznPxLBidjxeGuvYAIv7KaeJUFKtUyZbjQuv",
	"0i1UdygrNsDPWQxXqubYToNxEKVDJXb64uKXtLJJCZRp7TLd6fbIvT3r4bSLccLbqIZbXRIQD3uWD9DA",
	"w4N0m3xcV8iNCg8j8wz1xlBA3ZuWFr6C52JnbWVenJ5eX1+fBLvTSabK0y3GmK+sqrPdaRho8HBvGM+X",
	"BXNcuNhbkRn28se3qDMJWwA9WAc3aN9qKGvxzckzdNpUIHklFi8Wz0+enXxNGNshEZxSfvfixe+3y8Xp",
	"1TencdDDNvnMAHCd7egi4NueYJop0O3mbd40eqP0yzCcdxDQQ0IvPozVq3dH1v39zxr0fhFK2cYGk9Zt",
	"NbeQffrnw8mG4TFqjMSztaZEtQR0hSiFnQLtdjhdWymGbyGa7YT9ZCAqx4ZvUQfFMkSwhmpiTacRwNwQ",
	"Kbha4h7mydGavVKLYVpcBmv0FrMZ0JEgo/i/k06pI2++9DWrfSmRbM9qWeAzszLypJlmaVgFi7LlM+4x",
	"4NMoQvCh8RpSYqFhkpWHcOUgPHJHppde+PLvX+i63RR3WfRbightw5ci35+v+Y7rNeGtzkvYjwHTpniN",
	"k9zBoKTpz2Pgh6MaXK5tBW8qjYUFMyvQOKTM0OprsLhlMBQRawqO/1wYvi4ACxvhLbDjMh49b009vyN2",
	"oFswYgy1g2oO4zP8guW5sU4HcvFvnj37iDf8Y3kw73le/4B66v3hziv2I0llTaFLMs7TvqKxhd65HXdg",
	"3tgVssvhyD+FJMGKb4X0bn+0l5T8Es0ikkLznT4NxobT6QOFkQc3JmPPtT3FzDBbtCKwi4Bj3+233N0u",
	"PywMCtfFL7c9kX36ewgIEvntqPx+p9RlXUVvgbb1uQdinNr6Hf3zHslzUow35qVw2pGYnbYR0XID5CJG",
	"lNU1TPONSIrTEAnxHn24K6+4+9n+JCfviPP2Cc9XmqbvjaQLJLQDJH3ar0E9h777tvYJAo8rQh8i9Edt",
	"sZcL62bZiBtPW8F5mqle1RKJVeZCCbQkFOiEwcGO1iPInDamRjRff09OHGLW40nvIfA+hTaxPd9XDg8F",
	"vgn0q8NWoJ+6dRI0jGnw+nh4VZytGltteGCcrcjOcta+Nc5WZHkku0tq7c076KnFz3mffLhIfw6jhXSN",
	"ruu9z7BN70Vay0lKg/OboSDwvz28DDg4JbdM6aggbDt1KXwJ1rHpmwb3AgJVz+zDwG8OwBAaHKvmfvYL",
	"fh8L0frpLQIrSnel86yLS/b+zSv2/Pnz7/yTPxZyr9iMIYeGpES0eCENC8q5bT7PYWjv37xCAM4aA9ms",
	"VgcJoKG++1o5jvjlLfzRnPGvZc74I90/CEs+Jddr45TJO60gNfm+CWjbuNv7vYv8i9zch8/cfPyzNCMV",
	"o4MM7Ux4b9enKANmliE/bj9uy++2mrbn37dV69Fev71/C0OPTObZ97oVzR5tfL1kpk9o54smOf29e3gO",
	"2/u69RaTZpC2SdrWlxKm/SN8UKB+MnNZN5f8CBJ+OLPZJzKWYTLBLD6PLafctTTUo/FrhvHrDVpvyHjj",
	"c1Ua/kHXqialoo1wTGq9zXOb9zq7G310tbx3UbuH+WpJr/Gm5nPfjpvvwe0F98yNmjM5T6i65o/itBGn",
	"gQ19IkGKw5/+HojosPD0KXaHXWWu4XzhGacBfS6xaXzRu1nk+YAeJpxy+UlFZkQBp77g+kG/EhZ069d8",
	"ud4pjEqMXyqfpJAw2aOgnSEKPoPR/tFu+D/dbviFsuOYDc3SHAbPtjwqEaHCfctkH0qIHBOg0KkYFNcq",
	"mNQtHmMUHmMUHmMUHmMUHmMUPkGMwmOEwGOEwKOm/z87QgATuRun+6BqY5zc7gCNUr47j95TveIxUm+q",
	"XD1QGsQrVa6FhFZXDitoExus8s8Vdos1h4ZYWyr4CQ6sa6VVMSKFQy3gJkN/uQhlj7l22vAcqdxZTQAQ",
	"6xNE87dLM8etjd4AL5TBV6eigtLS4bko9sz6N1u4UxnDSpZMbNhe1ewaD0shLrE/vmhA4RslFfns5pNg",
	"BaZ61A7vu6+aolOTMR33eW19DE95DE/5XOEp9Fr96e9Utp+upwdt8M3LQam7MT6xfug+TGRA06VDw2KA",
	"HtYKNLV/tLg74nqWSSJyEU/nSzSO4kc7xKMd4tEO8WiHeLRDPOZKPFpCHi0hj5aQR0vIoyXk0RLycJaQ",
	"z2m9+KMV8Xi0j3x59pHl4lva0+530FrpkehFLIGtr8Itu1tfDG54WRWApcUwmtX3byqT0cP8yDPD7Zps",
	"BdEvfq7bX27/fwAAAP//EM8KuUviAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
