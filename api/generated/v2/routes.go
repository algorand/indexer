// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
