// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplication(ctx echo.Context, applicationId uint64, params LookupApplicationParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"round":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplication converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplication(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplication(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplication, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"zL/OAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
