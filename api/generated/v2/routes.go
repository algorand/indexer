// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
