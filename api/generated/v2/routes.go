// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
