// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"n3769D8BAAD//9X7UAtdHwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
