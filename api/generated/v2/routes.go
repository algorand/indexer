// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
