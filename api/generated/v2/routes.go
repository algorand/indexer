// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
