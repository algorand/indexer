// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"KeYAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
