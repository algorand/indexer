// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
