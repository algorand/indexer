// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
