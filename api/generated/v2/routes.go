// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
