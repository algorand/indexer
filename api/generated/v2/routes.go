// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
