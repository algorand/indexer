// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+zurAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
