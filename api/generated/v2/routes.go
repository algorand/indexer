// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"header-only": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------
	if paramValue := ctx.QueryParam("header-only"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e4/btrYo/lUI/w6wk/6smTR94DTAwUF20qDBTrqDTNoN3Kb3blqibXZkUiWpmXF7",
	"890vuBZJURIp2/NKcuq/krH45uJ6P/6clXLTSMGE0bMnf84aquiGGabgL1qWshWm4JX9q2K6VLwxXIrZ",
	"E/+NaKO4WM3mM25/bahZz+YzQTesa2P7z2eK/d5yxarZE6NaNp/pcs021A5sto1t7Ub68GE+o1WlmNbj",
	"Wf8p6i3hoqzbihGjqNC0tJ80ueRmTcyaa+I6Ey6IFIzIJTHrXmOy5Kyu9Ilf9O8tU9to1W7y/BLns6uC",
	"1iupqKiKpVQbamZPZk9dvw87P7sZCiVrNt7jM7lZcMH8jljYULgcYiSp2BIarakhdnV2n76hkUQzqso1",
	"WUq1Y5u4iHivTLSb2ZNfZpqJiim4uZLxC/jvUjH2BysMVStmZr/OU3e3NEwVhm8SW3vpbk4x3dZGE2gL",
	"e1zxCyaI7XVCXrfakAUjVJC3L56Rr7766juCx2hY5QAuu6tu9nhP4RYqapj/vM+lvn3xDOY/cxvctxVt",
	"mpqX1O47+Xyedt/Jy+e5zfQHSQAkF4atmMKD15ql3+pT+2ViGt9x1wStWRcWbPIX6168JqUUS75qFass",
	"NLaa4dvUDRMVFytyzrbZKwzT3N0LXLClVGxPKMXGtwqm8fwfFU7LVikmym2xUozC01lTMT6St+4o9Fq2",
	"dUXW9AL2TTdAA1xfYvviPV/QurVHxEsln9YrqQl1J1ixJW1rQ/zEpBW1xVl2NAeHhGvSKHnBK1bNLRq/",
	"XPNyTUqqcQhoRy55XdvjbzWrcsec3t0OMA+d7LqudR6woU/3MLp97TgJdgUPYbz976/cc68qbn+iNeGG",
	"bTTRbbkmVLtVrWVtH7uekwiTkVqWtCYVNZRoIy2GWErlSDeij7nr33EjpIQLrMhiO2wpqt7ou/vY82FX",
	"TS3tzpa01ix9Xn738SHBLmMiSet65lCv5RjclEX4gTaNLmDHhTbUsLhN09gWQgqWoKThB6oU3dq/tdla",
	"dgFwxKy7naKspWaFkTs4Cc8cwIFFtD8+sYP4CvJuzQhMbj8gTwWQLSy6qestMe4CLEAQz0XMCV+SrWzJ",
	"JTydmp9Df7cbC9MbYi8frqzH8li+MQfco8NIgPZCyppRAaC9ZrRiqpCi3o7P7Qf4SOxHsqzp6oT8a83c",
	"Y7ZEzK4OlzMniplWCQtltSzPSSWZJkIaSwAN5WLIe+rM+uP17Fi6Y38LC3p5Qlz7J4nNLc2Fs6kCjZ6T",
	"itUM7qd7P/CrNkpu4d4sFM+JbCy8ytaM37Wo3LD4efjMAeaznHa8kx2brvmGm/F2X9Mrvmk3RLSbhb2x",
	"ZSDaRrqrAThVjJQAbose0mroimnCLE3nKCbAPPaS7R0qRst1HqHimnbg0A29KpRsRbUHN2yIVDG3oRtW",
	"8iVnFQmj5NbSTbNrPVwctp6OR4+W4wfJLifMsmM5gl0lrtViFvsFLii61RPykyN78NXIcyYCdUQ8z0ij",
	"2AWXrQ6dMmuEqaflUCENKxrFlvxqvMgzdxwWuWEbR5s3jjF0KIBVxOEBOxwiyuyaogkP5X4XVLNvv86x",
	"ft1Xxc7ZNkkvhgCA2wni9tp+wb7Tuwgz7HjUe8Ihsgcx/E3C3l5wB40KRBsJ9s5+dUglrdro9d9DuRHP",
	"jYJ1cSMlB47hKXPuKAYz3Z08pfmqwBFHr4Sv3lk2YslrYDF+s4/D32yrLV3q361nOjRfCWpaxZ68F1/Y",
	"v0hBzgwVFVWV/WWDP71ua8PP+Mr+VONPr+SKl2d8lTsUv9ak0gO6bfAfO15ayWGuwnZTU/jPqRkaahue",
	"s61idg5aLuGfqyUAEl2qP5BtBJJommVuASlB/5WU520TH2jZU3wttuTl8xywwJBT+BBwh26k0Ayg9iky",
	"Em/db/Yni/KYAIwe8QKnv2kJQlQ3dqNkw5ThLFY02v/+h2LL2ZPZ/3faKSZPsZs+dRN2cqvJkTJ8wNQ4",
	"FIaoyyE1ZAY2TWuQtKewQ3jOv4S1DefsrkUufmOlwQPqL+MB2zRm+9Au2K1d395p6Z5Asue5DYWKOzxH",
	"JO4FEOnxyD9pJ/g1dMUFbHxOLi2bvaHnFitQIc2aKWLvgmnjyTyiP6T8QUPqeAUnK5zMUi8mcaf6xpfa",
	"3dory+6eAbt7G1c8EBsPuOvUko43H25+dLC3CQKrW7r7SdXx+/e/0Kbh1dX797/2JC4uKnaVvo87vexa",
	"roqKGno9GF09t10TAPopw1BfLX9bAHS7wHPALdwvRb2t47rlx3YtHHvErIlXcXOkqjUzf6c1FeWtkNOF",
	"G2rvG37NBYdF/ICqruM1+2sOR3kbV+xO91YeMmrc937Cx8tNveFgx7jx1d7Wle51kfcsEcKUt3FIHwvw",
	"jxB/uxD/91qW59e6y6mrglF3zPy9UlLdAhR5/n2w6/lsw7SmK5bWj8cn6Rvuc3R+wXDtzG4BtIg/MFqb",
	"9bM1u4PDjMbecaTvOoXZLRzsnT6rSLe3a//RrnYw5P1hD3wJ0TT6Uz+9Twcp9Y58f1zeu9MhRt//jvVh",
	"l/zB64hjJXDC6cw5iHKBBgMuhb0p6nyo0ITzXrwXz9mSC7DIPnkvLB46XVDNS33aaqacEHCykuQJcUM+",
	"p4a+F7P5kBDm7CngJuNW07SLmpfknG1Tt4D+O2mVS72S79//Sow0tI7szZFXj7PydQrjMcjhBIWFDNma",
	"wnnDFYpdUlUllq6DjRFGRveiqVnnxI2NplDnbefGTz+DkYtKRuNUD/RNOuHJw0Xf1cbe74/SOOMhvSQI",
	"X6TVTJN/b2jzCxfmV1K8bx89+oqRp03TKS3/3fkF2UWD2eJWNaCwcbjPgl0ZRQtwB0hu3zDawO2vGdHt",
	"Bpxi6ppAt777kZIrRTfOs2Do2DRxAbiO/WhZtEPY3Bn2+jCPmMHxDdpPcIXQhqxZPXaNOvS+Iinq2te1",
	"QxKb8Dp9//4XcCj1NxNcnFaUC+2pguYrYR+B89VbMFJaLoBVJ+TlkgBWm/e6O49xhzED6uAa3evIO7tH",
	"MICTkgpwu2sqcHTiglCxHZrcNDPG2znfsnO2fRfZzw+0wzpnG7qDJFatHS6Qxe6GySXVZCPBBlsyYeqt",
	"899JgGZ6MS0XBh0Jeo5sGaQBrybyMLMPJ0YhGR+9yGuJNg1Z1XLhME0A0ScBRn2fPFJ5YxegbwGhJAWn",
	"vs9f+iCoShwEPsScm+LhG7Xj3egZTm7v2iC35EqDbxijjkbQ+IlcA/Kc49p4Kf9aM+DKpAIHrj5Iaf+k",
	"U0Af/FLms4Yqw0ve7KdFx9Hf9PrYQXaR9iQxl8shzR6R1CQJwcbFguo0+Wb2i4XAVqM/pt2jR3R+JuSW",
	"YQcnBJxQ3FNd1OCiGZz78Y6pAt9Rv210ds8tLf0umBIdT+WX0T+RmHlbU+3dSMEX2qOIvdicDPC+swcA",
	"AGzfTQS9Md/K7bw1u6C588/7v7wUlcUdTPddaoN3iycrY89m70aGQUzeC8a7vnh/F/uvhfa2rglfklac",
	"C3lpmeNDPFrmM8v5telLkgI4P/vmVngc2NiDj1vw33R0bXZV/1wuay4YKQgPZ2DgDNBtXZYcvYO79+nm",
	"YFYw+IJYGLQD7D1CCrijZTdS1jgw+VHGL1asDlmkYBxwDPVjA7KJ/mZpCQ8YPOD10J+WizQ0lh4vWA6z",
	"RyxhYRBrsGBMoFsu4WJOrJx3QWvLrRiJzEsYJO15/6DHajs2Tz/M8fFp7QPuCKjYQXtCuned3cTMol90",
	"mpOdWPE035K6Ag3nhVxEd1YT8QU7p87wCrmzegAbv8EChmrP4BHoRN6doumYonWofd75XCIaSUN7DmKS",
	"95I5sbGmIrhWvRmS7aQ+oteKYJOFk68j9iyFku2rKKXQTOgWgnKMLGV9MlJEaFYz4GyKHidRnLNtWoZh",
	"gGDPfLdISUEe8KUVKR5GrItiK64N6wXOBIfYzt93C8EmDTWGKTvR/37w309+eVr8L1r88aj47v8//fXP",
	"rz88/GL04+MP//Vf/7f/01cf/uvhf//HLEM1WNEoKZf53ZlGLe3+3koZsDJ0JNCxt81738GFNKwABrW4",
	"oHXG3cY2eqFBeH4BvGySYehdNsG4L55RPcK052xbVLxu0/Dq5v3Hczvtj0HfpNvFOdsCW8houSYLaso1",
	"8I296W2bialrunPDr3DDr+it7Xe/12Cb2omVBZf+HJ/Juxjg2il0kADAFHCMby17pBMIEkj9c1ajpScf",
	"j4yPs7INT6a0rKPHVPmxpwSmaBV5qoQjJffSd3DK7wK84SBAiZsokEyPdrSvgHsZYsBinuqSBgn+zgXZ",
	"eHexMOtGSUuz7uMNtjceft/t3Zb7ItzeIXoa5JRGAAYPxw22A7gi1fE4psEyyV79ja8lEhUw2lLEexs/",
	"oy5obr+L8SyIi+GTbSClg2nuDABZQpTAvadgkSyV3MDLGzOlEXDyjETeA8GO5AxmddktxvBikSdEXe+0",
	"oDFa/4Ntf7Zt4VZtb8+Y7vtkOgWFl2Gc2HKzq7mZLSAF+W7EnZCPLrk5sIc8CKiQ7dn2DnwBtVyl9Q31",
	"CvgOueoiv2JwWDAr+7ErVramC/ob6BODyvN+ucmh7jQdpROZbTEpxzT/AAflxtpxdW8CnrzLm6NNo+QF",
	"rQtn7MrheCUvHI6H5t42ds/sWPqZvfv+6as3bvlgVmFUFUGcye4K2jWfza4sXyJVBsX6oP41NUGTMKT/",
	"ztjFdc9AdgkB1QOJ2XJaDrgQQXfGz+j1OoPZ0vPlB5q/nJ0Wtzhhr2VNMNd2ena01vYttPSC8toruP1q",
	"00QFN9fZyA+mK/EAN7b0Rgb74lYpxeh1p1/HDkwUzzAROb3B+H1NpIuQDnIuCLegLQcA3dCthRtUT45R",
	"kmg3hX10ha55mTaBiIW2ICHQem8bE2icEZPtiJYWp8dqeTSWbab3ULoNFhnNkTxM7/2aO7uFdO5FreC/",
	"t4zwigljPyl4i4PnaV+jTytzbREoYePD9DP3KATBhIeIPy6bxY02F0a5jhBk5ZrxpO7W3H7C3d1E/ul0",
	"xGP+DxYxLfzEjhij5T4PmlIPRUHvTkXPZn2AP1c844jLmPDFco/PoYpWcGcFuMbt7M6a5gUtl/UkjS4O",
	"kqPiJCo3kp50sVTyD5bWHoLS9XI8fTQx9k4PvrcUNHg3GWmID5JCXeOqQhqamy4pSM83XtSQdgZjSpdS",
	"r7uk7KPLse2x0afvCZhB7PD+In8TEFC9NZQKfHDPIDVfT2JKP9vYRfQUx++erVvzWK9BLxe0PE9zz3ZN",
	"Tzsvq57d1kjiO4cEQ/1bOiGRw1Zo63L1NExtuOmTgU4wuy4njNPuzQN3LC9AVczsukxltZaJYVpxSYXx",
	"GZccQnO9NUPLk+11KZU2kPstucuKlXxD6zRLXMHpv+sxWRVfccyV1GoWZfpxA5FGcmEQiiqum5pu0Y+t",
	"O5qXS/JoHmE1dxsVv+CaL2oGLb7EFguqgVnpVFe+i90eE2atofnjPZqvW1EpVpm1S0KlJQnSCmh+gvvE",
	"gplLxgR5BO2+/I48AMcRzS/YQ3uKjgWdPfnyO8iOhH88SiN5SNc3hXQrwLoe6afhGDxncAxLPt2oaSyM",
	"CVfz+H3iNWHXfd4StHQkYfdb2lBBVyztjrnZsSbsC7cJVqzBuYgKU9ABs0W4Sc/PDLX4qVhTvU7zB7gM",
	"UsrNhpuNcyTQcmPhqcs0g5P64TCfHWL4sC7/Ebx0GpLW692vjgmztaR2Db5UP9IN6x/rnFBNdGvX3OnL",
	"HEI8IS7ZUoXZ7jqNJpyNnQsYFMtsgt55SRrFhQGJuTXL4j9JuaaKlhb9neSWWyy+/Xq85L9DRirCRCnt",
	"/OKwhd/7uSummbpIH73KgL1ntVxf8kBIUWwsRqkeOizff5VZx6G0V7rH6MOghOmh9+W37ChFFtzaHrjR",
	"CFPfCPDExIA3BMWwn4Pg8eCd3TtktioNHrS1N/TT21eOy9hIxfqK34UPFOnxK4oZxdkFOMinL8mOecO7",
	"UPVet3CT1X9cs79nOSO2zL/llCCAwZ7j44CsotG2cyK2lOfnjDVcrE4hEymy6jjqkElfMcE013kCulpb",
	"yLGfLcmLNCKY5HTBailW+v4h3S88Y1deMcBJL5/vWvVo4L4fBYZz7NS39FzJfnJ97GAuAWUB8+ZP2baz",
	"633jE1biOm37j0Hegpv2zpjkt65t3qva0kSMy3nmomjQhahvzsX9XlJQujNRIY8IuHRNuci4WjNWZdzo",
	"GMx4JpXh6MjC2Ed2ijOKludJfdo7+0UHZzh0p47c4vTekRugan9j+7zzs6VMkXzDtKGbJs1JgG4ckQ0g",
	"Lnt8oYsVuDQrpag00VyUjLBG6vWukORMKN2VgMlqrpGqxgkuS6kwxSCwTUYOwkX3PZLJwNj+Ggslpckt",
	"FPirOKJZSkNoa9ZMmOAsziAh9HAnGO4CQhXSTMTK5LUlYz45I63r7Zxw8zccRzkPSUo2TJ3XjBjFGLlc",
	"S81IzegF6zLHw2h/0+TdFa805IWv2RUv5UrRZs1LIlXF1Al54QzoIOhhJzffoxPiAv2cs/u7KwHbCxms",
	"433iNn3MQjDXxDueI48w/BkSemtWXzB9Qt5dSlyE7oKjteWzej0WrcEgoYovlwywB2wH5EPo132I1gQ5",
	"8MGfPAzr9nT/OGAEYYVe08fffJsDtMfffJuCtbMfnj7+5lvLalFBaHvFa07VNm5mW83JouW1cdlUKblg",
	"pZEqln650IbRagRbqDtxswC5X7aidN5YoUtcqeDsh6fffPn4/zz+5lunbIlm8cGQwBEKwsQFV1LYT17P",
	"FSDETRlmY1dcm4/AUJgrUYColtFnGFSaXYln2Ii4CKi+rXKAwjaoPPEPv2bViqk56vThefAN65IWWDFC",
	"KtPpDpcMA4MsXeTCKFm1JcNQ+bMe3oiWxUdLCjmyI2cTeOu+VES3Tq/38xT5hJCXIGs9Qo5fyP4O4Y2x",
	"C6YwcKMb6AESh2hd2lAFXjrgtOO2yqqHadLeNitFK7afiR2I1U/YI4R4+xEu5GED/GzbDzn4HpvcYz7T",
	"PF4UBmF5lJjmpmjOBJbICghvc8F0L7D8gmI1xjNB+ntoOx+x/0vGCs1FWke/ZAzIMy1L1lhIj+tmMWZp",
	"Db50eMsQfu2ZNnv5wvALhpFWE1xmUdK6bGvktidYyMuS1qpv7KvZ0kgLe3E5lU5xze1cC/CaxrzxOJ+y",
	"NCzqAXlnLpjauhYo4/s07fbdqIGHyjiisajZBUtL3oxiYOMP8pJsqNiGu7BTdMuYR+FPYeXIBIP7A972",
	"T079EC0f35kDyOlF2qvIHG4V33PDFJcVLwkXvzH30APG8hCD9R6kMFy0UOFDsW7dSOoJxGgO4zDHEKBy",
	"mSbsh37Ig2CXvduuIkGhHyCgDT1nuGwfTeq4m33vVDHNqzajcFe07K/sMGB0j/ctNexUhavVtwSXA+QV",
	"HvnUoxvC8gBsBrc1PqUsnurh5X2QFQ3xVMTh8ITPtEth41tmhGpppNeL+hQOYewLpnTfGzfSVLOrHWPb",
	"Fr3xMbGPkqgFO3yWwjtb6ex8W0THHcx5/hljsKE/c94+iRPMZD0KC9CX3JTrIhOAZNtiCwzgGojw4ymR",
	"u4BXyJZLVpp91gCRLFj2JLsK/GxX8ZzRCsKCu6AkDEcaLuXBj5LYoXXE8gjNQZDoOB4Y5eEBWWsDhOwC",
	"/p/lnrB/IeF/YMjf4xl4HsfdfVo5j20c8HQx6JRsmYZTCb7V0RtppKZ12g7pJ61YTbdTU0KD/qSB5/Wm",
	"WKQ51NIwS1DQlzvtJB9N7d7Z1OS2yXDD4XmOX0VcT2F4k99f0DoTK/WWNYppEGsoeff901fO4pyLmCqz",
	"AX7UuMh6Q0k2GcaHOchCaRSBTo3w3dWZS2rbc46M6MdoP496X88BJpc0LjpQ7xc7XtA/fNgGaSh37hRd",
	"uNj4ZF0I4Tioc5/Qj+6Ch5twgXkwSGonP1C9fkGtjL0dZ6yzkkAmFYSz2B1yxF9+m4ZOu4T0JGAOdEkm",
	"+hJ98LIBDxePvuVylGmCQKqJNXWCvv/TCiZRWonw3co7Q7Glu4s47+LYwYms4TNmZCK+usj4prPpKatF",
	"EVy4U1WG5jOXXjLOqbczboPrYsNXCjB0etR8WsxIJ56Ig0XOIFGqz2HhPOswANLexgcr7pbXiaR+5hRA",
	"vxQVu2KqUyS/7nY3SKSN0i4Uq9NFp/tJ4yYE9vvV6GAorZ1CG1ZNCJfLA58i2sRrS1X2Gr++3viiAKou",
	"ikvGV+v0wb651tCW6u++tIv7v7QUgnsNSsqn9kECRGYQ7bJDw5PJXyOMDdY+k7HImTVu/1OJH1PMslxN",
	"ZrmmOhAQ/jNz2MNs9wlErfmmqdFvyqGSUT6Wg2LFO/fuu48WuG1X6zt3lmbX9tm5fR/p665ld8aZac/o",
	"f4pnctPULM88N+jxhhVrUcyAHFtRgU+vspZl2arO5jT0ff6Z1hwrz2nIsyWkbCCxVmO4sP+BsGvZGvw/",
	"o8r+B90E+v9DqIr4JDvUDO4FMt34gXxU1czKNxVqV1zfFBeVdDUYHUo/t42/T/BfBNW/YKwCb98uB+Yp",
	"LQ2aa5wXk2DmUqrzMQvGrhp7l4OUE3EtsjE6pcq0TaU2GAcaTL4S83qFfHLjxUlxwZRThUqXRwyVnmbN",
	"uBonOyFueT0T8Q78mkKF18yRsZdVeiwBJVB+x4ShpiCT9RQypMRyaOQ6MHYRKtW2MfIU2kCTU21UWxqN",
	"XkLdnKNbtweNvgy7a6YMSbaltFJzNG8YWSh2wWhOa4cZkH5vmb1k0NzbxiQMkLrYfZHi8IxxbJ135Ywt",
	"4+j6T0uDGm+XIA1KWm9o8wvO8ispyFtcccjHbDuQjV41hzty4FDJIuC0NkVWinD8GzmjtYnJtF2QM/sG",
	"g3k+kSFyiNkIjvt3qOGrG4Cg3TCrptjpy2uw01ncAfMGRIwcTv9JXTCFkX57g8PPvseH+exe9/E2vNgx",
	"Voj2t98u4kOJUENaheG/+ufU5cukoiLR/JrA20i4DsHTZcKo7XWSb/BVoWt5wPbO+OrMdthxpL7Z6Exr",
	"eclUYeeduOK67/GNLXv5RENCeBwPDaesInYz+noHgQMfdBKuy+6z6MYe2KhpXUpR9Ga/X6yD+LIA6CpC",
	"DO+O06Ob/uk1XnY9FGsBkthyscrnSTtn209DVk84II7uEyw+eWUJxhIE+2aUau7S2ZTQZtBndHZkkbbi",
	"EHCaLrn+xLvKRlJseKkkBdtsl2aUjThYJ0yBa1M4jSl7c6ZYNuwNO7/bNiz46I2T8W9oE5UDp9oywSd3",
	"qRQK+RtTDmau1D1kZU0x9+ibx+oGEFWnez75pMD354gyD0zP0+dTbgCAIsNQ7M5p/z8+MqMYu3+Ht3O2",
	"LWq+ZIZnwnpqCCv8B9sS3+zk1niKXD6QnkENJPsaXYS7HCdEKvyygi9xKhWCeBTi97T/S5OKGaY2FhTX",
	"8pJs2nINvDtdMZ9MBAwi4Gg6mKg3uo+v7ifFcfEouqElDoQxqzVVK6aICyMlrlhiMLBsKId30jkHDiPF",
	"wG+Epoxdu1KcvMY41gh3gWkySnSSyKTil3HOtqdoeYPfr4FI8vlSMguDrCl3uKQbJV+J8/fsgNfzntES",
	"S4D0Uh6F5d+i8dKuz6kQDjRejjMT7bs92Ac8h1az8T73d86PzzYh4nZ729fyPj7cvMHcLPYxmOcNuIDo",
	"8UCgvgaBpZJ/f/lvotiSKVBhffEFTPDFF3PX9N+P+58t4H3xRdrd4b5s9XhGbgw3bxJi+kXmBnZLJPwa",
	"kpUv0bfFEjkpwKurrgdREaIiEAoLLAsFJ3FWy4YlW+MBR5cOKY8UW7U1xWgALgRTvU775LJAlYC5Ek79",
	"BX++uxKptjGLCa2j40gVIYtqg1+vOt+g2gxmEikhZ8d1R+yyfnQjYnaAm4z4AlMThBFhqCVTNxnznRtj",
	"j8JPK6EwxRsq6LiPVAWmGG+4D00hetUXhPI5OELEC/u9pbWL6BEQP/MO8lCU50xgrSeL+VyFP8KEbpVT",
	"E9q1wnh2KW4YGRN43TW5btWnYqqSiipRI+ycXl1kMuRUwa6W9ajs5cjpOgW2vRU7J9IvlZB/yTX0+fXA",
	"nWyXOAZgrDZ5u/kgr2rsfA45xnz/zPBdAYGuQH86+1aXRm1ArTFt9IOXzx8SSDGeS/YcCV+7tx3XMNhv",
	"RRjuPlrLMNvaIatYMpbz+B/EHpEly6iHd2XKX150SfKh1dBLc+cq94xN/oFqyHrvmrvAlU80ILm3SPLy",
	"eZLl6GWHPDiT+ny2UrJNB3euMGPpILIeBANgulCoR4eu08fffEsqvmLanJB/QfooJL7j+jj92yS8q7vT",
	"K+9FYGEhJSHyQy5eKZpz7S50FD/IXdwSDHP/N3ydBL7zGfAlhblKxcC+HPEspHFBXpBNL8I3Pc/Y24h8",
	"5cIoisi3kMtlMsPkP+H3zhVBeZys2PjW98DK52yr2HV5l39AZ/S8msQ89UWoVnE9xFOzXPG0+irxfL56",
	"XHQv6IS8sr0JE0uprKS9acH6x64g05QzwsVcKqRfMl0hSci8JP5gSoIiQRDpjN3DNxYOGwKxaAn8vHaB",
	"hnYNIZVkUFY+OANuZo6LfIhy6vipkVYYjuyPPcafo1NsLOGxi/7XmtcJKGik/a7jdcyJkARLJMctMfK5",
	"SyOGa3aRoz1Aut9nHqfTrdLmfwsJFaYm77LQd1qKck1FV/N1d87yMUzuV6dxVMsj8cxvM7f6xDo/rnOc",
	"kJkIMuEqyFgBBRJ6BY3a/S64odsNE+aamO8N9kZ/Bah5qKYlAJWRAHzvXRUkz9m2MDI9NkNjE3LmQdQC",
	"3Sli22iP84zcE8JwfLXcjnfFF2RZhGULRt7InOl1p06kCz5c52zbecDExbpQbLqGlIVkMa0Zf8c3rJNL",
	"kJFLsUB8L5KI4mVarsW0KYiy/zaxnTDMNFToDFRg32mY2Nv2G4FtZPwdpUK5xiuIXJMgXH8itGLbsH7s",
	"T6/gZj8OHnQGJ+R5yCMBvn8Yjtsll0B91tBDEJMmhPyfXHm9F1Vehw1OhOAAt8WyvyNE4Bogb2TbjLkk",
	"14SWy1Uo251QBPlmV0umunYpZYxvuVR/dA3HeiDfbFzxPdFKmwYMRrmb7hwhG7qdeWZwNp/Zbdl/7LLt",
	"v0v1xwxKoddQRrBZjv0g0w/YwUQB8ySiYGd9qbXHSIaX2IHWDg3oZPkpF9sHFqOIqh6qnoyV6phwt/vh",
	"Ga3rd1fC+QaOQ80mvDFpg+Fmr5wXZsDQFo07l1mvtXLYIbbO0LK0LF7VRYVH6/ybJsO6ARgrPq4cMOGh",
	"uRNDJyr4B9ikapXdNyisxmwoLwlVqxYzlNzD/nbsIFsti1curdm45JNj2RAttIpVRCqX7YcvXSqnXM7y",
	"Peu40MbxjLzsWMMuUD0D6XMr/LDGZQ+WoiiDN7elk1bCNJK8Ry/o97MT8hLTSihGK0SwihuWqijS2z9k",
	"YrxkUCnVQ3QRbjeqF3ViX1GvYosGyFYMfCoSNYQ+1xo1tNFt5sZyWAm5qv4lfYQbemZn6hx88JJKKoQ0",
	"n9E9HVijpp/YPY5daJpQrKZm9tx/byHozCJsGDajo5WK8ZXIlDcGAFlSTwj08LqS5KCPpVxGsvji9YhK",
	"BHb8ekgULC84GFZfp1UhRb2dcgNPoNdwFpl6y4jgQj463cW7aLfLKLv7flv0aOZNtEMAbM/K3ub+rlFS",
	"6MZ1hAYD9LDGrr69oJ5E5aGYFg6H3sWZRVbOSc4MU43XduOInxQrPP30GEtUmIW87WKE3oun5A+mpBNW",
	"w1D2QXS6cZeK1qVQPEl0CiUD9KjbcMoDSzLg5ie4w2ypk/fvf7miIy4D1nQD/uJ6VWt23vGLTEr8+I69",
	"qczlwL9hrQucceJguzjHsUWMVtUgO3js94VIJmS3xtN2tQEAWOhlJg3/5G0uJ29zYvxekpZLLx26su5J",
	"9OmkSUyHc+lPHHukYinzcYFdzZTx1Ps8/uA8sBdoeAn5psDhZ50Aj4lKRhQ9R5+GInVucTKs74Q4FOIM",
	"7f535fU49dJjM2+b89bjGNIsZUK6tqHNrdZJ2ok8ohXnfQ5Y1uOgS33kCLMfL0oXDAN0rg2W1fTGyATH",
	"eODW/ejpG4Svw4Q3NE5MrteyrSvMTb6BbE2diJm4HFfQJLCFXaUZ9OIAp4s4rllHM8RnTchLOzKtL+lW",
	"ez1tB1j54fypYgbzhI4wTueGyuX02agSPcdZyRvOhAkuN/G9WBjPazfTAzstqUU6mGeKXwSlhfPFp12J",
	"oL7lzRveXLETGhHouTtmWve1BTiw10TbNs/82H5H4UojerY7i0eqYFQ40h04z5lGJ5GdUyseiuOwFyI5",
	"nCaP3cSwsH3GJiNsI3tpr6k679FA91jdAGKFEfy9UXssRhR3P1VbP50jvHaWjDftouYlWBHADzzYFVwQ",
	"QEXeUlHJDXnh8+c8+Pnti4dEMd3WxgOZz31qgc+t5OMmHM9uvFFLt/OzKIAmbJ8LZ1BZcW1UQm9577uC",
	"rHC7/I1so6U2ndMR2qsxIdwoRpw7LJimQjDhOdsWFa/bLCDbVudVPyWfbhdQzYgLzNu5oKYEZ5bREvTE",
	"1DscHGybGrcKXg433el+Dwa2615Mb5Zm8H4+NQDaIUl46+o09nSGm0PRp+uG+NPNdD32ELnDLnIiShVq",
	"79OXTBgQ/hsxWdEUGLpluQ/tamh1zFbfo7SrZieCY2hkR9jpcdofL1N62/FZMAkU4eFjjstOCNTf0ZaO",
	"M4L+lavCV0fMz7IVlR4cYVcNesL8Osn7ONbHt5m05OaYgn05gV4cbX8lYLd0cShdCPWg4DtURsMaaP8U",
	"9dblgRvm/O+OslHyglepOsy1XPFSowbmUIPxK9/3w3y2aWvDrznOa98XLdhpcshXjhSKiqqKsOrxN998",
	"+V0/O8InhK7Gh5T07nHbckpGanjZ52PD7vZAYv4qT1ZyjLKytja16kwPwbY2h1qOnfPcYSYyWEg+Gt7r",
	"WZ1/yGJLaATq0rLtteHdT3P725rqdYc6o3qcUCeVEoevhk5/EHL0cQr+R4+iuJFfxuB55BBH90g+hbcR",
	"o0eEh31R4usIk4zLVbototrVwouPw4SzbmpmebsOB2Yz6/irQZLv5zzj47LW8XjpU4cGUH9LWk4EU6Fa",
	"ZrLjuEBB0K3qGs7Bo/M5i9eVSkW3VkzbFaWdb9YqmXxkKuVll2wwkXn5oLs9G5zpIFkJnFuWw23OP1JO",
	"mykY+DQSO6T9sKZZ5lx6BrJPXF7ITzXMS5XnnqNErFOgn01x2pef909y4pYzdHLLeafpxvunvfMOaa7y",
	"l8+EQF4i+HdOjcDHCkxh47Lcoe3XpQjvn9fNo/Q/QIDAUmLCA2FoCYICVgCdPXUjzVzBydnamEY/OT29",
	"vLw88dOclHJzuoIgp8LItlyf+oEgc2Mvm5rr4urjWLJbbw0vNXn65iUwydzUDOIl4OqiHLZPZo9PHmG2",
	"QyZow2dPZl+dPDr5Ep/IGuDiFDMLz578+WE+O714fBr7Rq1ScQ9njKpyjWDs2p5A5j6G4uzLKjR6IdVT",
	"P5yzc4GJePbkl2QNd4wS4fbv31umtjNfxjfW+3XW1zE+3B1Tj3opjQ6/plWYpUAxUnquPXItAO8Bwi6Y",
	"IBwhseYbHqp3K0bLtWPTEmuGtgcuuKuWQFcsWu8J+UmzqFqRPIeQI5QvfACDL7YTOmUWZodIravDceOA",
	"cjw1J9uA/ycV3tSygiA7sJKJyFH5pFfuw+nmfYEsTDBabkkrastQensTmIl12BpUgsEMNyV1J+Ci+7yX",
	"tM7fgJ+kcCss7AoPvBFX2hWEYeAenF83qDWdrOxgfB6SpcaOInNfqNuX0tZzEtKPDkwKc+foYYfFz5En",
	"ErggoBtJbsPO5bygdZ3aZmRcHG7z+yu3zQ76cbe6LdfgkjRc6HBlmEDTJafoKvzj2cxd/8hNxIdmBveQ",
	"0FL0DnCPPvY42FVTy4rNnixprVn6eBhusnc0gSP0Drh4ds4TZhCUqtH3VheRO8isF1BrWwgp0ulJR1kK",
	"zRZQtyU6s0NfHTybT/fJ2Slu9N68223kU2FkF1kOJbXsI3QJnZJUI4TG57HdTmfa6c+55Xs6411ZunL6",
	"mO0KSk42TMGQogRrmgZs4VXVCPPem6rimi5qTEELeqieKw7QB+CD+h5osfPNktfwhuAWkfZhoohgvxSV",
	"RUwFFx1hJy+glx16sSUReukNMzECHEBAi2i8hQceZvhRisJ12lBBV3aNFnQthY1DaNDkiKcKus0YeKdA",
	"MlSbOwAK4xy2eaZk6Ig1McOvUBkfyjYAtnn86JHnH51+PRrt9DeNkmA3YN6B/ZBwuBQS8gV7JlMNhDKM",
	"vVtAvmnTtCbvHHNlCuBWxiP/pB2haOiKC+dSBje7oefI1GNgpPPo9BjKZ5awLFAwRzqmyb2aPZTHHV/a",
	"P4Bfk/x+f+UPwLProd3g1ze6x2y9jnzdjME+fMN9lv3WASB6pWO9jw/z2Tef+xYsUNOVhnIrIHfMfv0w",
	"kGZO//Qu1bz6kBVtXkl53jbBKBKXkx9JONjWvau/bwFJTEo4wdTi6Q6gFKix0GGUsMhZfEZGtewgfn1f",
	"KnSLGPPIJx/55Pvhk++ElB5AQO+QYKaJ1JFGzb5+9PWRzH46ZLYG4reDzJ6OMMAuuisiR88hHpUNott6",
	"6zXoPjYKEwVNUOenTQO5KEArrT8lOn3rYsZflSwfFb3XUvTeMikdvPcDxNNulu6lHoXVKOJrcLBHjuDI",
	"EXyOHEGIL/0ofIAXTT4d+n8nVs8jzT/S/Huj+eFF70fo4/KZR/ru6XtQohyJ+pGof25EPZFO+jAS77WV",
	"aWXmjUj+Mxz6aby0o/x/5AWOvMDdyP89BHCo6H9kCBIpXo5swZEt+LzZgsNl/sAQDGyht8IKHJUAR8J/",
	"JPwfXQlwJPZH6f9I5j9/Mh9Hpu3rWNdPNPSuV/lOMYe2WUUEu7SPzUgia0uMdlD4eKBdBP5IN24nMigq",
	"x2VnWfIrh519FihX8rjz4RbSMEwFn10F5F2BwQ523McI+pzffvj6Z3Jin9w8nvT28rKnTo+vIM7R++b/",
	"Zg/NA2LbpQcJbps+TX+Ii4UU+pqvSBGyNNhfNvgTRP6e8ZX9qcafIOcARlynjkDzVf4MNHTb4D92vL02",
	"6R5/tJF+uoXF1jHv6StJc76fpO+rn5IaiLxYYlBcPPWGi2Jy+tDgVpawYEvpooCiNdCrHWvwDQ4NmrhT",
	"QcbvLNrTilsEDMW3yWuHb6ggb188I1999dV3BN+9FWwQXHIbxiGxpEm8uIA3KmrC532w0NsXz2ABZ8Gl",
	"da9WOy81QNRt7RxG/PQ2/heON/1LBv19zNgI3LXTQDihEms8TXMpoRLUpMLidgXtv4iAPJ8NpYqbF3Uc",
	"CEr9kxxMeIwB+x8lt+5jl46zWvSNL7nEFgeYlO/ezIthuig/9KpUhEeHHEOI1O2S7CUROja7HuN91Dgf",
	"NQdHU/Nf0dT8PzqSODqn0z/7yHp3RHFUqi6nw+yapKOJUyzxkGTsZIv/cgbDO0M7ByKb+wsavaEV6WiC",
	"+UxY2RESOvXlrPfERMS23wMdvZIr/XFQ0pHVuh0jzUfWwP9F1eGQIzzolUZlJDGLlUv8Pi2OuQLWXQ2o",
	"u0lmdWe0Ml+yteHV1aB6MuGiYleZHPh3yaLXclV49H941Orque2aqr//GXD+iKpvwDlM0axp/79Y8QIt",
	"p5KJ7uW7d9RDHInjAdSqpzpzJU3vT2m2e3Y7ena3dGC4u4X5WsFNbj77bXb/zq1Hb8Wjt+JRzrxPZRdc",
	"8umf/nnuVnC5Upq7E+bZhvtLk3G5v6Nq605VW4Dm9sWF95gDDaY8opujZu7T1swNMebpgtZUlGynRg5Z",
	"b41VjX3W5Mu1BITi0jcCgpnEqH6yo2x0lI2OdR+Ofnj7+uHdGtN1u9xIjDz3ktJec8GPyWVSVG/RkYaj",
	"yPZXYkAOiczqmSdAF+vw01R4FgZlWZKKgVqTMt8xOOsYnHUMzjoGZx2Dsz6ONfoYRnUMozqKb/+zw6j2",
	"8TjxFby5iOvXxygfyH+WC7lrJ5TRpp7JzYIL1glAfgddjTQjXd1XcrmmJtBh39BIooOXwY59FUrWGfoK",
	"TjggFJeMX8B/l4qxP1hhqLLM9T70trcbv0Co5BLNH5dyOWhvlilGhRvx4Wu+mJraQNYkE1IrEUr8TuaW",
	"T97KllzCY6n5OfR3ZWDsoW+IBeJBaTojiVFt1jjtuhewnp2BcvP7MAAdY/6OMX/HmL+/gDZkUcvyXJ/+",
	"CVddoB5hpxEbOuWUGH+3H3cpLvAx4nTpKOZ4QTdEaj8wWjFFpCX6y5quTsi/7OOE1weupcZj6Hmns4E9",
	"kkoy1IU4BcCQB9AZ/LeGKQs75d2iwKknjzdxjGP4jJ/nXqrJyDN034RRQ42kZ9fTbKOrGztk2oOYeFgq",
	"quCletR0HjWdR03nUdN51HQe01Ad9adH/elRf3rUnx71p0f96Z3rTz+mzvPuS9sctapHrepRbfNRw4Li",
	"qz3908pEuwODiBUf6x6FzKlYY6jbJzrICWX754L8jFBIdFwHPdb9H+cxhuaIXj4VrfCH+UwzdeHfeqvq",
	"2ZPZ2phGPzk9ZVd009TspJSbU0hS4fr/Gfh+udkAoQq/uJGjXxwq+/Drh/8XAAD//wAi0g/MZQEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
