// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
