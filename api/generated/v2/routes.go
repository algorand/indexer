// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
