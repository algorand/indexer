// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
