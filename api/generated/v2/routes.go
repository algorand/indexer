// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
