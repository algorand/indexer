// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"X9HFgqnMzowwPzl5PPn0/wIAAP//csXxQ8d9AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
