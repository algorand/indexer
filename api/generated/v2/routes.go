// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
