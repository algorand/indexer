// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/l8AAAD//84PGZ5wfgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
