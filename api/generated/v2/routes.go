// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
