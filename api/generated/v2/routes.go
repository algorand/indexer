// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDandName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDandNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDandName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDandName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDandNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDandName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDandName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/XMbN7Lgv4LivSrbOY7k2EnqoqrUK9mOd13rfJTtZN/bKHcLzoAkoiEwC2AkMjn/",
	"76/QDWAwMxhyKFGyveFPtjj4aACN7kZ//jHJ5aqSggmjJ2d/TCqq6IoZpuAvmueyFibjhf2rYDpXvDJc",
	"ismZ/0a0UVwsJtMJt79W1Cwn04mgK9a0sf2nE8X+VXPFismZUTWbTnS+ZCtqBzabyrZ2I71/P53QolBM",
	"6/6sP4hyQ7jIy7pgxCgqNM3tJ02uuVkSs+SauM6ECyIFI3JOzLLVmMw5Kwt94oH+V83UJoLaTT4M4nSy",
	"zmi5kIqKIptLtaJmcjY5d/3e7/zsZsiULFl/jc/lasYF8ytiYUHhcIiRpGBzaLSkhljo7Dp9QyOJZlTl",
	"SzKXascyEYh4rUzUq8nZLxPNRMEUnFzO+BX8d64Y+51lhqoFM5Nfp6mzmxumMsNXiaW9cienmK5Lowm0",
	"hTUu+BUTxPY6Id/V2pAZI1SQNy+fk6dPn35NcBsNKxzCDa6qmT1eUziFghrmP4851Dcvn8P8b90Cx7ai",
	"VVXynNp1J6/PefOdvHoxtJj2IAmE5MKwBVO48Vqz9F09t1+2TOM77pqgNsvMos3wwbobr0kuxZwvasUK",
	"i421Zng3dcVEwcWCXLLN4BGGae7uBs7YXCo2Ekux8UHRNJ7/g+LpTK4zhKmHNGQm18R+s5R0IWmZUbWA",
	"FZIHTOTSnuPZFS1r9uCEvJSKcGH01J01cw25MGefP3n6hWui6DWZbQzrtZt99cXZ+TffuGaV4sLQWcnc",
	"Nvaaa6POlqwspevgiFl/XPvh7L/++x8nJycPhg4D/hnPoNJb+5cfzl9TNbjz0ee8VoqJfJMtFKNArZZU",
	"9Pf/jcM+vZR1WZAlvQJUoytgu64vsX3xasFJnJDveK7kebmQmlCHtAWb07o0xE9MalFaNmFHc1efcE0q",
	"Ja94wYqpPe/rJc+XJKduM6EdueZlaTG+1qwY2sz06nZQltDJwnWj/YAFfbyb0axrx06wNdCe/vK/XTsK",
	"WxTc/kRLwg1baaLrfEmodlAtZVnghYmYByllTktSUEOJNtIS5blUTlpCij11/RsBkORwgAWZbbotRdEa",
	"fXcfuz9sXZXSrmxOS83S++VXH28SrDKWS2hZThy3s0KamzILP9Cq0hmsONOGGha3qSrbQkjBEsJL+IEq",
	"RTf2b202VkIDsjxpTifLS6lZZuQO4c3LY7BhkbgV79heohx5t2QEJrcfUIwFzBaWzpTlhhh3ABYhiBfc",
	"poTPyUbW5BquTskvob9bjcXpFbGHD0fWkjItJRxC7t5mJFB7JmXJqADUdmJ7Zs9vWIAoPV5jcysrwARF",
	"kC2mpGAlg0U2SAi/aqPkBhZvUWFKZGUPXdamfzlE4YbFz927Aogz+EKIV7Jj0SVfcdNf7nd0zVf1ioh6",
	"NWPKHrgXNowkiplaCThsxUgOZzZr3fyKLpgmzMoiHJ83MI8lXEIaohjNl8NUCWHaQYhWdJ0pWYtihBRv",
	"iFSxlKQrlvM5ZwUJowzB0kyzCx4u9oOneVtE4PhBBsEJs+wAR7B14ljt9bRf4ICiUz0hPzneAV+NvGQi",
	"sBgkloxUil1xWevQaUhcsVNvfz8LaVhWKTbn6z6Qb912WAqBbRyDWzmBNpfCUC5YYXkfAC0NQ2ozCFM0",
	"4b6S04xq9tUXQ4JT81WxS7ZJEt0uAuBygppgab9g3+2rCDPsuNQj8RB5bIx/W3FvFN5BowzJRkJGsl8d",
	"UUmrZFr9R8i88dyoEMhupZzBMTx7G9qKzkx39w7UfJHhiL1bwhfvLC+e8xL49G/2cviTrbXlS+2z9Zxb",
	"84Wgplbs7EJ8Zv8iGXlrqCioKuwvK/zpu7o0/C1f2J9K/Om1XPD8LV8MbYqHNamsgW4r/MeOl1bOmHVY",
	"bmoK/zk1Q0Vtw0u2UczOQfM5/LOeAyLRufodZa9yaOaUZuK1lJd1Fe9k3tLUzTbk1YshLIEhtxFCIBq6",
	"kkIzQNdzlCDeuN/sT5bWMQGkPBICTn/TEp4gzdiVkhVThrNYM2r/+x+KzSdnk/912mhST7GbPnUTNq8+",
	"M8TD8OZS42gX0ixHzVAKWFW1QZ6eIgvhHv8SYOvO2RyLnP3GcoMb1AbjIVtVZvPIAuxg14fbLd0S50fu",
	"W1ckv8N9RK6eAXfuj/yTds+mii64gIVPyfWSCbKil5YcUCHNkiliz4Jp4/k70j1k+UGl64QEJ2mfTFI3",
	"JnGm+taH2pzaayvnvgU59xBH3Hl07XHWKZCOJx9Ovrexh0SBxYHOfquu++LiF1pVvFhfXPzaempxUbB1",
	"+jzu9LBLucgKaujNcHTxwnZNIOjHjENtO8KhEOiwyLPHKdwvRz3Udh34st2Ixh4pa+JW3J6oas3MM1pS",
	"kR+Enc7cUKNP+DsuOADxV9RxHY/ZH3PYykMcsdvdg1xk1FePvsLHw03d4WAFuPXRHupIRx3kPb8IYcpD",
	"bNKHQvwjxh8W45+VMr+80VluOyoYddfMcn34eeU6NeszuSZcoNrPST7P5Jp9rE+emYVt9LV4Jtcv3JRS",
	"fdqvEVz4GAx+5jxSNJhIRbyzdsnfKiXVAU7Xvw078EwnK6Y1XbC00SVeo284ZlEeYDgQZpcAqum/Mlqa",
	"5fMlu4OLGo2947q+a5SxB9jYOyXZkd541/qjVe147LWH3ZPKRtPoj333Ph5y0dry8QSxdaZdcjj+jPV+",
	"h/ze2x9iA0PCmc55S0fsyJ4UdQ6FaBe8EBfiBZtzAWb+swth6dDpjGqe69NaM+UemCcLSc6IG/IFNfRC",
	"TKZdBjVkpAMHJgdNVc9KnpNLtkmdAnpWpXlbuZCWsxlpaBk5MUT+Vs503Bgj+iiHE2QWM2RtMucamil2",
	"TVWRAF0HwzWMjI5f22adEjc22ted66kbP30Nes5DA6y97DB2nfCx4qLtBGXP93tpnEWaXhPEL1Jrpsk/",
	"V7T6hQvzK8ku6sePnzJyXlWNQvyfjceWBRpMYgfVrsPC4TwztjaKZuBjkly+YbSC018yousV8OKyJNCt",
	"7Rim5ELRlXNX6bqcbTkAhGMcL4tWCIt7i73eT6OHRv8E7Sc4QmhDlqzsO63te17RC/3Gx7Xjlb/FBfvi",
	"4hfwrvYnE5zPFpQL7bmC5gthL4HzopwxklspgBUn5NWcAFWbtrq78AlHMQPp4BodH8k7u0bwqiA5FeAQ",
	"WRXggsYFoWLTNedqZow3nr9hl2zzLnLK2NO47zy46A6WWNR2uMAWmxMm11STlQTDfs6EKTfOKSyBmmlg",
	"ai4Meqe0XAwHiAbcmsj3z16cmIQMeE9GrnC0qsiilDNHaQKKngUc9X2GicqPFgB9AIKSfJS3vTHTG0FV",
	"YiPwIg45kO6/UDvera7h1uXdGOXmXGlwOGTU8QgaX5EbYJ7zhuyD8vclA6lMKvAKbKOU9lc6hfTB2Wk6",
	"qagyPOfVOAsNjv5jq48dZBdrTzJzOe/y7B5LTbIQbJzNqE6zb2a/WAysNXrK2jV6QudnQmkZVnBCwLPJ",
	"XdVZCc6zIdIFz5gq8Or1y8bIjyHQ0veCKdHIVB6M9o7EwtuSau/gC17qnkSMEnMGkPed3QBAYHtvIuyN",
	"5VZu5y3ZFR3a/2GnqleisLSD6bazc3CZ8myl73PufRMxos+7Vnl/Ku9EZf+12F6XJeFzUotLIa+tcLyP",
	"m9R0YiW/On1IUoDkZ+/cArcDG3v0cQA/0NGxWah+mM9LLhjJCA97YGAPMKBA5hz9tpv76eZg9mHwGbE4",
	"aAcYPUIKuSOwKylLHJh8L+MbKxb7ACkYBxpD/dhAbKK/WfqFBwIeyHropM1FGhtzTxeshNlilgAYRIHM",
	"GBPo6024mBL7zruipZVWjEThJQySjol42BK1nZinHw3J8WntA64IuNhea0K+d5PVxMKiBzotyW6BeCbX",
	"GURk9WGFwKqqygKpk6LcYAxC9+EHI9j1yBwwxLu+XrINhj9AQA7cEtD2OdoyY6W0sqDsYVhzUDuAvy3g",
	"B4RmuwiYwmYNqIcCWYN2W4Jodk49IHYNod1DwKFbANDV7QaPXac92PnK7wsHDZecNj7RSJHThGPo8vVR",
	"vI03yXMb2NG+Uih4SP7YlZCSqp9WK4JNZk6VEUnCKe5nCVAuhWZC1xCZZmQuy5OezkezkoEQmbWEtuyS",
	"bdLPRQa87K3vFumDyEM+t6+3R5GUqNiCa8Na0WPBob3x199AxFVFjWHKTvR/H/7n2S/n2T9o9vvj7Ov/",
	"ffrrH1+8f/RZ78cn77/55v+3f3r6/ptH//kfkwEGzbJKSTkfXp2p1Nyu742UgQFCRwIdW8u89xVcScMy",
	"eAtkV7QcMCHZRi816ClewrMhKZu1Dptg8CMf0PLCtJdskxW8rNP46ub92ws77feBUOp6BsScC8KoJZbU",
	"5EsQ0VvT2zZbpi7pzgW/xgW/pgdb77jbYJvaiZVFl/Ycn8i96NDibeQggYAp5Oif2uCWbiGQIFW9YCUa",
	"1YbzIODlLGzDk20K7d5lKvzY296mERTDXAtHSq6l7ac4vAqw8ILMw00UTal7KxqrSwBDC/KDaJprGpQl",
	"d64ziFcX6w3cKGnFgft4i+X1hx+7vEOZ5OH09lGJoSTVQzC4OG6wHcgVaen7MUn2PeItDXhbIikVQ45F",
	"V1rtIF0Ieh13MF4EcTG4sg6sdLtQfDgEZIlXG649hYtkruQKbl5faI2Qkw8oP1oo2LCczqwuq04fXyzx",
	"hJfOTmMlo+Xf2OZn2xZO1fb2guvYK9Pogvxz0T9dbnU0tzO7pDDfjbgT89GzfgjtIf8K6r5bZtQ9b0Ap",
	"F2nVTrkAuUMumsjNGB1mzD6z2ZrltWmCdjuq26Bdvl9psqumTgfbRRZyTAa0XX6AjXJj7Ti6HwOdvMuT",
	"o1Wl5BUtM2dXHKLxSl45Gg/NvRnynsWx9DV79+356x8d+GDBYlRl4TkzuCpoV30yq7JyiVQDJNZntlhS",
	"EzQNXf7v7Ipct2yR15AQofNitpKWQy4k0I2dObq9zjY593L5npZGZxLHJW4xjbMqWMYbkwYaxtvGcHpF",
	"eeltCR7aNFPBxTXuCHvzlXiAWxvVI9+I7KCcone707djByWKZ9iS+WCF+Tc0kS7DQXjnwuMWDBOAoCu6",
	"sXiDmuA+SRL1ClRLmS55nrY2iZm2KCHQUcI2JtB44JlsR7S8OD1WzaOxbDM9QinXATKaI7mZ3ol9aO9m",
	"0nly1YL/q2aEF0wY+0nBXexcT3sbfW6lGz+BEuZUzMF0j48gmHCf54/LRnOrxYVRbvIIsu+a/qTu1Nx6",
	"wtnd5v3T6JD78h8Asf3xE/u89MB9ETSlHouCiYOKlnvAHq5z8Yw9KWOL25u7fI5U1II7g8sNTmd3tkb/",
	"0HJZi9LkYq93VJwE6VavJ53NlfydpbWHoHS97k8fTYy904OPfgV17s3Aa4h3MqPd4KhCGqnbghRez7cG",
	"qss7g7GlSeXZHNLgpRsS22OjUNvpcoCww/2LXHvggeoNz1TghXsOKUFbL6b0tY29cU9x/ObaOpj7eg16",
	"PaP5ZVp6tjCdNw5tLRO5kcR3DgnC2qd0QiLfuNDW5dqqmFpx02YDzcPsppIwTjtaBm5EXsCqWNh16fpK",
	"LRPD1OKaCuMzpjmC5nprhpYn2+taKm0gAWJylQXL+YqWaZG4gN1/1xKyCr7gmOus1izK1OUGIpXkwiAW",
	"FVxXJd2gy2CzNa/m5PE0omruNAp+xTWflQxafI4tZlSDsNKornwXuzwmzFJD8ycjmi9rUShWmKVLIqcl",
	"Ca8V0PwET5UZM9eMCfIY2n3+NXkIPjqaX7FHdhedCDo5+/xryG6GfzxOE3nIWbmN6BZAdT3RT+MxOCnh",
	"GJZ9ulHTVBgTPQ/T9y23CbuOuUvQ0rGE3XdpRQVdsLTn62oHTNi3cUno7IsoMA8jCFuEm/T8zFBLn7Il",
	"1cu0fIBgkFyuVtysnM+GliuLT02mKJzUD4d+CUjhA1z+IzhEVSSt17tfHVM6S7BdNbitfU9XrL2tU0I1",
	"0bWFudGXOYJ4QlyytAJ8MyKNJuwNZh1GJzzUO8+jnMC1mWf/h+RLqmhuyd/JELjZ7Ksv+iA/g4xyBFIY",
	"swLnGg/4ve+7Ypqpq/TWqwG096KW60seCimylaUoxSNH5du3ctBHKx0A4Cl615tm+9Bj5S07SjaIbnUL",
	"3WhEqW+FeGLLgLdExbCevfBx75XdO2bWKo0etLYn9NOb107KWEnF2orfmY/JackrihnF2RXEIqQPyY55",
	"y7NQ5ahTuA30H9bs70XOSCzzdzn1EMCY7f522J/jZQ89saW8vGSs4mJxOrN9UFTHUbtC+oIJprkeZqCL",
	"pcUc+9myvEgjAkM7Bz19/5juAR+wKy8Y0KRXL3ZB3RvY53zNoOnwxth2dooffY5YHNq2/xAcKTix78wG",
	"8Ma1HfY5t2wMo5aeuxgj9PppW2BxvdcU9ORMFCjWAflbUj7glqkZKwY83xjM+FYqw9H3hLEP4Mdm+Ipp",
	"Q1dVms2C4hhvItxqC2joYl8jmuVSFJpoLnJGWCX1cldo9EBI31rAZCXXyHLi7K25VJhGE2QKIzthq2OD",
	"arYG6LZhzJSUZghQED7iyGopDaG1WTJhgtM6g4Tm3ZVg2A28OJChIMki31ka7xOQ0rLcTAk3D3Ac5dwH",
	"KVkxdVkyYhRj5HopNSMlo1esqS0Aoz3Q5N2aFxoqB5RszXO5ULRa8pxIVTCFBStsc3gFYSc33+MT4gIO",
	"ndP9u7WA5RWS4RMpXicu08dOBFtGvOIpMtDuz5DyXbPyiukT8u5aIhC6CdLWVghp9ZjVBoOVCj6fM7in",
	"sBx4PEG/5kMEE1RJAL/2MKxb0we4bWuRgXw88Ig0qKlYi+fYiDjv8baBqHM1Vvhi9QhVsmLB1BQVqbDt",
	"fMWaoHwru0llGoXNnGHgi6VsXBglizpnGAr+toWPEVi8B1JILB5Z+AGHfJGKBk6vbPE01T7IQcB9jGKW",
	"kO0VwtmxK6YwMKEZ6CESnQgubagC1wjwlHBLZcWjNHGuq4WiBRtn1wQi+BP2CCHMfoQrud8AP9v2XbGp",
	"JZu0OH6aS0e+6ZbLxLQ8RcsGRa83QxFhL7G6g2IlBuVAYQBoO+0JVnPGMs1FWvs5ZwxoO81zVll0jiuh",
	"MWYJFQqxQCoghtjzVnvCwvArhuFCW4SBLKdlXpfoD7qF01/ntFRtM0rJ5kZaBIurtTQqQW7nmoE/KmbU",
	"x/mUJYBRD0iecsXUxrXA15NPYG8vh+rY/vtheVnJrlj6TcMoRuf9VV6TFRWbcBZ2igaMaRTDEyBHWQUM",
	"y3jaP7mHXQQ+XiaHdduBtEcxsLlFfM4VU1wWPCdc/MbcbQ5kyWMMVsKQwnBRQwERxRq4kU8QCDTsBhP2",
	"MUANpUuwH9rO5IJdt067iOS5tuu1NvSSIdg+JNKxxrFnqpjmRT2gylQ0b0O2HzK6y/uGGnaqwtHqA+Fl",
	"h0KFS77t0nVxuYM2ndPq79IgnWoR3zHEioZIFeIIdcIb1eVh8S0H3j7SSK9x8nkIwthXTOm2n2OkA2Tr",
	"HWPbFq3xMTuNkqhf2H+WzLux6MH5NkiOG5zzwhcGEkN/5vwoEjs4kLonAKCvucmX2UBoh22LLTA0pvPS",
	"6k+JIgTcQjafs9yMgQFiBLAgzCAU+NlC8YLRAmJbm3APDPTogvLwe0ns0DqSa4TmIIU2Yg2M8miPtL4B",
	"Q3Yh/89yJO5fSfgfmEhHXAMvyLizT6s9sY1DniaQmpIN07ArwWs1uiOV1LRMW3j8pAUr6WbblNCgPWkQ",
	"bL2RC3kOtTzMMhT0kh0Ml/RTu3u2bXLbpLvgcD37tyIuONE7SZnwhvEZ5ULAhsvNlXD1GlJI2w8WRF8u",
	"cUpmLV3i/ceWeQ/0foyT/eJhhT+6wH5g5aUrxYgr+DV9iFHaw+RxFuF7FGaJvsWwbp8TiroqgSNPuqMg",
	"9qf9EexXap++vaLlQMjVG1Yppu3riFDy7tvz185wPRR4lQ/GCVLjciEYSgbTl7yfTgbiyy8ufkHfSIwe",
	"D6fRV9oP+UOiO6T93Ot9Mz+aoTR/0YZ699o+QH/z0R+kotx5ZTRRZ/2ddZGIw/d324O2OeDuIlx83+AV",
	"+ivVy3R6DjDpuZwcoISf1wLficFTBrxUvKAg573EHAQycyzpl58/+X9PvvzK//nky6/iLBzhu30+49dU",
	"Ho44TWWiPu0SPmMCK+IL/fS3eTCbZzHLght2qtLXdOKyccYpCHfGXnCdrfhCgSyQHnU4i2ikJE/EsqIM",
	"mqg56fj9sJDawZDWwjsQN+A1Gg4/cwqbeonnEwel+aoq0ffBDdVLX7FXvGfjonn3Hr+Hdpe8c4dHdmO7",
	"++H9HG8Ky+6sEtu9G38Qz+WqKtkw56rQawVLr6JACymJoiKbXgMq87xWjWq867/4My05Vn/TkJZISFlB",
	"HqLKcGH/A6GTsjb4f0aV/Q8myWv/D7EqopN2qAmcC2Sz8AP5yIiJlaQLfMe7vikqesPw61E2nT5XTFDE",
	"rTEZLWkETqZES1QTZ2JvJXxZwJc4nIUgIOBDpf1fmhTMMLWyT8qlvCarOl9CBAddMB/QAQwN7BmdiVqj",
	"ex/XdmCS8wnQFc1xIPQbLKlaMEWcKx9xdScCg1xR3imr2fXWAQ0TTUkKu8JM+uVkQa6Lgk0S0SwejEu2",
	"OUWxBX6/AeEYjlkZAAwiV+4QpFsFwMQxVDvw9bIl8WHGy1bYWQD/gJKfhc/dtT0lv3502NjlwTrgOtSa",
	"9dc53gYc722CVDRrG/ts6W/u8GvDzMa8NtKyse0Ozx3cEEgnSQBU8s/P/0kUm7tq3p99BhN89tnUNf3n",
	"k/Zni3iffZZWjNzXQyekQ8Jqn8N3oZ1TvVvrHAga5P3yxchzuVpJAfrfsuwY30VBwB1RQ3VyQZi4YqWs",
	"WLI1bnB06BB2ptiiLikanbkQTLU6jYkn0HwhWGHWAh2V3sKf79Yi1TZm9dA62o5Uzu2osMHNktF3kqti",
	"NEcOcRM3HbGJvGhGRA/t24z4Et3Dw4gw1Jyp24z5zo0xIs/xQigMs8X4CO69BUFIwxPuFCD2HoQ+/7GP",
	"gwiOFexfNS2d44gAN413EAuQXzKBqY1rHRLaEyZ0rZyfhoUVxrOguGFkzOB10+SmSY6zbYlDFdiwgnnM",
	"eYdCXAt2taJHYQ9Hbs8lZ9tzsci2hMDlEAPnGvoYZ1A8b81hawe3SKhWrBiZ2yI2U0Ocp+8/MHyTxK2p",
	"LpKOgIwKoIt+Jhjy8NWLR4R364vEsaZRPevdy47zyI2DCF2Oe7B0I173gWLO2JBvQMediszZgJlpV7ay",
	"+VWTqAxade05O6Ec6R/6V6oh85hr7vxYPlKn0BaQrph1f6g4Qn/vbFbTyULJOu1DuMCsEV3ltX0YgNCF",
	"nm2okDt98uVXpOALps0J+TuE8CHz7aeDbZ8m4U2a2VY2awKAhbBwlIec+1I059IdaM9NjTs3Jhjm/k/4",
	"JklUphOQSzKzTrlavurJLKRyPl8Q0RzRm5YN7RAOllwYRZH4ZnI+T0b5/wC/N6ok5WmyYv1TH0GVsVz8",
	"DaWCv2Gt+ffTyY60geVVyBh4M8JTsqFc4eU6cX2ePsmaG3RCXtvehIm5VPalvaqNlQHYGqL9UNfZklIh",
	"BM40dRMg+k38zpQERYIgUuSsxwN5tNngskVzkOe18zu0MIRw/hAc8vAtSDNTBPIRvlP7V43UwnAUf+w2",
	"/hztYmUZjwX670teJrCgkva7juGYEiEJVgSKW6KDbRPKiTC78IkWIt3vNY9TmhRpPZnFhALTQzWZwBot",
	"Rb6koilxsjtvVB8n9ymL36b93Wt+yPxWW+D8sAmuhBzwNRMui6d9oEBQZdCo3S/AFd2smDA3pHw/Ym90",
	"Y4MU/2r7C0ANvAB8710FEy7ZJjMyPbb9GIL6w1MLdKdIbaM1TgfePcFhxxeHaWRXvEFWRJjX4AodeY97",
	"3al70gUd/CXbEOVVA3HCZHw23eCVhWzR8JTl/x1fseZdgoJcSgTio1giPi/T71qMg0GS/WDLcsIw27FC",
	"D2AF9t2OE+EU9kDbt6EPeNtnw5q0TcXaXj2tehBtN3Z445+QFyG8AGwt6GjbxByg/qlrkcEg/ZAzgSuv",
	"p6LK65zBaHNx8UuFTk6Ji+saoCxj2/SlGteE5vNFqCqVUNz4Zus5U027lPLEt5yr35uGfb2Nb9YvSNai",
	"PI1JqaKbiRfLJtOJBdj+YwGy/87V7xOowVX2TUnpO+SOOYMJEi6rk/bDsSXLhcvQYMsOJeTWLLzOEW+O",
	"2f8DY9tXQxjrtTHvSPPDc1qW79YCZ0q4yiDdGzI5YmJrF2IViKSlpM7q6BVH7oLGBhKa51bKKhoX7gjO",
	"B5p006ehY3c/gVqLie9JJBM14wK6UbUYXDfojPqSIM8JVYt6hTr9u1/fjhUMJg3mhYvu7Ge+dVIT3vRa",
	"sYJI5eK6+NwF7Q2lbhqZzhJr7b2WC5430lnjVT6A6VP7/mCVS6IiRZYHg7hlVfaRZyS5QEPyxeSEvMIY",
	"EMVogTRTccNSiRVb64eA9GsGBSU8RmfhdKO0uSf2FrUSV2rAbMWgpF4ileqnmqqTVroeOLEhqoSCTfuQ",
	"PsAJPbczNSUS8JByKoQ0n9A57Zmqs1NUNHL/qKqQs7Nkwte2RdEXhh1Qk0rF+EJsKwQ4p54R6O5xJdlB",
	"m0q52NP44HWPSwSJ+GZEFIwfOBjW+6JFBkV0EtQ1jjPukNewF1urAYbIY924DGm3yijJ1bglejLzY7RC",
	"QGx4Nf942PXdILPqrdOpdgZoUY1dfVt+UTvrsreH3iWZRYbGrZIZZlzCSlFAnxTLPP/0FEsUmIypbtys",
	"LsQ5+Z0p6d6LYSh7IRr1tMvI4YLlTxKdQuY03evWnXLPzHS4+C3S4WDGx4uLX9a0J2UATLeQL26WvHPn",
	"Gb8cyAwWn7G3VrlUYLdM+YczbtnYoVrXFxe/zGlRdJIkxa5XSGRCkh/cbZciDZCFXg9kI9t6mvOtp7ll",
	"/FZE1bV/8G2pR+gfiBi7du13HHuk3FGHXSub1JH9qcdc/mC/H4Ua/tF7W+Tws25Bjy0JXekK3mTnIVe3",
	"A04G+E6IIyHO1u1/V16VUs5D3TtnHvMG3E5ByHPkaytaHTRd7E7iEUE8bPZng0b/Jk7Rlyp040UpWGCA",
	"xrugW3bydvVt/ejpE4Sv3eg0GudnakpdK7aC0MrmiZk4HJfXMYiFTcJNdKQAv4fYNVxHM8R7TcgrOzIt",
	"r+lGe1Vpg1jDw/ldxUROCTVdHHuN+t303qgcDGNvWM4rDtW721Qw4PiwgnGgejoqKi3RwaBQfhWUFs43",
	"nDaZUtvGL2/7cjkfacSgp26badnWFuDAXhls2zz3Y/sVhSON+NnuQIhU3tywpTtonrNObiV2TlO4L43D",
	"XkjkcJph6ia69b0GzCLCNrKH9h1Vly0eSHW7cjEGQbRGbYkYUejCDSoOOmPCj01JNXDFDqr9n5lCA+Yb",
	"Kgq5Ii99CNLDn9+8fEQU03VpPJL5bCQW+RwkH2kxwkrN3crfdkoQek90tGksuDYqobf8eAsUzvsFChNl",
	"+uzqDlWa8LL4QKUJy15pwpuvdHxRQn9jhkoSfpQItOMl4Q2c26mns8XsSz5dN6SfbqabiYcoHTbBC1Fe",
	"D3uePg1dh/HfSshqVXunhlxb6UPH5Z8TTp1NUm8RfDMjO8JOp8/2eAMViJycBZNALtJEkXDtis973tJI",
	"Rq6AHCYjLyPhZ16LQne2sCmKs8UCulX2caKPb7PVmDokFIyVBN7GptI2JGCKdKEgoch9t+4VJIjGVNA/",
	"iHLjQmm72d2arayUvOJFqhxNKRc816iB2ddm+9r3fT+drOrS8BuO853vi0bkNDvkC8cKRUFVQVjx5Msv",
	"P/+6We5HRq76m5R0sHHLckpGanjelmPD6kYQMX+UJwvZJ1mDtja1aEwPwbaWyvEw3kQGgKTXGy3Wu2jM",
	"NoRGqC6t2F4a3vw0tb8tqV42pDMqSwDlIihx9KrrdwdRPx+m7ll0KbJbuUZ0rscQ4WguycdwNzplAXk+",
	"miR+F1GSftZ+t0RUu1p88aGQsNdVyaxs19DA/r3J1aYy8tQfDbJ8P+db3q/uE4+X3nVoAGmIpZVEMJWD",
	"FSYbiQsUBA1UN/DP7e3P2xiuVHbUpWLaQpT2p1mqi4tf08LmUNYAK12mO73f82zfdva0veO4b4MSbnWJ",
	"QNzzm207Dtw/SP09fw8u23OQxnIpDM1Nk5xmcu4UZhOXhn2yNKbSZ6en19fXJ16bdpLL1ekCwk4yI+t8",
	"eeoHwgJlcSC46+ISmFoqXG4MzzU5//EVyEzclAw82Au2Bq1dwKzJk5PHmD+ACVrxydnk6cnjk89xx5aA",
	"BKeYq2Ny9sf76eT06slp7CqzSNabY1TlS3wIuLYnEAvP8HXzqgiNXkp17odzZg+suH32y1BtLXtl7d//",
	"qpnaTHxxi1gN1Bjj+tdjd5Qzqik0umCaWmHcuGIk90JcZGnGipDsignCUewr+YqHmjbKPmod107ADG33",
	"BLjJdEcXLIL3hPykWZROVl5CEAiKm96l3GdDDZ0GALNDpOBqUL4f4ou75kRd8PCjwmveFxD2BEYTEbmO",
	"nrRSNTpVratt41J25BtSi9LKF978AFZDHZYGWTwxm0VO3Q64eCvvt6qHT8BPkjkIMwvhnifiCh7A2wiY",
	"ifO0BS2Xezo5HJ+G9COx38C0qRXoFPVTEhJ6dDTMU2f396XA+xW20atgaMHOCTijZZlaZmRr6i7z27Vb",
	"ZoP9uFpd50vwUOkC2qv9DWVxXLqApu4V7s3U9Y+8BnywXPAWCC1FawNH9LHbwdZVKQs2OZvTUrP09jBc",
	"ZGtrgoDgHTFx75xjRCdMUKMPps4i74BJK8TRthBSpBN+dGUHbTZAui0/m+x760pXoewjvXJ2ilvdN++F",
	"GZnYXVkyWC+kQ7aX8JJthoBpgpWHqd1O38rtn4fA93zGezY0RaYwqyzkmq+YgiFFDsYVDdTCay4R571z",
	"TcE1nZVQdwXVEi3PjEGCEFJh73ECceqZYYbc9UnZMsOvUCsJkoDBTXvy+LGXnZyqMRrt9DeNQnEz4LAv",
	"7z7BOakL6BONbg18Djni0QaG53qNMsOqqs2wn8DaZMCp+yP/pB2RrOiCC+ddAwq8Fb0EPZ3AMC3n3OZv",
	"p49zt+w/WGacwOAwZoQerZHJ2hvwa1LWbUP+EJxcHtkFfnGrcxzM/jacha2zDt9wDNhvHAKigy5mj3s/",
	"nXz5qS/BIjVdaEjeBzL35Nf3HUn+9A/vXcqL94Ni/WspL+sq6IfjAkM96R7bunv1bANEYqt0H7TOnuYC",
	"SbGPkIiiBCAn8R4ZVbO9ZNWxFPiAFPMoIx5lxPuREe+Ele7BQO+QYaaZ1JFHTb54/MWRzX48bLYE5reD",
	"zZ72KMAuvisin7cuHZUVktty4+zvIUwE05Zs4c7nVQWR8eDcoj8mPn3wZ8aflS0flZw3UnIemJV27vse",
	"z9NmluamHh+rUfBLZ2OPEsFRIvgUJYIQavdB5AD/NPl4+P+dWPyOPP/I8++N54cbPY7Rx8UYjvzd8/eg",
	"RDky9SNT/9SYeiK57X4s3msr08rMW7H85zj0eQza8f1/lAWOssDdvP9bBGDfp/9RIEhkuziKBUex4NMW",
	"C/Z/8weBoGMLPYgocFQCHBn/kfF/cCXAkdkfX/9HNv/ps/k4LnSsY10758q7Vh0uxRzZZgUR7NpeNiOJ",
	"LC0z2sHh44F2Mfgj3zhMVExUHMjOMudrR519QpxcdgpLCmkYJroehAJSUMBgezutYzDxkM96+PpHcmKf",
	"5zme9AC5qVPbxhfvNpXdhxIc9n6zu+UxsG5SJAR/TZ99PMQGQmZwzRckC5Hq9pcV/gTRj2/5wv5U4k8Q",
	"d41Rp6m1a74YXryGbiv8x443apHu1kcLaYeczzZOak+fRVrk/SidXv2U1BD7KpljJFg89YqLbOv0ocFB",
	"QJixuXShLxEMdL0DBt9g32iJO33B+JVFa1pwS3kNX7ET8p0jNFSQNy+fk6dPn35N8MLbFw2iy9CCcUis",
	"rBADFwhGQU34PIb8vHn5HAB4G3xZR7XaeagBow61chjx41v4nzjI8k8Z6fYhgyJw1U714F6TWGpmu3gS",
	"CtJs1VQc9oX9J3kZTyfd58Tta8t1XkjtnexMeAz++rd6sI4xSMepHNpWl6FsDnvYku/evvsSHhD4fmhl",
	"6g+XDiWGkK+1STSWJOjY7GaC91HVfFQZHG3Mf0Yb8791CHG0T6d/tIn17lDiqFzXkPKyaZIOI06JxF2W",
	"sVMs/tNZCu+M7OxJbO4vWvSW5qOj7eUTEWV7ROh0JteDhOgvIP7Z139LFoVrOJNrYu/V1IkvupOLMzSA",
	"1k7n8Mz91hRAdYr9haRlRtUCK9s+gDG4WJxBvweY7YUDEamd+IENuTBnnz95+oVroug1lIDXUwcGAEW+",
	"+gKAsF0fzL764oG3NlBIrW1/Ojv/5hs3RqW4MHRWMqdY6M2pjTpbsrKUroMTi1mvof1w9l///Y+Tk5MH",
	"Yyi4XFsiTkXxPV2x+6fl582RcXEHJ9Jud1+bnpQ7cX/H6oPS+si//HD+mqpBdWX4fFtmso1fPJPrFIWw",
	"1yxKQHI08R/ZzOHYjK5XK6o2FsWZAZIRoZrzrEO9QUeAvTF/YnpfDtUwJShsHbgOJB+nbcFRS2WF0pKt",
	"eS4XilZLntMSK+btVuM8A/DunVYf9Qkflz5huMZuxYt1p4I14aJg6/STP6D7KOXEM7l+4aaUyTqOn4IG",
	"AW8DLnwMYXoWX+f21T9yuiOnu0tOh2g3gsftpQg6LeVC76ENIrb9iAfFa7nQH0YtdGRPh/GQ+8BeUH9S",
	"lySoVRNs+71y5pg+1xUg2m4Sw1ZZU4v0brLofvxizZ2aSUq5yDzH2D9l0OKF7fpJy0630N5u0xtuD76K",
	"jd/QctuDaVTg1NEWfGSOe3CrlvuCK61/f44Lu2e3o+/QQB50vlpwMzSf/Ta5/8jCY6jYMVTs+DS9T4cD",
	"OOTTP/z13O1k4Eq6785WbhuOf03GZaeP7gV36l4AZG4sLbzHBNQw5ZHcHJV5H7d3RJdins5oSUXOdmrk",
	"UPTWBtTQvtrO9VICQXG584HAbKWofrLj2+j4NjoWnDvGQo2NhTqY0HVYaSQmnqNead9xwY+ZPVNcb9aw",
	"huOT7c8kgOyTFqNlngBdrKNP23JjYEYMy1IxS8bWN98xM8YxM8YxM8YxM8YxM8Y9m6GPOSyOOSyO77Z/",
	"7xwWY1xNnPXSAioFQx/mVmPk+4Pix117n/QW9VyuZlyw5uXjV9BUZTbSHhQ0WlIT+LBvaCTRwb1gx7oy",
	"JcsB/greN/Aazhm/gv/OFWO/s8xQZaXqMfy2tRoPINTPjOaPC2jutTYrDaOmjfjcIYjLwu5zWW6ICQlt",
	"CSV+JVMrIG9kTa7hspT8Evq74pt201fEInGnGLaRxKh60CrtumcAz84sJdP7sPwcE64cE64cE678CdQg",
	"s1Lml/r0DzjqDBUIO63X0GlIe/HMftylscDLiNOlU0jFAN2vZnVr5Acs7hiX/Qlj/Cg1X+RlOTbzbVe7",
	"5yXgtCTGNUi4XTk4vLz2y6kbPD6PWsOj1vCoNTxqDY9aw2M+3aMu8qiLPOoij7rIoy7yqIu8O13kh9Qf",
	"3n1xzqOG8qihPOprPmhsTXy0p3/YN9Hu6Bpin49li0MOqStjrBsTYuMeZeOT2n9CJCTarr0u6/jLeQxE",
	"OZKXj0Ud/H460Uxd+bteq3JyNlkaU+mz01O2pquqZCe5XJ1CpgfX/48g98vVChhV+MWNHP3iSNn7X9//",
	"TwAAAP//sCOVHBhhAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
