// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAAA///cXOD61FsBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
