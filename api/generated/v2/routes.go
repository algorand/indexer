// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
