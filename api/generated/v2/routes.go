// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
