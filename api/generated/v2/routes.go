// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
