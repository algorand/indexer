// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
