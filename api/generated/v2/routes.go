// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"header-only": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------
	if paramValue := ctx.QueryParam("header-only"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
