// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"next":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"header-only": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------
	if paramValue := ctx.QueryParam("header-only"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e5PbNpYo/lVQ+m2V7fzEbsd51E5Xpbb8GN+4xs64bCezu3HuHYiEJExTAAOA3VJy",
	"/d1v4RwABEmQovrlzkZ/2S3ijYPzfvw+y+WmkoIJo2dnv88qquiGGabgL5rnshYm44X9q2A6V7wyXIrZ",
	"mf9GtFFcrGbzGbe/VtSsZ/OZoBvWtLH95zPFfq25YsXszKiazWc6X7MNtQObXWVbu5E+fZrPaFEopnV/",
	"1r+Lcke4yMu6YMQoKjTN7SdNLrlZE7PmmrjOhAsiBSNyScy61ZgsOSsLfeIX/WvN1C5atZt8eInz2Taj",
	"5UoqKopsKdWGmtnZ7Knr92nvZzdDpmTJ+nt8LjcLLpjfEQsbCpdDjCQFW0KjNTXErs7u0zc0kmhGVb4m",
	"S6n2bBMXEe+ViXozO/t5ppkomIKbyxm/gP8uFWO/scxQtWJm9ss8dXdLw1Rm+CaxtVfu5hTTdWk0gbaw",
	"xxW/YILYXifkTa0NWTBCBXn38jn56quv/kLwGA0rHMAN7qqZPd5TuIWCGuY/T7nUdy+fw/zv3QantqJV",
	"VfKc2n0nn8/T5jt59WJoM+1BEgDJhWErpvDgtWbpt/rUfhmZxnfcN0Ft1pkFm+GLdS9ek1yKJV/VihUW",
	"GmvN8G3qiomCixU5Z7vBKwzT3N4LXLClVGwilGLjGwXTeP7PCqcLuc1wTT2gIQu5JfabxaQrScuMqhXs",
	"kDxgIpf2Hs8uaFmzByfkpVSEC6Pn7q6Za8iFOfvyyVdfuyaKXpLFzrBeu8W3X589/e4716xSXBi6KJk7",
	"xl5zbdTZmpWldB0cMuuPaz+c/ed//ffJycmDocuAfw4jUHmtFBP5LlspRgHjrKnon+E7B0F6LeuyIGt6",
	"AeBCN0A6XV9i++LzgNM8IW94ruTTciU1oQ7wCrakdWmIn5jUorSo3o7mni/hmlRKXvCCFXN7Z5drnq9J",
	"Tt2BQDtyycvSQm2tWTF0IOnd7cEOoZNd15XOAzZ0fw+j2deek2BbwB/97f9167BkUXD7Ey0JN2yjia7z",
	"NaHarWotywKBPiIApJQ5LUlBDSXaSItYl1I5jgex7tz1b5g4ksMFFmSx67YURWv0/X3s+bBtVUq7syUt",
	"NUufl999fEiwy5i3oGU5cxTLMlpuyiz8QKtKZ7DjTBtqWNymqmwLIQVLMCDhB6oU3dm/tdlZLgtQ66y5",
	"nSwvpWaZkXsYMM9TwYFFLFN8YgexY+TDmhGY3H5AVhQgW1gsXZY7YtwFWIAgnvmaE74kO1mTS3g6JT+H",
	"/m43FqY3xF4+XFmLU7TYbAi4e4eRAO2FlCWjAkB7zWjBVCZFueuf2/fwkdiPZFnS1Qn5x5q5x2xpv10d",
	"LmdOFDO1EhbKSpmfk0IyTYQ0lm8wlIsuy64H1h+vZ8/SndSQWdAb5l9K/ySxuWVV4GyKwNrMScFKBvfT",
	"vB/4VRsld3BvFornRFYWXmVt+u9aFG5Y/Nx95gDzgwJKvJM9my75hpv+dt/QLd/UGyLqzcLe2DLwOka6",
	"qwE4VYzkAG6LFtKq6IppwiwrxFG6gnnsJds7VIzm62GEimvag0M3dJspWYtighBhiFQxk6YrlvMlZwUJ",
	"owytpZlm33q4OGw9jWgTLccPMricMMue5Qi2TVyrxSz2C1xQdKsn5EdH9uCrkedMBOqIeJ6RSrELLmsd",
	"Og1xS3bqce5ISMOySrEl3/YX+d4dh0Vu2MbR5o3jpx0KYAVxeMAOh4hycE3RhIcKDQuq2bdfD3HMzVfF",
	"ztkuSS+6AIDbCVqKtf2Cfcd3EWbY86gnwiGyBzH8jcLeJLiDRhmijQR7Z786pJLWCLX6T2C547lRH5Fd",
	"SzeEY3jKPHQUnZluTwzVfJXhiL1XwlcfLBux5CWwGP+yj8PfbK0tXWrfrWc6NF8JamrFzj6KL+xfJCPv",
	"DRUFVYX9ZYM/valLw9/zlf2pxJ9eyxXP3/PV0KH4tSZ1RdBtg//Y8dK6IbMN201N4T+nZqiobXjOdorZ",
	"OWi+hH+2SwAkulS/IdsIJNFUy6EFpPQjr6U8r6v4QPOWvnCxI69eDAELDDmGDwF36EoKzQBqnyIj8c79",
	"Zn+yKI8JwOgRL3D6Ly1BiGrGrpSsmDKcxfpZ+99/U2w5O5v9f6eNPvcUu+lTN+EsCGlmiJThA6bGoTBE",
	"XQ6pITOwqWqDpD2FHcJz/jmsrTtncy1y8S+WGzyg9jIesk1ldo/sgt3a9c2dlm4JJBPPrStU3OI5InHP",
	"gEj3R/5RO8GvoisuYONzcmnZ7A09t1iBCmnWTBF7F0wbT+YR/SHlD4plxys4WeFklnoxiTvV177U5tZe",
	"W3b3PbC7N3HFHbHxgLtOLel48+Hmewd7kyCwuqG7H9W4f/z4M60qXmw/fvylJXFxUbBt+j5u9bJLucoK",
	"aujVYHT1wnZNAOh9hqG2NeOmAOhmgeeAW7hbinpTx3XDj+1KOPaIWROv4vpIVWtmntGSivxGyOnCDTX5",
	"ht9wwWER36Oq63jN/prDUd7EFbvTvZGHjBr3yU/4eLmpNxzsGNe+2pu60kkXeccSIUx5E4f0uQD/CPE3",
	"C/HPSpmfX+kux64KRt03s9ze/Lxym5r1mdwSLlD75zifZ3LL7qvIs7Brm/wsnsntCzelVIdKI89At07A",
	"l8TCMhe0bJxO8JmA6eK24BzscJViFRMFtvk4W3z79dnHGeFLcs5Y5fWswVjiHV+uIO7gyU55Is/cGWiw",
	"Iov46uyZ/lUpqW4AfLzw2VnPfLZhWtMVSxt34j36hlM25RcMd8nsFkAF/j2jpVk/X7NbwATR2HvwwYdG",
	"23sDB3urNCFSTO/bf7SrPdJke9gD0Xg0jb7vp3d/KGrryKdj3NaddvHt9DvWh13yJ2/giC0YCZ9B5xQe",
	"0Tt7U9T5TaL98aP4KF6wJRfgTnD2UVg8dLqgmuf6tNZMOQn2ZCXJGXFDvqCGfhSzeZcCDhkDwcfLraaq",
	"FyXPyTnbpW4Bnc/SxLNcSUs6jTS0jJwlIpc0Z6JurB19kMMJMgsZsjaZ84DNFLukqkgsXQcDOYyMvnFj",
	"s86JGxtJlfOwdeOnn0HPv2qAdyg7nINOuKFx0fYTs/f7gzTO8k0vCcIXqTXT5J8bWv3MhfmFZB/rx4+/",
	"YuRpVTUa9382Tm120WBzu1H1PWwc7jNjW6NoBr4sye0bRiu4/TUjut4ALS5LAt3avnNKrhTdOLeYrlfe",
	"yAXgOqbRsmiHsLn32OvTPJJk+jdoP8EVQhuyZmXfr+/Q+4pUAFe+rj1qhBFP848ffwYncn8zwT9vRbnQ",
	"nipovhL2EThH0wUjueUCWHFCXi0JYLV5q7uLEnEYM6AOrtE3lHywewTvDZJTAT6jVQFeelwQKnZde7Fm",
	"xnjm8R07Z7sPkfPHgU4EzlOM7iGJRW2HC2SxuWFySTXZSHAgyJkw5c45nyVAM72YmguDXjAtL8wBpAGv",
	"JnKPtA8nRiEDDqaRyx2tKrIq5cJhmgCiZwFGfZ9hpPLWLkDfAEJJSv1th9X0QVCVOAh8iEM+todv1I53",
	"rWc4ur0rg9ySKw2OjYw6GkHjJ3IFyHNel/2l/GPNgCuTCrwP2yCl/ZNOAX1wqprPKqoMz3k1zQSEo79t",
	"9bGD7CPtSWIul12a3SOpSRKCjbMF1WnyzewXC4G1Rmdiu0eP6PxMyC3DDk4IeFC5p7oowb84BPTgHVMF",
	"js9+2y05uLe09LtgSjQ8lV9G+0Ri5m1NtfeBBkd+jyImsTkDwPvBHgAAsH03EfTGfCu385bsgg6d/7Dz",
	"1itRWNzBdNsfPLhmebLSd8v3PpAYuOhduLzflnfWsv9aaK/LkvAlqcW5kJeWOT7EHWs+s5xfnb4kKYDz",
	"s29uhceBjT34uAU/0NG12VX9fbksuWAkIzycgYEzwJgLmXN0bW/ep5uDWcHgC2Jh0A4weYQUcEfLrqQs",
	"cWDyg4xfrFgdskjBOOAY6scGZBP9zdISHjB4wOuhMzgXaWjMPV6wHGaLWMLCIFBmwZhAn3LCxZxYOe+C",
	"lpZbMRKZlzBIOmzkYYvVdmyefjTEx6e1D7gjoGIH7Qnp3lV2EzOLftFpTnZkxQu5zSDwrL9WiB+rqiyg",
	"OinKHYZpdAU/GMHuR+YAId7F9pztMEIEYpbglYC2z+GWBSul5QVlD8Kai9qz+Osu/AZXM84CpqBZA+gh",
	"Q9aA3Uic0d6pB9iuIbB7CDB0jQV0dbvBM9hpD/ZK+X3moKGS88b3GjFyGnEMPb4+iLfhJnlvAyfaVwoF",
	"F8y3XQ4pqfpptSLYZOFUGREnnKJ+FgHlUmgmdA3Be0bmsjzp6Xw0KxkwkVmLacvO2S4tLjKgZe99t0gf",
	"RB7ypZXeHkVcomIrrg1rBdgFx/kmLmAHQWkVNYYpO9H/fvgfZz8/zf6bZr89zv7y/5/+8vvXnx590fvx",
	"yafvvvu/7Z+++vTdo//4t9kAgWZZpaRcDu/OVGpp9/dOykAAoSOBjq1t3vkOLqRhGcgC2QUtB2xUttFL",
	"DXqKlyA2JHmz1mUTjA/lA1pemPac7bKCl3UaXt28f3thp/0hIEpdLwCZc0EYtciSmnwNLHprettmZOqS",
	"7t3wa9zwa3pj+532GmxTO7Gy4NKe4w/yLjq4eAwdJAAwBRz9Wxs80hEECVzVC1aiUW043QM+zsI2PBlT",
	"aPceU+HHHpNNo1UMUy0cKbmXtiPk8C7AhAw8DzdRwKnu7WiqLuEyxIrG7OslDcqSW9cZxLuL9QZulLTi",
	"wH28xvb6w0/d3k3Z/OH2DlGJISfVAzB4OG6wPcAVaen7sU9WHvGWBnwtEZeKUdmiy612gC4E1067GM+C",
	"uFhfWQdSOs4U3xwAsoTUhntPwSJZKrmBl9dnWiPg5APKjxYINiSnM6tLHtSHF4s8QdLZa6xktPwb2/1k",
	"28Kt2t6ecZ36ZBpdkBcXvehyrau5ntklBfluxL2Qj677Q2APaWZQ990yox74Akq5Sqt2yhXwHXLVRIjG",
	"4LBgVsxmW5bXpgkO7qhug3b5brnJrpo6Hc0XWcgx59E4/wAH5cbac3VvA568zZujVaXkBS0zZ1ccwvFK",
	"XjgcD829GfKO2bH0M/vw16ev37rlgwWLUZUFcWZwV9Cu+sPsyvIlUg2gWJ/8Y01N0DR06b+zK3LdskVe",
	"QuKFjsRsOS0HXIigGztz9HqdbXLp+fIDLY3OJI5bHDGNsypYxhuTBhrG28ZwekF56W0JfrVpooKba9wR",
	"DqYr8QDXNqpHvhHZjVKK3utOv449mCieYSTDwgbzfGgiXSaFIOeCcAuGCQDQDd1ZuEFNcB8liXoDqqVM",
	"lzxPW5vEQluQEOgoYRsTaDwgJtsRLS1Oj1XzaCzbTE9QynUWGc2RPEzvJT90dgvpPLlqwX+tGeEFE8Z+",
	"QrfRzvO0r9Gnn7qyCJQwp2KaqjsUgmDCQ8Qfl/XmWpsLo1xFCLJyTX9Sd2tuP+HuriP/NDrkPv8HixgX",
	"fmKfl95yXwRNqYeiYOKgouUecIDrXDxjj8sYcXtzj8+hilpwZ3C5wu3sT0rpBS2XHSmNLg6So+JkS9eS",
	"nnS2VPI3ltYegtL1sj99NDH2Tg8+WQrqvJsBaYh3ksdd4apCuqrrLilIz9deVJd2BmNLk7G0uaTBRzfE",
	"tsdGobbT5QBih/cXufaAgOoNz1Tgg3sOmU9bElP62cbeuKc4fvNs3Zr7eg16uaD5eZp7tmt62ji0tUzk",
	"RhLfOSQia9/SCYl840Jbl9OrYmrDTZsMNILZVTlhnHYyD9ywvABVMbPrMhqWWiaGqcUlFcZnZnMIzfXW",
	"DC1PttelVNpAjsjkLguW8w0t0yxxAaf/ocVkFXzFMadarVmUEcwNRCrJhUEoKriuSrpDl8HmaF4tyeN5",
	"hNXcbRT8gmu+KBm0+BJbLKgGZqVRXfkudntMmLWG5k8mNF/XolCsMGuXrE5LEqQV0PwET5UFM5eMCfIY",
	"2n35F/IQfHQ0v2CP7Ck6FnR29uVfIIsa/vE4jeQhrecY0i0A63qkn4ZjcFLCMSz5dKOmsTDmsx7G7yOv",
	"CbtOeUvQ0pGE/W9pQwVdsbTn62bPmrBv45LQORdRYKpKYLYIN+n5maEWP2Vrqtdp/gCXQXK52XCzcT4b",
	"Wm4sPDUZqXBSPxz6JSCGD+vyH8EhqiJpvd7d6pjSyZDtrsFt7Qe6Ye1jnROqia7tmht9mUOIJ8QlZSsw",
	"K2aj0YSzweTK6ISHeudllPq4Nsvs30m+pormFv2dDC03W3z79d7oOnHYwu/83BXTTF2kj14NgL1ntVxf",
	"8lBIkW0sRikeOSzffpWDPlrpAACP0bveNONDT+W37CjZILjVLXCjEaa+FuCJkQGvCYphPwfB48E7u3PI",
	"rFUaPGhtb+jHd68dl7GRirUVvwsfk9PiVxQzirMLiEVIX5Id85p3ocpJt3Cd1X9es79nOSO2zL/llCCA",
	"QeH944Dsw9G2h0RsKc9dPPApZCxGVh1H7TLpKyaY5nqYgK7WFnLsZ0vyIo0IJkNGBz1995DuFz5gV14x",
	"wEmvXuxbdW/gth8FRs7s1be0XMl+dH3sYC5RbQbzDp+ybWfX+9YntsV12vafg7wFj/i9uQveubbDDuyW",
	"JmII1HMXsIQuRG1zLu73koLSnYkCeUTApWvKB3w8NWPFgBsdgxnfS2U4OrIw9pmd4oyi+XlSn/bBftHB",
	"GQ491yO3OD05SAZU7W9tnw9+tpQpkm+YNnRTpTkJ0I0jsgHEZY8vdLECl2a5FIUmmoucEVZJvd4X/T0Q",
	"tbgVMFnJNVLVOBFuLhWmIgW2ychOZO7UIxmNQW6vMVNSmqGFAn8VB49LaQitzZoJE/zyGSSO7+4EI4tA",
	"qEKaiViZvLFkzCdxpWW5mxNuHuA4ynlIUrJh6rxkxCjGyOVaakZKRi9YU2ECRnugyYctLzTUjyjZludy",
	"pWi15jmRqmAKS4/Y5iDoYSc33+MT4mIqXVzBh62A7YVM9/E+cZs+PCSYa+Idz5FH6P4Mif81Ky+YPiEf",
	"LiUuQjdx6NryWa0ei9pgPFbBl0sG2AO2A/Ih9Gs+RGuCWhnguh+GdXu6exzQg7BMr+mTb74dArQn33yb",
	"grX33z998s23ltWigtB6y0tO1S5uZlvNyaLmpXFZlym5YLmRKpZ+udCG0aIHW6g7cbMAuV/WInfeWKFL",
	"XNHk/fdPv/nyyf958s23TtkSzeLjToEjFISJC66ksJ+8nitAiJsyzMa2XJvPwFCYrchAVBvQZxhUmm3F",
	"c2xEXCBD21bZQWEbVJ74h1+yYsXUHHX68Dz4hjX5IawYIZVpdIdLhjFYli5yYZQs6pxhVoL3LbwRLYv3",
	"lhRy6UfOJvDWfUmZZp1e7+cp8gkhr0DWeowcv5DtHcIbYxdMYYxMM9BDJA7RurShCrx0wGnHbZUVj9Kk",
	"va5WihZsmokdiNWP2CNE0/sRLuRhA/xk23c5+Bab3GI+0zxeFCZheZSY5qZozgiWGBQQ3g3FLb7EMi2K",
	"lRg6BmUyoO28x/4vGcs0F2kd/ZIxIM80z1llIT0uS8iYpTX40uEtQ6S7Z9rs5QvDLxgGtY1wmVlOy7wu",
	"kdseYSEvc1qqtrGvZEsjLezFZZcaxTW3cy3AaxrrS+B8ytKwqAek+LlgaudaoIzvyznYd6M6Hir94NGs",
	"ZBcsLXkzijGk38tLsqFiF+7CTtEsYx5FmoWVIxMM7g942z869UO0fHxnDiDHF2mvYuBwi/ieK6a4LHhO",
	"uPgXcw89YCwPMVgXRgrDRQ2VgBRr1o2knkA4bDfktQ8Baiiph/3QDnkQ7LJ120UkKLQDBLSh5wyX7QN3",
	"HXcz9U4V07yoBxTuiubtlR0GjO7xvqOGnapwtfqG4LKDvMIjH3t0XVjugE3ntvqnNIinWnh5CrKiIZ6K",
	"OBye8Jl22YJ8ywGhWhrp9aI+W0YY+4Ip3fbGjTTVbLtnbNuiNT7mUFIStWCHz5J5Zys9ON8O0XEDc55/",
	"xnB36M8KnwOud4IDCabCAvQlN/k6GwhAsm2xBQZwdUT4/pTIXcArZMsly82UNUAkC5ZHGlwFfrareMFo",
	"ARHYTVAShiN1l/LwB0ns0DpieYTmIEg0HA+M8uiA7NYBQvYB/09yIuxfSPgfGPInPAPP47i7TyvnsY0D",
	"nibcn5Id03Aqwbc6eiOV1LRM2yH9pAUr6W5sSmjQnjTwvN4UizSHWhpmCQr6cg8G9fqp3Tsbm9w26W44",
	"PM/+q4jrrvRuUiZ8tnzewxBW5DLIJRwSh8wm9oNdok8jOSeLlsb77iMgfZxEPxLPfvFrhT+6i/3MKnZX",
	"FxV38Ev6EqPsn8nrLML3KBgYPeBh3z5zGXXlPifedMeM4W/7HpxX6pz+ekHLgcDAd6xSTIMMT8mHvz59",
	"7dwrhsID88FoVmpcxg5DyWCSnU/z2UAWhI8ff0YPXsxxEG6jb1oa8tpFp137udf7at5eQ8koowP1TuD9",
	"Bf3NxyiRinLnO9TERvZP1sXLDr/fMVm3ueDuJlwU6uAT+p7q9UuaG6l2/UyYVuwdSDHjzNOHHPGX36ZR",
	"sV1CehKwfbvkNW31VXApA3cuz6vIZS+DDYEUNmvqtFr+TyuFR+lqwncr3Hdl9OYu4nyuiXrVa/iMmd6I",
	"L7nVv+nBtLfFIgvxCqnSe/OZS1sb5+rcG6TEdbbhKwXsSHrU4XS7kQEoEfSNbHCifq1jOYb55A6Qtjbe",
	"WXGzvEb/4mdOAfQrUbAtU43V5E2zu051CVTtQAVXnTWKzjRuQmC/W9qNceN2Cm1YMaJJWR74FNEBpLQs",
	"1KTxy6uNLzJgYUV2yfhqnT7Yt1ca2rK4+y/t4u4vLYXg3oBG/ql9kACRA4h22aDh0aTSEcYG07YZMD+b",
	"NW7/vgRLKmbli2pguaY4EBD+feCwuyVgEoha801VopOgQyW9PE8HJUZoYhluPzTmpuMKbj0ygF3ZQe3m",
	"AwKuupb96ZfGwwD+Lp7LTVWyYea5QvdOLOOOMjXk7ouqXnv7jMzzWjUG1q6j/0+05FiOVUP+PiFlBQn7",
	"KsOF/Q/kGJC1wf8zqux/0Cem/T+EqohPskPN4F4g7ZMfyIcQzqwwX6Aq0fVNcVFJv5reobQTOfn7BGdd",
	"sHMJxgpwbW9y657S3KBt0rnsCWYupTrvs2BsW9m77ORXiQt09tEpVaauCrXBoOfg3yAxX2DIgdZfnBQX",
	"TDm9v3T5CVHDb9aMq35mH+KW1/KH2INfU6jwiglhJrlg9CWgBMpvmDBUiw1kU4Z0QLEcGvnJ9P3hcrWr",
	"jDyFNtDkVBtV50ajS1wzZ+/W7UGj487+QmJdkm0prdQcbXlGZopdMDqkosZ0X7/WzF4ymKlsYxIGSF3s",
	"VKTYPWMcWw/7LcduIBjnQnOD5h2XeJHaM9/Q6mec5ReSkXe44pDn3XYgG72qDvdawqFSS9e0NNmgFOH4",
	"N/KeliYm03ZBzscheIcMJ0hFDnEwXOnuvcf46hogaDfMijF2+vIK7PQg7oB5AyJGDqf9pC6YwrDWyeDw",
	"k+/xaT670328Cy+2jxWi/U3bRXwoEWpIqzD8V/+cmjy8UP+nGUoTeBsJPzl4ukwYtbtKphm+ynQpD9je",
	"e756bzvsOVLfrHempbxkKrPzjlxx2Q5vwJatPMWh0ASOh14CrCB2M/pqB4EDH3QSrsv+s2jG7jhk0DKX",
	"ImvNfrdYB/FlBtCVhYD1PadHN+3Tq7zseijWAiSx42I1nBTwnO3uh6ye8Lbt3SeYN4eVJRg4E4z5UV7F",
	"S2dARQNZm9HZk53eikPAabqiHSPvajBsaMNzJSk4IjTpi1mPg3XCFPjxhdMYc65IK28xyTN2/rCrWHBI",
	"7Rf52NDKyzMg51om+OQ2lUIhWWnKmzKXwlAO5TuSzD06orKyAkTV6J5P7hX4/hRR5o6fxfj55BsAoMgw",
	"FPsu2//3j8woxu7eu/Oc7bKSL5nhA8bYEmJo/8Z2xDc7uTGeYij5TcugBpJ9if7wTUIfIhV+WcGXOG8Q",
	"QTwKwara/6VJwQxTGwuKa3lJNnW+Bt6drpjPnAMGEfCq7kzUGt0nE2hngHLBV7qiOQ6EAdolVSumiIuZ",
	"Jq6CcDCwbCiHd9J4wnbDIsFJiqaMXfvy+bzBoO0Id4FpMsrqk0gb5JdxznanaHmD36+ASIaTAw0sDFIE",
	"3eKSrpVpKE5WtQdez1tGSywt1MrvFZZ/g8ZLuz6nQjjQeNlPwzV1e7APeA61Zv19To9Eic82IeI2e5tq",
	"ee8f7rDB3CymGMyHDbiA6PFAoG4PgaWSf375T6LYkilQYX3xBUzwxRdz1/SfT9qfLeB98UXat+eubPUh",
	"77wdw82bhJh28cqO3RIJPxRYwGJZ6O4vBbgwlmUnBEgUBOK+gWWhEBHBSlmxZGs84OjSIb+XYqu6pBj6",
	"woVgqtVpSuIWVAmYrXDqL/jzw1ak2sYsJrSOjiNV3DCqIHu1qp+dKlaYNieHBDVXHbFJcdOMiKkwrjPi",
	"S8zDEUaEoZZMXWfMD26MCQXlVkJhPkNU0HEflg1MMd5wG5pCqLYvNOcTzoTwLvZrTUsXviYgWOwDJF3J",
	"z5nAGnIW87nKoYQJXSunJrRrhfHsUtwwMibwumly1Wpy2ViFJpWjRth5eLswfEgghF0t61HYy5HjRTts",
	"eyt2juQayyHZmGvok0mC7+Q+cQzAWG2G7eadJMJxpAUk1PP9B4ZvqmU0ZZzTqeaanIEdao050h++evGI",
	"8G4h5zipXyR87d92XLBj2oowt0NvLd3UgoesYsnYUHhLJ9COLNmAenhfWYjlRVMRAlp1XZL3rnJiIP73",
	"VEOJB9fcRWnd0+j71iLJqxdJlqOVCvXgsgHz2UrJOh3JvML0vF3/SysYANOFQj06dJ0++eZbUvAV0+aE",
	"/ANypSHx7dfdat8m4U09r1bZQAILC/k3kR9ywXnRnGt3ob1gWe6C9GCYu7/hq2Srns+AL8nMNhXw/arH",
	"s5DKRTRC6sgI37TcwG8izJsLoygi30wul8l0qn+H3xtXBOVxsmL9W5+Alc/ZTrGr8i5/g87oeTWKecqL",
	"UJrlaoinZENFGctt4vl89SRrXtAJeW17EyaWUllJe1OD9Y9tIa2aM8LFXCrkGjNNgVpIMyZ+Y0qCIkEQ",
	"6Yzd3TcWDhuiDmkO/Lx2UbV2DSFvalBWPnwP3MwcF/kI5dT+UyO1MBzZH3uMP0WnWFnCYxf9jzUvE1BQ",
	"Sftdx+uYEyEJll6PW2KYf5MzD9fswqRbgHS3zzzOHV2kzf8WEgrMw9+UXGi0FPmaiqaW9P4E/X2YnFb/",
	"tVe4JvHMb7KQwMg6P69znJAD4ZLClUuyAgpkrwsatbtdcEV3GybMFTHfW+yN/gpQS1WNSwBqQALwvfdV",
	"pj1nu8zI9NgMjU3ImQdRC3SniG2jPc4H5J4Qc+arcDe8K74gyyIsazDyRuZMrzt1Il3w4Tpnu8YDJq5M",
	"h2LTFaQsJItpzfgHvmGNXIKMXIoF4pNIIoqXabkWcwQhyn4wsp0wzDhU6AGowL7jMDHZ9huBbWT87eX9",
	"ucIriFyTIDfFSGjFrmLtQLdWId920gfQGZyQFyFpCvj+Yex5k0kF9VldD0HMEBKS3XLl9V5UeR02OBGC",
	"A9wOy4n3EIFrgLyRbdPnklwTmi+hwZAiyDfbLplq2qWUMb7lUv3WNOzrgXyzqio79agSrbSpwGA0dNON",
	"I2RFdzPPDM7mM7st+49dtv13qX6z/1RVCTU1q2XfDzL9gB1MZDBPIuR71pZaW4xkeIkNaO3RgI7WWnOB",
	"rEus8Rqo6qHqyVipjtmlmx+e07L8sBXON7AfajbijUkrDDd77bwwA4a2aNy5zHqtlcMOsXWG5rll8Yom",
	"BUK0zgeadItkYGKEfpmMEQ/NvRi6ywLEsEnVanDfoLDqs6E8J1StakzHcwf727ODwdJwvHA5/Pr1zRzL",
	"hmihVqwgUrnUVnzp8pYNJeifWLSIVo5n5HnDGjZZGQYgfW6FH1a5VNlSZHnw5rZ00kqYRpKP6AX9cXZC",
	"XmEOFcVogQhWccNS5XNa+4e0o5cMygZ7iM7C7UbF0U7sK2qVJ9IA2YqBT0WiYNYftSATrXQ9cGNDWAm5",
	"qvYlfYYbem5nahx88JJyKoQ0f6B7OrAgU7uKQRy7UFWhMlPJ7Ln/WkPQmUXYMOyAjlYqxldioNY3AMiS",
	"ekKgu9eVJAdtLOXS78UXr3tUIrDjV0OiYHnBwSy6sDCXQan0ETfwBHoNZzFQfBwRXEi+qJt4F+12GZUy",
	"mLZFj2beRjsEwPas7E3u7wr1s65dNKszQAtr7OvbCupJlNmKaWF36H2cWWTlHOXMMK9+aTeO+EmxzNNP",
	"j7FEgSn36yZG6KN4Sn5jSjphNQxlH0SjG3d5l12+0JNEp1AfQ/e6dac8sP4Ibn6EOxys6/Px489b2uMy",
	"YE3X4C+uVqJp7x2/HKj/EN+xN5W5gg/XLOyCM44cbBPn2LeI0aLopMKP/b4QyYRU7njarhAGAAu9HKg5",
	"MXqby9HbHBm/lZHo0kuHmI43jT6dNIm5ny79iWOPVCzlcFxgUyCoP/WUxx+cByaBhpeQrwscftYR8Bgp",
	"20XRc/RpqMjoFifD+k6IQyHO0O5/V16PUy49NvO2OW89jiHNUiakaxta3WhRsL3II1rxsM8BG/Q4aPJ8",
	"OcLsx4tyY8MAjWuDZTW9MTLBMR64dT96+gbhaze7E42z8Ou1rMsCE/FvIDVZI2ImLsdV7wlsYVNWCb04",
	"wOkijmvW0QzxWRPyyo5My0u6015P2wDW8HD+VDFdf0JHGOcuROVy+mxUjp7jLOcVZ8IEl5v4XiyMD2s3",
	"0wM7LalFOphUjV8EpYXzxadNPay25c0b3lxlHxoR6Lk7Zlq2tQU4sNdE2zbP/dh+R+FKI3q2P4tHqjpa",
	"ONI9OM+ZRkeRnVMrHorjsBciOZxmGLsJKdoxwQM2GWEb2Ut7Q9V5iwa6x+oGECuM4G+N2mIxorh7zUrM",
	"zNkJSx4KmtGsdJaMt/Wi5DlYEcAPPNgVXBBAQd5RUcgNeenz5zz86d3LR0QxXZfGA5lP9GuBz63k82bX",
	"H9x4pZZu5++jAJqwfS6cQWXFtVEJveXdJ2GThmX7/I1so6U2jdMR2qsx+2EvRpw7LJimQjDhOdtlBS/r",
	"QUC2rc6Ldv5JXS+gdBcXmKR2QU0Oziy9JeiRqfc4ONg2JW4VvByuu9NpDwa2615Ma5aq837uGwDtkSS8",
	"dXUcezrDzaHo03VD/Olmuhp7iNxhEzkR5cW19+nrg3QI/7WYrGgKDN2y3Id2BeMaZqvtUdqUbhTBMTSy",
	"I+z1OG2PN1Bn3vFZMAlUnOJ9jstOCNTf0ZaGM4L+hSs5WUbMz7IWhe4cYVP6fMT8Osr7ONbHtxm15A4x",
	"BVM5gVYcbXslYLd0cShNCLXWMueNDR7KAGLBv7+LcufywHULXDRHWSl5wYtU0fFSrniuUQNzqMH4te/7",
	"aT7b1KXhVxznje+LFuw0OeQrRwpFQVVBWPHkm2++/Es7O8I9Qlf9Q0p697htOSUjNTxv87FhdxOQmL/K",
	"k5Xso6xBW5taNaaHYFtL5UidbiKDhQxHw3s9q/MPWewIjUBdWra9NLz5aW5/W1O9blBnVHwWigJT4vBV",
	"1+kPQo4iO98dR6Q7wM6u5ZfReR5DiKN5JPfhbcToEeFhKkp8E2GSfm1Wt0VUu1p48XGYcNZVySxv1+DA",
	"wcw6/mqQ5Ps53/N+Dfd4vPSpQwMoNictJ4KpUC0z2XBcoCBoVnUF5+De+byP15VKRbdWTNsVpZ1v1iqZ",
	"fGQs5WWTbDCRZvygu33fOdNOshI4t0EOtzr/TDltxmDgfiR2SPthjbPMQ+kZyJS4vJCfqpuXaph7jhKx",
	"joH+YIrTtvw8PcmJW07XyW3IO01X3j/tg3dIc2XufCYE8grBv3FqBD5WYAobl+UObb8uH377vK4fpf8J",
	"AgSWEhMeCENz02Tznj11I81cddXZ2phKn52eXl5envhpTnK5OV1BkFNmZJ2vT/1AkLmxlU3NdXHFoCzZ",
	"LXeG55o8ffsKmGRuSgbxEnB1UQ7bs9mTk8eY7ZAJWvHZ2eyrk8cnX+ITWQNcnGJm4dnZ75/ms9OLJ6ex",
	"b9QqFffwnlGVrxGMXdsTyNzHUJx9VYRGL6V66odzdi4wEc/Ofu4ljQPVKkSJcPv3rzVTu5mvWR3r/Rrr",
	"ax8f7o+pR72URodfUyvMUqAYyT3XHrkWgPcAYRdMEI6QWPIND6XqFaP52rFpiTVD2wMX3JQGoSsWrfeE",
	"/KhZVJpLnkPIEcoXPoDBV5YKnQYWZodIravBcf2Acjw1J9uA/ycV3tSygiA7sJKJyFH5pFXbxunmfTU4",
	"TDCa70gtSstQensTmIl12BqUPcIMNzl1J+Ci+7yXtB6+AT9J5laY2RUeeCOujjEIw8A9OL9uUGs6WdnB",
	"+DwkS40dRea+Kr2vG6/nJKQf7ZgU5s7Rww6LnyNPJHBBQDeSoQ07l/OMlmVqm5FxsbvNv27dNhvox93q",
	"Ol+DS1J3od2VYQJNl5wixBO5s5m7/pGbiA/NDO4hoaVoHeCEPvY42LYqZcFmZ0taapY+HoabbB1N4Ai9",
	"Ay6enfOE6QSlavS91VnkDjJrBdTaFkKKdHrSXpZCswPUbYnO7NBXB8/m/j45O8W13pt3u418KoxsIsuh",
	"fpx9hC6hU5JqhND4YWy315l2/PPQ8j2d8a4s3k7pQsWwvmrFFAwpcrCmacAWXlWNMO+9qQqu6aLEFLSg",
	"h2q54gB9AD6o7YEWO98seQlvCG4RaR8migj2S1FYxJRx0RB28hJ62aEXOxKhl9YwIyPAAQS0iMZbeOBh",
	"hh+kyFynDRV0ZddoQddS2DiEBk2OeKqg24yBdwwkQ2nFA6AwzmE7zJR0HbFGZvjFCudYtgGwzZPHjz3/",
	"6PTr0Win/9IoCTYDDjuwHxIOl0JCvjrVaKqBUHO0dQvIN22q2gw7x2xNBtxKf+QftSMUFV1x4VzK4GY3",
	"9ByZegyMdB6dHkP5zBKWBQrmSMc0uVczQXnc8KXtA/glye+3V/4QPLse2Q1+fa17HKzXMVw3o7MP33DK",
	"st85AESvdKz38Wk+++aPvgUL1HSlodwKyB2zXz51pJnT371LNS8+DYo2r6U8r6tgFLFCnkX4zlrdlnCw",
	"rXtXz3aAJEYlnGBq8XQHUArUWGgwSljkLD4jo2p2EL8+lQrdIMY88slHPvlu+ORbIaUHENBbJJhpInWk",
	"UbOvH399JLP3h8yWQPz2kNnTHgbYR3dF5OjZxaOyQnRb7rwG3cdGYaKgEer8tKogFwVopfV9otM3Lmb8",
	"WcnyUdF7JUXvDZPSzns/QDxtZmle6lFYjSK+Ogd75AiOHMEfkSMI8aWfhQ/wosn9of+3YvU80vwjzb8z",
	"mh9e9DRCH5fPPNJ3T9+DEuVI1I9E/Y9G1BPppA8j8V5bmVZmXovkP8ehn8ZLO8r/R17gyAvcjvzfQgCH",
	"iv5HhiCR4uXIFhzZgj82W3C4zB8Ygo4t9EZYgaMS4Ej4j4T/sysBjsT+KP0fyfwfn8zHkWlTHevaiYY+",
	"tCrfKebQNiuIYJf2sRlJZGmJ0R4KHw+0j8Af6cbNRAZF5bjsLEu+ddjZZ4FyJY8bH24hDcNU8IOrgLwr",
	"MNjBjvsYQT/ktx++/p6c2Cc3jye9ubzsqdPjK4hz9L75/7KH5gGxbtKDBLdNn6Y/xMVCCn3NVyQLWRrs",
	"Lxv8CSJ/3/OV/anEnyDnAEZcp45A89XwGWjotsF/7HiTNukef7SRdrqFxc4x7+krSXO+99L31U9JDURe",
	"LDEoLp56w0U2On1ocCNLWLCldFFA0Rrods8afINDgyZuVZDxO4v2tOIWAUPxbfLG4RsqyLuXz8lXX331",
	"F4Lv3go2CC5DG8YhsaRJvLiANwpqwucpWOjdy+ewgPfBpXVSq72XGiDqpnYOI96/jf+J403/lEF/nzM2",
	"AnftNBBOqMQaT+NcSqgENaqwuFlB+08iIM9nXani+kUdO4JS+yQ7Ex5jwP5Hya1T7NJxVou28WUoscUB",
	"JuXbN/NimC7KD60qFeHRIccQInWbJHtJhI7NrsZ4HzXOR83B0dT8ZzQ1/4+OJI7O6fT3NrLeH1Eclaob",
	"0mE2TdLRxCmWuEsy9rLFfzqD4a2hnQORzd0FjV7TinQ0wfxBWNkeEjpdyO0gIvpfwP5Z6b/Fi8IzXMgt",
	"se9q7tgX3clDGxpAa6dzeOZ+ayoPO/3+SrqibLnFJFStsLb0AxiMi9UZDPAAM+BwwCa140OwIRfm7Msn",
	"X33tmih6SRY7w/TcrQdWR779GlZjuz5YfPv1A299oJBf3v509vS779wYleLC0EXJnIahN6c26mzNylK6",
	"Do4/Zr2G9sPZf/7Xf5+cnDyYgsrl1mLzp6L4gW7Y3SP1p83dcQFXk93ojbTb3dWhJxlQPN/piqHrUoYx",
	"5P9MblPP3b6ZKKnI0Wx/pBk3RzN0vdlQtbO4nhl49hGoOW85VAJ0uNErExumDyU3DYWB8vCBhECeV9rm",
	"ArVUlsMs2ZbncqVoteaWouxOJulknsHy7hzfHpUD90s5MFwsuuLFtlO3nXBRsG1afg/gPknT8ExuX7gp",
	"ZbIg6Zg6oJNMf8ktZAQyjkcN13NbSgNgrCrFKiZc5YuPM0vaP84sVJ4zVnnHhAAQnpU4SN+Azw1Pdgrm",
	"exbjizZuOZLSIym9TVKKYDeBiB6kNjot5UofoDsitv0EqeO1XOnPo0Q60r+bcav7zD5Tf1IHJqjqFDwB",
	"eoX/Me+wK9U1bkDDVllTtfd20g/ff77pVo0qpVxlnmIcnmdo9cJ2PZA5uy+2GkTV19D1jmkZxyO2YlM5",
	"tByTyCZFWx0tx0fieAC1ajk7YErxO3Rz2D+7HX2PmvJG56sFN0Pz2W+zuw9HPMaXHePLjqLpXbonwCWf",
	"/u6f536XBHjmU1Kc24bTpcm4QPvRGeFWnREAzU3FhXeYtRqmPKKbozLvfvtSdDHm6YKWVORsr0YOWW9t",
	"QA3t69xcriUgFJdwHxDMKEb1kx1lo6NsdKzUd4ycmho5dWNM181yIzHynCSlveGCH9OBpqjeoiENR5Ht",
	"z8SAHJJLo2WeAF2sw09jCTUwjYYlqZhaY1TmO6bTOKbTOKbTOKbTOKbT+DzW6GPii2Pii6P49j878cUU",
	"jxNnxLQLlYKhr3SrMZL/QS7ktp1Qept6LjcLLlgjAPkdNB6mRtqLgkZragId9g2NJDp4GezZV6ZkOUBf",
	"wQkHhOKc8Qv471Ix9hvLDFWWuZ5Cb1u78QuE2pvR/HHxzYP2ZpliVLgRn3DEl79WG8hza0IyXEKJ38nc",
	"8sk7WZNLeCwlP4f+rnCnPfQNsUDcKSZuJDGqHjROu+4ZrGdvapP5XRiAjllajllajlla/gTakEUp83N9",
	"+jtcdYZ6hL1GbOg0pMR4Zj/uU1zgY8Tp0nmn4gVdE6l9z2jBFJGW6C9Lujoh/7CPE14fuJYaj6Hnjc4G",
	"9kgKyVAX4hQAXR5AD+C/NUyZ2SlvFwWOhsPATRwjz//Az3OSajLyDJ2a4rerkfTseppt5BrY8S7THsTE",
	"w5IHBy/Vo6bzqOk8ajqPms6jpvOYOPioPz3qT4/606P+9Kg/PepPb11/+jl1nrdfjPSoVT1qVY9qm88a",
	"FhRf7envVibaHxhErPhYtijkkIo1hrop0UFOKLu7JG13iEKi4zrosU5/nMcYmiN6uS9a4U/zmWbqwr/1",
	"WpWzs9namEqfnZ6yLd1UJTvJ5eYUklS4/r8Hvl9uNkCowi9u5OgXh8o+/fLp/wUAAP//kNh9f8p7AQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
