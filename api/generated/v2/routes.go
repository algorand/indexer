// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
