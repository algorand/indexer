// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"kaNfHCv79NOn/wkAAP//0i840mAeAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
