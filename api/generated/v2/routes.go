// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//V1Y4WK5iAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
