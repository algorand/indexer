// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
