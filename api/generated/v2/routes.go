// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nZwBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
