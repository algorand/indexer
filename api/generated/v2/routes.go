// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
