// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
