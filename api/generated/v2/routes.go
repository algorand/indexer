// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"FwAA//9wBkB7MHwBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
