// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"oAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
