// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9+2/cuNXov0LM/YAme0d29tHiboDiQ5ps0KBJG8TZLXDjXJQjcWa41pAqSdmezfX/",
	"/oHnkBQlURqNPXaS7vyUeMTHIXl43ufw0yyXm0oKJoyePf00q6iiG2aYgr9onstamIwX9q+C6VzxynAp",
	"Zk/9N6KN4mI1m8+4/bWiZj2bzwTdsKaN7T+fKfbvmitWzJ4aVbP5TOdrtqF2YLOtbGs30s3NfEaLQjGt",
	"+7P+Q5RbwkVe1gUjRlGhaW4/aXLFzZqYNdfEdSZcECkYkUti1q3GZMlZWegTD/S/a6a2EdRu8mEQ57Pr",
	"jJYrqagosqVUG2pmT2fPXL+bnZ/dDJmSJeuv8bncLLhgfkUsLCgcDjGSFGwJjdbUEAudXadvaCTRjKp8",
	"TZZS7VgmAhGvlYl6M3v6YaaZKJiCk8sZv4T/LhVjv7HMULViZvZxnjq7pWEqM3yTWNord3KK6bo0mkBb",
	"WOOKXzJBbK8T8qbWhiwYoYK8e/mcfP/99z8S3EbDCodwg6tqZo/XFE6hoIb5z1MO9d3L5zD/mVvg1Fa0",
	"qkqeU7vu5PV51nwnr14MLaY9SAIhuTBsxRRuvNYsfVef2S8j0/iOuyaozTqzaDN8sO7Ga5JLseSrWrHC",
	"YmOtGd5NXTFRcLEiF2w7eIRhmvu7gQu2lIpNxFJsfFA0jef/rHia10oxkW+zlWIUrs6aiv6WvHNbodey",
	"LguyppewbroBHuD6EtsXz/mSlrXdIp4r+axcSU2o28GCLWldGuInJrUoLc2yozk8JFyTSslLXrBibsn4",
	"1Zrna5JTjUNAO3LFy9Juf61ZMbTN6dXtQPPQycJ1q/2ABX25m9Gsa8dOsGu4CP3l/3TtrntRcPsTLQk3",
	"bKOJrvM1odpBtZalvex6TiJKRkqZ05IU1FCijbQUYimVY91IPuaufyONkBwOsCCLbbelKFqj7+5j94dd",
	"V6W0K1vSUrP0fvnVx5sEq4yZJC3LmSO9VmJwU2bhB1pVOoMVZ9pQw+I2VWVbCClYgpOGH6hSdGv/1mZr",
	"xQWgEbPmdLK8lJplRu6QJLxwABsW8f54x/aSK8j7NSMwuf2AMhVgtrDkpiy3xLgDsAhBvBQxJ3xJtrIm",
	"V3B1Sn4B/d1qLE5viD18OLKWyGPlxiHk7m1GArUXUpaMCkBtJ0Nm9vyGuVnp8RqbW8YFExSB0c1JwUoG",
	"i2yQEH7VRsktLN6iwpzIyh66rE3/cojCDYufu3cFEGdQXI1XsmPRJd9w01/uG3rNN/WGiHqzYMoeuOd8",
	"RhLFTK0EHLZiJIczW7RufkVXTBNmGSNHWRvmsYRLSEMUo/l6mCohTDsI0YZeZ0rWopggUhoiVcyydcVy",
	"vuSsIGGUIViaaXbBw8V+8DSCbgSOH2QQnDDLDnAEu04cq72e9gscUHSqJ+Rnxzvgq5EXTAQWg8SSkUqx",
	"Sy5rHToNwAhTjytzQhqWVYot+XUfyDO3HZZCYBvH4DZOusqlMJQLVljeB0BLw5DaDMIUTbivCLmgmv3p",
	"hyH5qfmq2AXbJoluFwFwOUFnXdsv2Hd8FWGGHZd6Ih4ij43xbxT3JuEdNMqQbCRkJPvVEZW0faDVf4KF",
	"IJ4btdPsTpYCHMOzt6Gt6Mx0f0qJ5qsMR+zdEr56b3nxkpfAp3+1l8OfbK0tX2qfrefcmq8ENbViT8/F",
	"N/YvkpEzQ0VBVWF/2eBPb+rS8DO+sj+V+NNrueL5GV8NbYqHNWk5gG4b/MeOl7YUmOuw3NQU/nNqhora",
	"hhdsq5idg+ZL+Od6CYhEl+o3lL3KoZlTavJrKS/qKt7JvGU2WmzJqxdDWAJDjhFCIBq6kkIzQNdnKEG8",
	"c7/ZnyytYwJIeSQEnP6qJaggzdiVkhVThrPYTGf/+1+KLWdPZ//rtDHrnWI3feombLQ+M8TD8OZS42gX",
	"0ixHzVAK2FS1QZ6eIgvhHn8IsHXnbI5FLn5lucENaoPxiG0qs31sAXaw68Ptlm6J8xP3rSuS3+M+IlfP",
	"gDv3R/5ZO7WpoisuYOFzcrVmgmzohSUHVEizZorYs2DaeP6OdA9ZfrAvOiHBSdons9SNSZypvvOhNqf2",
	"2sq5ZyDnHuKIO0rXHmedAul48uHkext7SBRYHejsRw2v5+cfaFXx4vr8/GNL1eKiYNfp87jXwy7lKiuo",
	"obfD0dUL2zWBoF8yDrWN2odCoMMizx6n8LAc9VDbdeDLdisae6SsiVtxd6KqNTN/oSUV+UHY6cINNfmE",
	"33DBAYi/oo3reMz+mMNWHuKI3e4e5CKjvXryFT4ebuoOBy/AnY/2UEc66SAfWCOEKQ+xSZ8L8Y8Yf1iM",
	"/0sp84tbneXYUcGoO2b+SSmpDoBFXn7vrHo+2zCt6YqlDePxTvqGU7bOAwzHzuwSwHz4V0ZLs36+Zvew",
	"mdHYO7b0fWMwO8DG3uu1imx7u9YfrWqHQN4eds+bEE2jv/Td+3KIUmvLp9Py1pl2Kfr0M9b7HfKNtxHH",
	"RuBEyJYLr+QCPQVcCntS1EUgoe/mXJyLF2zJBbhin54LS4dOF1TzXJ/WmimnBJysJHlK3JAvqKHnYjbv",
	"MsIhRwoEmThoqnpR8pxcsG3qFDD6JW1yKVfy/PwjMdLQMnI0RzExzr3XGIz7KIcTZBYzZG0yF0uWKXZF",
	"VZEAXQfnIoyMwTljs86JGxt9oC5WzY2fvga9AI8Bi1PZsTfpRBwMF+1AFXu+f5fGeQ3pFUH8IrVmmvxr",
	"Q6sPXJiPJDuvnzz5npFnVdUYLf/VRNVYoMFtcVALKCwczjNj10bRDOIAkss3jFZw+mtGdL2BkJKyJNCt",
	"Hbyj5ErRjQsp6IYFjRwAwjGNl0UrhMWdYa+beSQM9k/QfoIjhDZkzcp+YNG+5xVpUbc+rh2a2EjM5vn5",
	"BwjH9CcTAoRWlAvtuYLmK2EvgYt0WzCSWymAFSfk1ZIAVZu3urt4a0cxA+ngGoPTyHu7RvB8k5wKCFqr",
	"CggT4oJQse263DQzxjs437ELtn0fOc73dMC6KBu6gyUWtR0usMXmhMkV1WQjwfmaM2HKrQvcSaBmGpia",
	"C4MRBK0wsAGiAbcmis+yFycmIQMRblG4Eq0qsirlwlGagKJPA476PsNE5a0FQB+AoCQVp3bEXHojqEps",
	"BF7EoSC//Rdqx7vTNRxd3q1RbsmVhqAwRh2PoPEVuQXmuYi1Pij/XDOQyqSCyK02Sml/pVNIHwJS5rOK",
	"KsNzXk2zouPob1t97CC7WHuSmctll2f3WGqShWDjbEF1mn0z+8ViYK0xmtGu0RM6PxNKy7CCEwLRJ+6q",
	"LkoIcAyh8XjGVEHkpV82hooPgZa+F0yJRqbyYLR3JBbe1lT7IEyIJPYkYpKYM4C87+0GAALbexNhbyy3",
	"cjtvyS7p0P4PB768EoWlHUy3A1JDWItnK/24YB8/hilAPvzFx7z4QBf7r8X2uiwJX5JaXAh5ZYXjfUJZ",
	"5jMr+dXpQ5ICJD9751a4HdjYo48D+A86OjYL1T+Wy5ILRjLCwx4Y2AMM+pY5x9ja5n66OZhVDL4hFgft",
	"AJNHSCF3BHYlZYkDk7/L+MaK1T5ACsaBxlA/NhCb6G+W1vBAwANZDwNpuUhjY+7pgpUwW8wSAINI/QVj",
	"AuNxCRdzYvW8S1paacVIFF7CIOm49UctUduJefrxkByftj7gioCL7bUm5Hu3WU0sLHqg05LsCMTjckvq",
	"CDTsF0oRzV6NROfvnHpAVhjaq0ew8DsA0DV7hlBAp/LuVE37HK0h7fMm2BLJSBrbhzAmeS4DO9a3VITQ",
	"qrddtp20R7RaEWyycPp1JJ6lSLK9FbkUmgldQ0qLkbksT3qGCM1KBpJN1pIksgu2TeswDAjsme8WGSnI",
	"I760KsXjSHRRbMW1Ya20kxAJ2wT6biFVo6LGMGUn+n+P/vvph2fZ/6XZb0+yH//36cdPP9w8/qb343c3",
	"f/7z/2//9P3Nnx//93/NBrgGyyol5XJ4daZSS7u+d1IGqgwdCXRsLfPBV3ApDctAQM0uaTkQbmMbvdSg",
	"PL8EWTYpMLQOm2DWFB8wPcK0F2ybFbys0/jq5v3bCzvt34O9SdeLC7YFsZDRfE0W1ORrkBtb09s2I1OX",
	"dOeCX+OCX9ODrXfabbBN7cTKokt7jq/kXnRo7Rg5SCBgCjn6pza4pSMEElj9C1aip2c4mxcvZ2EbnoxZ",
	"WXuXqfBjjylMERTDXAlHSq6lHeA0vAqIhoPMJG6iNCzdW9FUBRes/8gPommuaNDg712RjVcXK7NulLQ2",
	"6z7eYXn94acu71Dhi3B6+9hpUFLqIRhcHDfYDuSKTMf9ZAYrJHvzN96WSFXAXEURr61/jZpsuWkH40UQ",
	"l7wn68BKO9PcGwKyhCqBa0/hIlkquYGb1xdKI+TkAxp5CwUbltOZ1dWG6OOLJZ6Qs7zTg8Zo+Te2/cW2",
	"hVO1vb1gOvXKNAYKr8M4teVuR3M3X0AK892IOzEfQ3KH0B6qCKBBtuXb2/MGlHKVtjeUK5A75KpJ+YrR",
	"YcGs7seuWV6bJtuvY08MJs+HlSa7ttN0lk7ktsWSFuPyA2yUG2vH0b0NdPI+T45WlZKXtMycs2uIxit5",
	"6Wg8NPe+sQcWx9LX7P1Pz16/deCDW4VRlQV1ZnBV0K76alZl5RKpBkisT4lfUxMsCV3+75xdXLccZFeQ",
	"Sd3RmK2k5ZALCXTj/Ixur3OYLb1cvqf7y/lpcYkj/lpWBXdtY2dHb23bQ0svKS+9gdtDm2YquLjGR743",
	"X4kHuLOnN3LYZwflFL3bnb4dOyhRPMNIyvQGE/c1kS41Oui5oNyCtRwQdEO3Fm/QPNknSaLeZPbSZbrk",
	"edoFIhbaooRA771tTKDxgJpsR7S8OD1WzaOxbDM9wejWATKaI7mZPvp1aO8W0oUX1YL/u2aEF0wY+0nB",
	"XexcT3sbfVGWW6tACR8fFm95QCUIJtxH/XFlLO60uDDKbZQgq9f0J3Wn5tYTzu4u+k9jI+7LfwDEuPIT",
	"B2L0wH0RLKUei4LdnYqWz3qPeK54xp6UMRKL5S6fIxW14M4LcIvT2V1zzCtartxJmlzspUfF1VPupD3p",
	"bKnkbyxtPQSj61V/+mhi7J0efLIW1Lk3A9oQ75RUusVRhfozdwUpaM93BqrLO4MzpSlI1xzS4KUbEttj",
	"p087EnCAsMP9i+JNQEH13lAq8MI9h8J2LY0pfW3jENFTHL+5tg7mvl2DXi1ofpGWni1Mz5ooq5bf1kji",
	"O4fKQu1TOiFRwFZo64r0VExtuGmzgUYxu60kjNNOloEbkRewKhZ2XZ2vUsvEMLW4osL4UkuOoLnemqHn",
	"yfa6kkobqJyWXGXBcr6hZVokLmD337eErIKvOBZJqjWLSvy4gUgluTCIRQXXVUm3GMfWbM2rJXkyj6ia",
	"O42CX3LNFyWDFt9iiwXVIKw0pivfxS6PCbPW0Py7Cc3XtSgUK8zaVZ/SkgRtBSw/IXxiwcwVY4I8gXbf",
	"/kgeQeCI5pfssd1FJ4LOnn77I5RFwj+epIk8FLsbI7oFUF1P9NN4DJEzOIZln27UNBXGcqXD9H3kNmHX",
	"KXcJWjqWsPsubaigK5YOx9zsgAn7wmmCF6uzL6LAAm4gbBFu0vMzQy19ytZUr9PyAYJBcrnZcLNxgQRa",
	"biw+NSVmcFI/HFaDQwof4PIfIUqnImm73sPamLBaS2rVEEv1d7ph7W2dE6qJri3Mjb3MEcQT4qosFUSK",
	"chtZNGFv7FwgoFhhE+zOS1IpLgxozLVZZv+H5GuqaG7J38kQuNniTz/0Qf4LlKIiTOTSzi/2A/zB910x",
	"zdRleuvVANp7Ucv1JY+EFNnGUpTisaPy7Vs5GDiUjkr3FL2blDA+9FR5y46SDaJb3UI3GlHqOyGeGBnw",
	"jqgY1rMXPu69sgfHzFql0YPW9oR+fvfaSRkbqVjb8LvwiSIteUUxozi7hAD59CHZMe94FqqcdAp3gf7z",
	"uv29yBmJZf4upxQBTPbsb4f9OV72kIot5cUFYxUXq9OF7YOiOo7aFdJXTDDN9TADXa0t5tjPluVFFhEY",
	"mixYKcVKPzyme8AH/MorBjTp1YtdUPcG9sUiM2g6vDG2nZ3irS8uiUPb9p+DI4XI6p1pxO9c2+FAaMvG",
	"MJXmuUt8waiftgcW13tFwU7ORIFiHZC/NeViIDqasWIg8o3BjGdSGY6xJ4x9hjg2wzdMG7qp0mwWDMd4",
	"E+FWW0BDF6uNaJZLUWiiucgZYZXU6135ugN5ZtcCJiu5RpYTl33MpcL6eyBTGNnJpZya6TGaNdqGMVNS",
	"miFAQfiI032lNITWZs2ECZHUDCohd1eCuSCgcSBDQZJF3lga7ysX0rLczgk3f8BxlAsfpGTD1EXJiFGM",
	"kau11IyUjF6ypig5jPYHTd5f80JDyfGSXfNcrhSt1jwnUhVMnZCXzrsMWhB2cvM9OSEuC85Fgr+/FrC8",
	"QjJUkeJ14jJ9QH/wZcQrniMD7f4MtaI1Ky+ZPiHvryQCoZvMYW2FkFaPRW0wg6bgyyWDewrLAeUJ+jUf",
	"IpigvDoEW4dh3Zo+w227FhnIxwNKpEFLxbV4jo2ISztpO4g6V2ODGqtHqJIVK6bmaEiFbecb1mSKW9lN",
	"KtMYbJYMszEsZePCKFnUOcP85LMWPkZg8R5IoSJx5OEHHPLV7Rs4vbHF01SrkIOA+wTFLCHbK4SzY5dM",
	"YbR8M9AjJDoRXNpQBaERECnhlsqKx2niXFcrRQs2za8JRPBn7BHyav0Il3K/AX6x7btiU0s2aXH8NJeO",
	"Ys8tl4lpeYqWDYpe74bSlF5iWXjFSswUgYri0HbeE6yWjGWai7T1c8kY0Haa56yy6By/58OYJVQoxAKp",
	"gMRWz1vtCQvDLxnmsIwIA1lOy7wuMR50hNNf5bRUbTdKyZZGWgSLn3loTILczrWAeFQsxY3zKUsAox5Q",
	"0eOSqa1rgdqTr3xtL4fq+P77uWJZyS5ZWqdhFFPG/iqvyIaKbTgLO0UDxjxKLAmQo6wCjmU87Z+dYheB",
	"j5fJYd04kPYoBja3iM+5YorLgueEi1+Zu82BLHmMwRL6Uhguanh5QLEGbuQTBLLfuhlufQxQQzn89kM7",
	"mFywq9ZpF5E81w691oZeMATb5+k51jj1TBXTvKgHTJmK5m3I9kNGd3nfUcNOVThafSC87FCocMnHLl0X",
	"lzto0zmt/i4N0qkW8Z1CrGjIVCGOUCeiUV1xEN9yQPeRRnqLk0+OD2NfMqXbcY6RDZBd7xjbtmiNjyVT",
	"lET7wv6zZD6MRQ/Ot0Vy3OCcF74wuxX6MxdHkdjBgXoyAQB9xU2+zgZSO2xbbIGpMR1Nqz8lihBwC9ly",
	"yXIzBQbIEcCXJAahwM8WiheMFpBw2aR7YKJHF5RHf5fEDq0juUZoDlJoI9bAKI/3qAcaMGQX8v8iJ+L+",
	"pYT/gYt0wjXwgow7+7TZE9s45GmyeynZMg27EqJWoztSSU3LtIfHT1qwkm7HpoQG7UmDYOudXMhzqOVh",
	"lqFglGw6/Dia2t2zscltk+6Cw/Xs34q4Un33JH+6pOVAFso7VimmrcBIKHn/07PXzpc3lIuSD6ZOUeNy",
	"lg0lg2UGbuag8KRJBIaLwXf3/lXSjjkUIoYRYvZzr/ftQguGynFFG+ojDvsA/c0HxJOKcueobhJx+jvr",
	"krP66XJTguqbA+4uwqU8wSCplcRF2vrREGQNn7F8C/FPEfSBH6xlVyyyEO+ZeotkPnO16OICXDuDvLnO",
	"NnylgOikRx2uoRdZ4xJJc8jsEq9iOcIyzA07+95aeAfiBrxGlfIzp86oVxo3cVCab6oSnaxuqF7y9l6J",
	"ZU0s2P2HFh46LuveI6vYrR18hw+oui0su9PTx8Oo/iGey01VsmF+UKF7HB+HQ84JBTmiZ8C8qUXmea0a",
	"G1w3UOoXWnJ8n0ZDUQ4hZQVVOCrDhf0P5GjJ2uD/GVX2P1giqv0/xKqoVocdagbnAmnxfiAfgj2zLLtA",
	"hcH1TdXyuGWe5yTjcZ/XJCjiaPB3i8fDyZRo8m4C2u2thC8r+BLHzRMEBII1tP9Lk4IZpjZWdl3LK7Kp",
	"8zWEitMV85HjEIEChtPORK3RfTBdOwPCOR91RXMcCAOUSqpWTBEXM0RcZewQeLShvPPwVzcsAFRZmuK/",
	"u+LZ+w/egbQURbUnwuY9GBdse4rCAPx+C8IxHBw/ABiEyN8jSHeKtI+TNXbg60VLjsJ6b638lgD+AeUp",
	"C5+7a3vKU/00lKnLg3XAdag1669zurMp3tsEqWjWNlUZ6G/usAxvFlNk+HThJtsdlAjcECimRgBU8q9v",
	"/0UUW7r3Rr/5Bib45pu5a/qv79qfLeJ9801aA3so9QH3yI3h5k1iTLuicPc1ViBoGirTuOdSc7nZSAGG",
	"prLsePlEQSDuScP7qYIwcclKWbFka9zg6NAhv0WxVV1S9G5xIZhqdZoSuKz5SrDCXAuMiDiDP99fi1Tb",
	"mNVD62g7UhVno4dgbleKuVNaEMPG8eXx247YhHg3I/pH728/4kuMQw0jwlBLpu4y5ns3xoQqnyuhMJ8P",
	"A7G5D0sCIQ1PuPNEog9V8tU/fcB18OCyf9e0dB5qAf7g9xB0nF8wgYU9w5vvRhImdK2cQ9jCCuNZUNww",
	"Mmbwumly2xKf2VjZPAXG8mCHd2FoEECPXa3oUdjDkeNFqWx7LlbZSK5NDsk2rqFPpgQL12gFRzu4RUK1",
	"YcXEJPrYHwYJZb7/wPBNtajmNaZ0qlX0RKvol5wgj169eEygnsxQZY/oxc3dy44LVk2DCGMbe7B0U+v2",
	"gWLJ2JATshO3QZZswJ69qyzS8rKpiAStuobjnVBODET7K9VQ4sg1dw7zLzT6rAWke26zP1ScCrx32Zz5",
	"bKVknQ5WWmF6eieMEhQDELowhEav6R+//e70uz/+iRR8xbQ5If+EXCFkvv1iiO3TJLwpstiq5UoAsJB/",
	"ivKQi5OI5ly7A+3Fw3AXLwHDPPwJ36Zaw3wGcklmrlMxXa96MgupXHAJpE5G9KZlrD9EJBcXRlEkvplc",
	"LpPpxP+A3xtTkvI0WbH+qU+gyvig7S2lgr/ha7g389mO+mTlZShNdjvCU7KhSrnldeL6fP9d1tygE/La",
	"9iZMLKWymvamNlYGgAf8va2zJaVCro1pqoZDmo34jSkJhgRBpMhZjwfyaLMhNoTmIM9rF+BkYQh5wyEK",
	"/dEZSDNzBPIx6qn9q0ZqYTiKP3Ybf4l2sbKMxwL9zzUvE1hQSftdx3DMiZAE38OIW2IkX5MzhjC7OO0W",
	"Ij3sNY9rJxRpO5nFhALr0DQlhxorRb6moinwv7tATR8n93m4t037u9f8kIV0RuD8vJV0hBwIahGuXKBV",
	"UCB7K1jUHhbgim43TJhbUr632BvjZaDAtRrXANSABuB77yoXPvT2vx3bfgzZw0HVAtspUttojfMBvSdE",
	"BvinERrZFW+QFRGWNcRcRmGq3nbqVLpgg79gW6K8aSCuzNo8fL+nloVs0fBUdtN7vmGNXoKCXEoE4pNY",
	"IqqXab0WA+6RZP9hZDlhmHGs0ANYgX3HcSKcwh5oexb6tB/D71vSthVrhw+0qqG342VBxz8hL0IcM/ha",
	"MKKvCW5G+1PXI4PZwCE5mytvp6LK25zBaXN+/qHCaIrExXUNUJaxbfpSjWtC8+UqvKmSMNz4ZtdLppp2",
	"KeOJb7lUvzUN+3Yb36z/HE+L8jQupYpuZ14sm81nFmD7jwXI/rtUv83gBZqy70pK3yF3zBlMkIiNm7UV",
	"x5YsFy5Dgy07jJCj5T5dxA84bSLGtq+FMLZrY4GD5ofntCzfXwucKRGA0rzEn3I5YgVdl8sRiKSlpM7r",
	"6A1H7oLGDhKa51bKKppY0QjOP2jSrdOEEaT9Sk0tJr4nkUy8mBTQjarV4LrBZtSXBHlOqFrVG7Tp3//6",
	"dqxgsDopL1waWb/EppOa8KbXihVEKpdAwpcuO2ioRszEunn40tRrueJ5I5014asDmD63+gerXLUGKbI8",
	"OMQtq7JKnpHkHB3J57MT8gqDzRWjBdJMxQ1LVXBrrR8yX68YVKb3GJ2F043qc57YW9SqkKcBsxWDB6US",
	"NRu/1pqAtNL1wIkNUSUUbNqH9BlO6LmdqanFjoeUUyGk+YrOac+agJ0n9aLwj6oKxQFLJvzLjij6wrAD",
	"ZlKpGF+JsWewltQzAt09riQ7aFMpl+QWH7zucYkgEd+OiILzAwfD125okUlRblPUNU5o7JDXsBejb2GF",
	"FEfdhAxpt8qoms60JXoy8zZaISA2aM1vD7u+W5RwvHPdxs4ALaqxq28rLmrkxX7Mr2oPvUsyixyNo5IZ",
	"lnYp7cKRPimWef7pKZYosOpL3YRZnYtn5DempNMXw1D2QjTmaZf677JyTxKdQokm3evWnXLPEli4+BHp",
	"cLC03Pn5h2vakzIApjvIF7erErjzjF8OlCCKz9h7q1zNoTvWFsMZRzZ26KXX8/MPS1oUnWoscegVEplQ",
	"TQR329ViAmShVwNlj0ZPczl6miPjt1I3rrzCN/Ial1cQMUnmyu849kiFow6HVjY16vpTT7n8wX8/CTW8",
	"0ntX5PCzjqDHSOVIugGd7FkoCuyAkwG+E+JIiPN1+9+VN6WUS0/NvHvMO3A7z6HhE/9kQ6uD1qXcSTwi",
	"iIfd/mzQ6d8kRPmHutx4Ua0HGKCJLug+una31x396OkThK/dNBgaF4JpHnpVbAM5XI2KmTgcV0AuiIVN",
	"ZT8MpIC4hzg0XEczxHtNyCs7Mi2v6FZ7U2mDWMPD+V3FijEJM12c5In23fTeqBwcY+9YzisOb9e2qWDA",
	"8WED48DbwWiotEQHs8/4ZTBauNhw2pRkbDu/vO/LFZejEYOeu22mZdtagAN7Y7Bt89yP7VcUjjTiZ7sT",
	"IVIFOsOW7qB5zjs5SuycpXBfGoe9kMjhNMPUTXQfEhpwiwjbyB7aG6ouWjyQ6va7nZgE0Rq1JWJEqQu3",
	"eNrMORPeNm83QSh2MO3/whQ6MN9RUcgNeVkLxIJHv7x7+di95++RzJc9sMjnIPlCXz2r1NKt/Kzz1pmP",
	"REefxoproxJ2yy/3JbRl/yW0xHtgdnWHegPtovhMb6CVvTfQbr/S6a+f+Rsz9PbZF4lAOzQJ7+Acp57O",
	"F7Mv+XTdkH66mW4nHqJ02CQvRAUE7Hn6elcdxn8nIav11jE15MpKHzp+/DQR1NlUDxYhNjPyI+wM+myP",
	"N/DUiZOzYBIoeph4Ile7p5c9b4ke2ceXqrDqcRkJP8taFLqzhc3rGyMe0FHZx4k+vs2oM3VIKJgqCZzF",
	"rtI2JOCKdKkg4Ynn7gM7UIkWa87CM9v4wnO3jFSzlZWSl7xIvXtRyhXPNVpg9vXZvvZ9b+azTV0afstx",
	"3vi+6EROs0O+cqxQFFQVhBXf/fGP3/7YLPcLI1f9TUoG2LhlOSMjNTxvy7FhdROImD/Kk5Xsk6xBX5ta",
	"Na6H4FubQ+3sJn5tPxcZAJJeb7RYH6Kx2BIaobq0YntpePPT3P62pnrdkM6o/jnUpafE0atu3B1k/Xye",
	"B5aiS5HdKTSicz2GCEdzSb6Eu9F5f4znk0nim4iS9MuDuyWi2dXii0+FhL2uSmZlu4YG9u9NrraVkaf+",
	"aJDl+znPeP8ZkXi89K5DA6h3Kq0kggUSrDDZSFxgIGigukV8bm9/zmK4UmUY14ppC1E6nmatzs8/poXN",
	"oaoBVrpMd7rZ82zPOnva3nHct0EJt7pAIB5YZxvHgYcHqb/nNxCyvQRpLJfC0BzkRizAPXvmDGYzV+95",
	"tjam0k9PT6+urk68Ne0kl5vTFaSdZEbW+frUD4QvIcWJ4K6Lq5RoqXC5NTzX5NnbVyAzcVMyiGAv2DVY",
	"7QJmzb47eYL1A5igFZ89nX1/8uTkW9yxNSDBKdbqmD39dDOfnV5+dxqHyqySD1sxqvI1KgKu7QnkwjPU",
	"bl4VodFLqZ754ZzbA5/2ffph6BEfe2Xt3/+umdrOfBX92AzUOOP612N3ljOaKTSGYJpaYd64gtf8UYiL",
	"PM349By7ZIJwFPtKvuHh8QxllVrHtRMwQ9s9AW5KatEVi+A9IT9rFtWtlBeQBILipg8p92UXQ6cBwOwQ",
	"KbgalO+n+OKuOVEXIvyo8Jb3FaQ9gdNERKGjJ62acM5U6x7RcCU78i2pRWnlC+9+AK+hDkuDcoFYzSKn",
	"bgdcvpWPW9XDJ+AnyRyEmYVwzxNxldVBNwJm4iJtwcrlVCeH4/NQfiSOG5g3j5I5Q/2chIIeHQvz3Pn9",
	"/ZvD/ad8MapgaMEuCDijZZlaZuRr6i7zp2u3zAb7cbW6ztcQodIFtPfIMLy/4coFNA/s4N7MXf8oasAn",
	"y4VogdBStDZwQh+7Hey6KmXBZk+XtNQsvT0MF9namiAg+EBM3DsXGNFJE9QYg6mzKDpg1kpxtC2EFOmC",
	"H13ZQZstkG7Lz2b73rrSPYX0hV45O8Wd7puPwoxc7O79I1gv1F21l/CCbYeAaZKVh6ndztjK8c9D4Hs+",
	"4yMbmtdssHwlFLWumIIhRQ7OFQ3UwlsuEed9cE3BNV2U8MADmiVakRmDBCHU3N3jBOLSM8MMuRuTMjLD",
	"R3iUBYqAwU377skTLzs5U2M02umvGoXiZsDhWN59knNSF9BXNBxNfA7FqNEHhud6hTLDpqrNcJzAtcmA",
	"U/dH/lk7IlnRFRcuugYMeBt6AXY6gWlaLrjN306f527Zf/DMOIHBYcwEO1ojk7U34GNS1m1D/giCXB7b",
	"Bf5wp3McrP42XIWtsw7fcArY7xwCYoAuVo+7mc/++LUvwSI1XVmJeqZB5p59vOlI8qeffHQpL24GxfrX",
	"Ul7UVbAPxy+Z9KR7bOvu1V+2QCRGpftgdfY0F0iKVUIiihKAnMV7ZFTN9pJVp1LgA1LMo4x4lBEfRka8",
	"F1a6BwO9R4aZZlJHHjX74ckPRzb75bDZEpjfDjZ72qMAu/iuiGLeunRUVkhuy63zv4c0ESxbMsKdn1UV",
	"ZMZDcIv+kvj0wdWM3ytbPho5b2XkPDAr7dz3PdTTZpbmph6V1Sj5pbOxR4ngKBF8jRJBSLX7LHKAV02+",
	"HP5/Lx6/I88/8vwH4/nhRk9j9PFjDEf+7vl7MKIcmfqRqX9tTD1R3HY/Fu+tlWlj5p1Y/nMc+lkM2lH/",
	"P8oCR1ngfvT/FgHYV/U/CgSJahdHseAoFnzdYsH+On8QCDq+0IOIAkcjwJHxHxn/ZzcCHJn9Ufs/svmv",
	"n83HeaFTA+u6uf8jXPt9PPwOpn3kBYfJdIke/LGzLPm1o7i+yE0uO49FCnhKnLNycHsElJWAwfYORMcE",
	"4aE49PD1U3JiX7s5nvQA9aZT28ZX77eV3YcSgvB+tbvlMbBuyh6EGExfUTzk+0G1b81XJAvZ5/aXDf4E",
	"GY1nfGV/KvEnyKXGTNLU2jVfDS9eQ7cN/mPHm7RId5OjhbTTyBdbJ4mnzyItxn6Rgax+SmqI1TSWmN0V",
	"T73hIhudPjQ4CAgLtpQunSWCgV7vgME32DcD4l61Er+yaE0rbimv4Rt2Qt44QkMFeffyOfn+++9/JHjh",
	"rZaC6DK0YBwSX0uIgQsEo6AmfJ5Cft69fA4AnIX41Emtdh5qwKhDrRxG/PIW/jtOnPxdZq99zkQHXLUz",
	"JzgNEZ+PGRdPwiMzo9aHw2rNvxNtdz7rqgh3fy+uo/W0d7Iz4TGh6z9KCZ3iZI7LM7Q9KUMVGvbwD9+/",
	"z/YlKBCoP7Sq74dLhxJDqMHaFA9LEnRsdjvB+2g+PpoMjn7j36Pf+D86LTjap9NPbWK9Oz04eoJryHjZ",
	"NEmnBqdE4i7L2CkW/+68f/dGdvYkNg+XAXpHl9DRn/KViLI9InTqX8qdSImIbT+BHL2WK/15SNJR1DqM",
	"d+YzW+B/p+ZwqH0c7Eq95/GwHJMraD2ujrm3cZu3be6nKtO98crhpygrXlx3HnolXBTseqC2932K6KVc",
	"ZZ7875+CunpB0++Xfw2SP5LqO0gOYzxrPJgvNrxAy7GqmJMC8Y52iCNz3INbtUxn7qnGhzOa7Z7djj64",
	"Wtpx3B1gvlpwMzSf/TZ7+EjVY+jhMfTwqGc+pLELDvn0k7+euw1c7onA3dXvbMPp2mT8jNnRtHWvpi0g",
	"c1Np4QMWNIMpj+TmaJn7si1zXYp5uqAlFTnbaZFD0Vvja62+evPVWgJBcbUYgcCMUlQ/2VE3OupGxwcM",
	"jnF4U+PwDiZ0HVYaiYnnJC3tDRf8WCkmxfUWDWs4qmy/JwFknzSrlnsiftd+VI87ZlodM62OmVbHTKtj",
	"ptUDu5aPOVHHnKijLvafnRM1JXzEPzPMRfzIdkzyge8Pih/3HVHSW9RzuVlwwRptxq+gebnLSHtQ0Ahe",
	"YXd82Dc0kugQMrBjXZmS5QB/hYia+E30+WypGPuNZYYqKylP4bet1XgA4Y2VaP74kZW91malYbSeEZ+L",
	"hrgs7D6X5ZaYUPSI0PA0/NwKyFtZkyu4LCW/gP7ugRa76RtikbjzYJqRxOr4Qzvqumf4uv6urLf5Q3hz",
	"jgl8xwS+YwLf78C0sShlfqFPP8FRZ2hA2OmRhk5D1ou/2I+7LBZ4GXG6dEpyDNDDWkvHbhEu7hjn/xVj",
	"/CTTXRQ5OV4dKcRPHu11R3vd0V53tNcd7XXHykhHK+DRCni0Ah6tgEcr4NEKeH9WwM9pubv/p1OOtsGj",
	"bfBoKfmsmSrx0Z5+sjrR7lwVYtXHssUhhwyFMdZNSVhxStn08oRfEQmJtmuvyzr9ch7TOo7k5UsxxN7M",
	"Z5qpS3/Xa1XOns7WxlT66ekpu6abqmQnudycQt0E1/9TkPvlZgOMKvziRo5+caTs5uPN/wQAAP//N7du",
	"Y+VJAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
