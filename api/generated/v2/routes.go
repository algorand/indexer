// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jn7xLHTz6eb/BgAA//+mBRqHoOUAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
