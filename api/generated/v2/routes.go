// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//EE3YrWRkAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
