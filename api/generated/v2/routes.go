// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
