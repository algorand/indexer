// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9eZPbNrYo/lVQ+t0q2/mJ3Y6z1J2uSt3yMn5xxc643E7m3nHnvYFISMI0BTAA2C0l",
	"z9/9Fc4BQJAEJar3TPSX3SKWA+DgbDjL75NcriopmDB6cvL7pKKKrphhCv6iM82Esf8rmM4VrwyXYnIy",
	"eZ7nshZGkxVV56wgVBNsSrggZsnIrJT5OVkyWjD1SJOKKsNzXlHbn9RVQQ3TR+TjksM3nJHQPGeV0YSS",
	"XK5WlGhmvxlWkJJrQ+Sc0KJQTGumjybTCVtXpSzY5GROS82mE24h+7VmajOZTgRdscmJX8B0ovMlW1G7",
	"Em7YChZnNpVtoo3iYjGZTtYZLRdSUVFkc6lW1NiF4oSTz1PfnCpFN/ZvbTal/cG2tX9T3JOMF/39ct9I",
	"mAtgrahZRqA2/acTxX6tuWLF5MSomsXgt6H+bCd2MPZm/ZsoN4SLvKwLRoyiQtPcftLkkpslMXb3XWd7",
	"blIwu8f2+KLGZM5ZWcCGJzfYTT4M4s6N3fHZzZApabe7u8aXcjXjgvkVsbCgBq2MJAWbQ6MlNcRCF+GS",
	"/awZVfmSzKXasUwEIl4rE/VqcvJpopkomIKTyxm/gP/OFWO/scxQtWBm8ss0dXZzw1Rm+CqxtDfu5BTT",
	"dWmvxRxWs2RkwS+YILbXEXlXa0NmjFBBPrx+Sb766qu/ENxGe3FwqsFVNbPHawqnYK+p/zzmUD+8fgnz",
	"n7oFjm1Fq6rkORCH5PV53nwnb14NLaY9SAIhuTBswRRuvNYsfVef2y9bpvEdd01Qm2Vm0Wb4YKmnorkU",
	"c76oFSssNtaa4d3UFRMFFwtyzjaDRximub0bOGNzqdhILMXGN4qm8fz3iqczuc4Qph7SkJlcE/vNUtKF",
	"pGVG1QJWSB4xkUt7jicXtKzZoyPyWirChdFTd9bMNeTCnHz57KuvXRNFL8lsY1iv3ezbr0+ef/eda1Yp",
	"LgydlcxtY6+5NupkycpSug6Bi3Yb2g8n//0//zg6Ono0dBjwz34MKq+VYiLfZAvFKFCcJRX9PfzgMEgv",
	"ZV0WZEkvAF3oClin60tsX7wesJtH5B3PlXxeLqQm1CFewea0Lg3xE5NalJbU29Hc9SVW8lDyghesmNoz",
	"u1zyfEly6jYE2pFLXpYWa2vNiqENSa9uB3UInSxcV9oPWNDD3YxmXTt2gq2BfvSX/9e1o5JFwe1PtCQg",
	"uhFd50uQOAGqpSwLRPqIAZBS5rQkBTWUaCMtYZ1L5SQepLpT178ReEkOB1iQ2abbUhSt0Xf3GSuf+tUn",
	"BVQvW9CynDiOZQUtN2UWfqBVpTNYcaYNNSxuU1W2hZCCJQSQ3UKtgy/LS6lZZuQOAczLVLBhkcgU79he",
	"4hj5uGQEJrcfUBQFzBaWSpflhhh3ABYhiBe+poTPyUbW5BKuTsnPob9bjcXpFbGHb9oKiJHEUrMh5O5t",
	"RgK1Z1KWjAqH2hWSyBHqk2v70PQnv4S7UKBwtZkU5aa/Zd/DR2I/knlJF0fk70vmaJ8Vlexh4ulNiWKm",
	"VsJeStjFQjJNhDRWzDLUbXCsDg0cdwzPjpN2SlZmb+qwuFd6CobNrWQHqFQESXBKClYyQOeG3MCv2ii5",
	"AVSxl35KZGWvt6xNnwyKwg2Ln7tUEUjEoD4Xr2THoku+4gnbwDu65qt6RUS9mtkTmwfR0Eh3NHCtFSM5",
	"3M5Zi8ZXdME0YVZy5KiMwjz2kO0ZKkbz5TD/QZh2sJwVXWdK1qIYoXMZIlUs0+qK5XzOWUHCKEOwNNPs",
	"goeL/eBpNMEIHD/IIDhhlh3gCLZOHKslxPYLHFB0qkfkJyclwFcjz5kIwgSyRUYqxS64rHXoNCRc2qm3",
	"C5NCGpZVis35ug/kqdsOSwOxjRNlVk79cCSgIbR2OOQrgzBFE+6rY82oZt9+PaRgNF+lKLlgA6RvF6FD",
	"ohiUycul5ZZtjmHvfA39UUAz5YbgnEOrjiHaQQcqJSupncVwJ6PzrR8ap2tWcRe8TrFztknKU90bj/gb",
	"rHhL+wX7bkfbMMOO0xtJeFB8jgnOVmIzitBAowz5REL9sV8dF0lbTFv9R6ik8dxor8uuZTvFMTyqDW1F",
	"Z6bbM9NovshwxB5Z5IuPVsye8xJE8H9ZauhPttZWEGmfrRfKNV8IamrFTs7EF/YvkpFTQ0VBVWF/WeFP",
	"7+rS8FO+sD+V+NNbueD5KV8MbYqHNWlLhW4r/MeOl7admnVYbmoK/zk1Q0Vtw3O2UczOQfM5/LOeAyLR",
	"ufoN1SqQgUw1n0wny9kQFCkj4lspz+sq3tW8ZVSfbcibV0MYA0Nu44JAQHQlhWaAuo7MfnC/2Z8so3NP",
	"N5EEePwvLcHS0Ixt6R5ThuNIjovY//6HYvPJyeT/O24eiI6xmz52E06CJcMMCTB4i6lxdAzpl6NsKAKu",
	"qtqgQJciEeFOfwqwdedsjkXO/sVygxvUBuMxW1Vm88QC7HnSze2WbnGKkfvW5RC3uI8o0mUgmvVH/kk7",
	"60hFF1zAwqfk0socK3puSQMV0iyZIvYsmDZeuEMaiPJeeH1xEqLj00eT1I1JnKm+9qE2p/bWKjmnoOTc",
	"xBF3bCt7nHUKpMPJh5PvbexNosDihs5+67PU2dknWlW8WJ+d/dLSs7ko2Dp9Hrd62KVcZAU19Go4unhl",
	"uyYQ9CHjUPvJ76YQ6GaRZ49TuFuOelPbdcOX7Uo09kBZE7fi+kRVa2Ze0JKK/EbY6cwNNfqE33HBAYjv",
	"0cB5OGZ/zGErb+KI3e7eyEXGZ6nRV/hwuKk7HB77rn20N3Wkow7yjjVCmPImNum+EP+A8TeL8S9KmZ/j",
	"W+GNsCs73PgjhdkPRxo4FO7eTRzplc5yxFFtn1mub35euU7N+kKuCRdo1XXC7Au5Zg9Vi51Z2MZfC7l+",
	"5aaU6o+tYOLCx2DwC+cPqOE1SsQ7a5f8V6WkuoHT9ep+B57pZMW0pguWfkSN1+gbjlmUBxgOhNklwMvD",
	"94yWZvlyyW7hokZj77iuHxv7+g1s7K2S7OgpYNf6o1Xt0N/bw+5JZaNp9EPfvYdDLlpbPp4gts60Sw7H",
	"n7He75A/+yel+M1o8M0+Zkf2pKhz58Zn3zNxJl6xORfgtnNyJiwdOp5RzXN9XGumnM3gaCHJCXFDvqKG",
	"nonJtMught5gwfXUQVPVs5Ln5JxtUqeAPrGJEaShZeSJFLnHOveD5lGpj2c4ambRQdYmc974mWKXVBUJ",
	"eHXwPoGR0U9326xT4sZGJxnn7e/GT+N+z9ezH2u01Q2Wi7afqj3IH6VxngX0kiAikVozTf65otUnLswv",
	"JDurnz79ipHnVdU8Zvyzcaq1gMJz5o2+jMBi4QwztjaKZuAclkYUXa+A05YlgbZth10lF4qunHNZ1xV4",
	"y07j5OM4VbQsWNEp9vo8jTTDzlHB72TJyr4D8b4HE5lRrnwuO0wxW0JaPkaRV3RBudCetmu+EBarnRf7",
	"jJHc8nJWHJE3cwK0adoK3HIhaI7uBQLANTqeoysQuL6QnApwSAcvIcBtKjbdd3bNjPEeDh/YOdt8jDxn",
	"9vTAcH6VdAdjK2o7XGBuzamSS6rJSoL3RY5uWDhkAgXTwNRcGPQZa7l49wCJHK7trYhMwkMu65FXKq0q",
	"sijlzNGOgIsnARl9n2Ey8d4CoG+ARCT16bYL/K7V4zUbctXff3V2vGtdsq1rujJyzbnS4PDLqCP1NL4M",
	"V8Ax542c9EkEKUoq8Mpt41HsZdhD7+B7Bl7TTBh+wTJW8gWfpeI7c9rimN7D37kNhhE04XPCjSbOKm6B",
	"4IIoKhbMSi/o3UdLjEZLQlNSbbIlo8rMGB1wgIWDaQJkWsu2/cmlJVnoOzm1m8PWFo+53QnFBLtkhV0N",
	"V66Nc8wceM21ADm3xOKK8Pjujatleq4VF5nbuoRHt5dfwu56AdX798ZXCeDC7ysGgVvy0p6LhUK6mKNe",
	"RE1tVdA0aC2P0JEONu9bfewgu2S3pLQm512hrCc/JUHGxpldc3+mWjtHWKqMZ3Z+dNR7AOojAi6IbpNm",
	"JQSwRE6+9rypajn6YgTlEDh6SDz2k7fXHl+6JdX+4kF8mOcToyTWAWLWoK+loxH+xnoHt/OW7IIO7fSw",
	"zyMEeXTdGEGE6Md3ee9wjID3vo7ewdF7Ndp/Lb2ry9JSm1qcC3lp1Zl9/BanE7zyfYAvJIgpzlXbIYYD",
	"8ZGOjsbC8bf5HOhHRrgo7CUCpYMaH64nc45RUQ1NtrR8YX88sgNY7LIDjB4hhbZuSJCwpSxxYPKjjO+f",
	"WOwDpGAc+Ar1YwODif5maS0cxHSQ2DEwhos0xuX+lls9oSUVAWAQYzljTGB8DeFiSiwpu6ClJWVGomga",
	"BkmrWo9bWpIT3PWTIRUsbSHCFYHksteaUNa5ympi8d8DndZNtkA8k+sMYpb7sELocVVlgYhJUW4wwq+r",
	"p8MIdj0yBwzx3ufnbIPBhRDuCrcELLKOfsxYKa2kL3sY1hzUDuCvC/gNQrNdwE9hswbUQ8m7QbstIao7",
	"px6Qr4fQ7jHg0DUA6Nrfg9O8s/DsNMq0RZk+42+44bQJUkCKnCYjQ1exj/BtLEqe4sD+9s14wU35fVf6",
	"SRrrWq0INpk5O1SkC6W4nyVHuRSaCV1DdI6RuSyPelY6zUoGakTWEsiyc5YIWTr1jSO7HXnM51Y/fxJp",
	"B4otuDasFZ8d4kqaOKkNxDRX1Bim7PD/+/F/nXx6nv2DZr89zf7y/x//8vvXn5980fvx2efvvvu/7Z++",
	"+vzdk//6j8kAW2ZW3Jbz9Jo+SBkYHzQm0Li1tDuH+kIaloHel13QMvW89xqUwqSk1Y61wiQCfMDmDhOd",
	"s01W8LJO4+KPgQrqegaUmgvCqKWE1ORLkKZbM9o2W2YD/WdgVW/pjS1qBDore/Ttgf8geN2hp9sucQKZ",
	"UsfeP5zBfdxC1kAyesVKfLwczvaDF62wDY+2PRz0Lkbhx96mLUZQDHMeHCm5lraL7/Aq4CUd5BZuojBG",
	"3VvRWBvQZQgJjUXQSxqMXLdu64lXF9t73ChpE4v7eI3l9Ycfu7xkWrZx3g5wYPuYLFEA6uEU3BU32A58",
	"it5F+szVqhHaKRx4QSLhEvNwiK6Q2cGzkB9g3Fl4WcGlK5B14ITbZdmbwzmWULZw7Sn0I3MlV3DZ+rJm",
	"bIAcsEu0sK5hLZ1ZXbq4Pr5YegkKys53YEbLH9jmZ9sWThViwZ2EOfaWNGYar+V5jeNaR3O9N68U5rsR",
	"d2I+xqEMoT0kFsO3idYL9Z43oJQLnQrbXDShzjEWzJhVitma5bVpzJ4d43qw/9+tDNh9SEhHpEY+B5jc",
	"brukAPvjxtpxYu8DebzNA6NVpeQFLTP3lpuk5tDCv/besayVvlAf//r87XsHMTwgMqqyoGukFwKNGh3j",
	"wa7Fihpyx2MwGKK8AaDL0t1jLtetB+BLyA3TUV2t8OSwCDemecSPrql7EJ57UXvP513nZIBL3OZs0Bh8",
	"0Neg7V9ALygvvcnew5hmFbikxpVjb24RD3BtP4XIr+TaY10wpZOCcXv/XIYP0udZflP1CDNRlzakL9oO",
	"OhYvYEtmmRXmN9JEugwyDS5YXRfeHADrV3RjkRGtvn2CJuoVGI4yXfLUq1vbGkqg1YC6bIeynHvbIPa7",
	"HmFy64AVDZ7cPh8ZMrRbM+l86WrBf60Z4QUTxn5ScKU7t9xeap+X8MrKUeKBHPMX3qF6BBPuoxi5/F7X",
	"WlwY5SrqkVV/Eo+VeGpuPeHsrqMmNRbivpgIQGzXkWIfpR64r4Ll02NReMCgovVKvYfzYjxjTyoZcDyM",
	"7p3g7hnlCqeyO0ux18Nc/rc0fdhLzYrTyV1LudLZXMnfUk66l/1powmxV3rQ0cpR554MKEm8k0X0CkcU",
	"EvFdF6SgVF8bqC53DE8nTerq5nAGL9mQWB8/8bQ9XgcIOdw3iDKh6uzsF9Rb/TMyFXjBXkIK7JZGlb6m",
	"sf/zMY7fXFMHc9/cQS9nND9PLKZxOmw9dBtJfKeQWrF9Okck8l8MbV2WwoqpFTdtct8obFcVnHHa0SJz",
	"IyEDNsWysUtpW2qZGKYWl1QYn2vSETDXO67xcCmVNpAkOLnKguV8RcuB18OGQBZ8wTE5ZK1ZlNrQ9SeV",
	"5MIg0hRcVyXdoDdnsyNv5uTpNCJe7hAKfsE1n5UMWnyJLWZUgyzSGLB8F7sqJsxSQ/NnI5ova1EoVpil",
	"y7qpJQk6Ddh/gmPJjJlLxgR5Cu2+/At5DE40ml+wJ3bznEw5OfnyL/CAiX88TdNySOc8SFs9SU9jLbgM",
	"YVfLFN1gaVqL5Qv2ujPYZcyNgZaO4O++MSsq6CKVJG4LLNincRvo7IMoMBMxiEyEm/S8zFBLdbIl1ctU",
	"1vdcrlbcrJw7hZYriy1NHjWcy4+CLgNIrgM4/iM4OFckbbu7W4NSOsX9j3TF2ps4JVQTXVtQG5uYI25H",
	"xGUQLDA9ZWOshC3BTPno8IYm5XmUx7428+w/Sb6kiuaWlB0NQZnNvv26D+kLyKtJIO0+K3Cu8YDf+XYr",
	"ppm6GHfRvJjk+pDHQopsZclD8cRR6vadG/SWSpPlrj/L9iHHykh2lGw7VtGIyl4Lv8SWAa+JcWEZe6Hd",
	"3iu7cwSsVQIbfvrw1skDK6lY23Q78yFLLclCMaM4u4DIjvTZ2DGveQSqHLX514H+fp/ovXAYCVD+xqZE",
	"dYxj72+Hc48Pyx5SeqU8P2es4mJxjO7hIEzjqF0xeiZFPWAQraSVnTgtCTQiFd3YXQ4i6BbX8zljOstl",
	"WbI8qaN2grtsc1JRjtcmTszq/Sq3zLVggmmuB9j52dmnxdJqKPaz5cSRlQXjDdClT9/9FfWADwTwL5iw",
	"cL95tQvq3sBtrw1njd1lw2m5m/3k+kAmaEzzncG8w7ts21l43/u04C4JNNXLu99an/h5ALF9umpPv7vY",
	"NfZtwQ+U4dUYinY1NS196Chg95wpVxeqBQ7YYKByD2NEc3G+0/V/ZzaMD67tsM/+2dknJQp7ci9ddB66",
	"YLWfyfEwLyk8ezBRNNDnS8oHXF41Y+kJ7Qc746lUhqNPEGP37B9oFM3PkwbIj/aLDj6C6MgfeQvq0XFi",
	"8Brx3vb56GdLvfXyFdOGrqrk3hltdw55AfAVu32hiyWYmuVSFNpiUM4Iq6Re7kpYoNNTrQVM5vOvtyhz",
	"LhXmKwbZ1chOMPnYLdkaNt+GMVNSmiFALZytfAdSGkJrs7QszIcpMEi1310JBteB3hqlrz8i76yU4TM9",
	"07LcTAk3j3Ac5RxHKVkxdV4yYhRjLk1/yegFa2o1wWiPNPm45oWGSkwlW/NcLhStljwnUhVMYREv2xx0",
	"aezk5nt6RFzQsAuz+LgWsLxQBCVeJy7TB8eEF614xVMU4bo/QwkdzcoLSM5/KREI3aRO0Fb6bfWY1QZD",
	"Egs+nzOgHrAcUMWhX/MhggmqTkEkQxjWrenuaUAPwzK9pM+++XYI0Z59820K106/f/7sm2+tJEwFofWa",
	"l5yqTdzMtpqSWc1L4/KzU3LBciNVbHHgQhtGix5uoTXKzQKyzLwWufNyC13i2mCn3z//5stn/+fZN986",
	"81U0iw+ydvF7TFxwJYX95A2GAUPclGE2tuba3IO0ZNYiA305xdXt0eRwLGvxEhsRF9fRfs7tkLAV2qf8",
	"xS9ZsWBq2jBiS1eblCZWuZMqkoDnDCPQLF/kwihZ1DnDRBqnLboRgcV7IIUyK5E3D9x1X5ytgdNbUoPM",
	"Qsgb0ICfokImZHuFcMfYBVMYMtQM9BiZQwSXNlSBGxR4RbmlsuJJmrXX1ULRgo1zcgBm9RP2CHkh/AgX",
	"cr8BfrbtuwpWSwdoSdZpATaKE2FQCavhuSmes4VKDOpvH4YCNF9jwTPFSoykgwpK0Hba087mjGVWEExi",
	"vNWaIL+XK5zSKvDLmOU1eNPhLkPhUS+0hRhrjPFLW7AApiynZV6XqEpsESEvc1rCS1CD2CWbG2lxLy5g",
	"2DwFcDvXDBzQsfQQzqcsD4t6QFaqC6Y2rgVaXnylH3tvVMczqC8qZyW7YGUScEYVyA7fy0uyomITzsJO",
	"0YAxjQLvAuQoBIOHCJ72T84oFIGP98wh5HYg7VEMbG4Rn3PFFJcFzwkX/2LuoseqA2AMlgyTwnBRQ009",
	"xRq4kdUTiADuRvn2MUAlPZYtXNQwC1gTJCLYZeu0i0hR6FUvOmcIto9VdtLN2DNVTPOiTkM2VzRvQ7Yf",
	"MrrL+4EadqzC0eobwssO8QqXfNul6+JyB206p9XfpUE61aLLY4gVDQFlxNHwhC+6S3DlWw5YDKSRwLSj",
	"1DBhbOdrln4mYOsdY9sWrfEx7ZfPnLD/LJn3R9OD822QHDc45+VnjOuH/i5rQ2oHB3KiBQD0JTf5Mku5",
	"3zkAsIWF4UNXhe9PidIF3EI2n7PcjIEBgoKwct4gFPjZQvGK0QIC0pugLgzn6oLy+EdJ7NA6EnmE5qBI",
	"NBIPjPJkjxT4AUN2If/PciTuu3h+8IQYcQ28jOPOPrllro1DnjchqJ6SDdOwK8F5PbojkPgk/cTrJy1Y",
	"STfbpoQG7UmDzOsft5HnQH4Qy1DQWX4wxtlP7e7Ztsltk+6Cw/Xs34q4OFPvJGXCyc2n6gwRWi7pYcJn",
	"M/mGZZGZrgCNfRXwKZm1HiTu/lHxZrJupMMmfWxLbxvgi98H+KO7Eff8uuKrlzs+iSv5JY0oUc7aJMoU",
	"4XsUcY1hDLB+n9uPuuLcI7Gp85LlMeoB7Ftqn/56QcuBOM4PrFJMg52Ako9/ff7WOcUMRXPm6UDKs7NP",
	"1Ficgn5kMJfV5+lkIPHE2dmnGVBMTCsRTqP/upj0obaEiNvu9nOv99Vc8oZytEYb6l39+wD94OPLSEW5",
	"c/RqQln7O+timvvB42Ni1JoD7i7CBQ0PXqHvqV6+prmRatNPEGtV64HMPWdnn+x577PFX36bJvcWhPQk",
	"H6P0QG0TWfD/A987Lw/JeS9NEIE8QUvqLGf+T6vpRzmBwvfJdNKzAzRn8f0MbP0oRyT3ZDmr1BzUT2wK",
	"9sNWaiMrbnzvE5i5pydXUvWcYZZFxWYbopfyEkzYYA5q6sB2TmiWVWljAjDj900AvHdB9lMTl1L67g1/",
	"APOXmi/ScH8JVOA0bJmck78J9pGvWPjtFFIX/G0+18y8efX4/Q9T8oKafDkl+NsTUkPRT+dWRt7/8Oye",
	"lvksvcZndok/sA1QBcEuMyg9S8ylRG2QsGrJVkzRssGd+1rB4EE9G3tQcDZwTs/cQcUHtKLaagSQpKHb",
	"/2emIJThyb0sfmjl/XU/iJuVpK1RYvaEZ+QSPmOyV+KrlfapzGD++mKWhTi6VOni6cTlnx+u0px4I+Q6",
	"W/GFAiUtPepw3vxIqE7IxEPhbv6lfNh60GGrrYV3IG7Ai2RYN3OKBb8RBVsz1bwlv2tWl6h0kmEZbp01",
	"zz9paQrZ893eGkxMYqfQhhVb7MvzPYUH9FEsrWI5avzyauOLDBR7kV0yvlimN/b9lYa2iv/uQ7u4+0NL",
	"kY138E753F5IwMgB0XDeCI5bq0NEMiZ4M5kBjyOzxOU/lBh9xVhWsGoAXFPsiQj/ObDZ3ep5CUKt+aoq",
	"0V3dkZJeMsC9Mu80IXG3H2F502Fqtx5wxq7sQ33zcWZXhWV3jr7t0WV/Ey/lqirZsLpfUYEK/5wLZ2m8",
	"XFJDaFGACxgtiX+1lnleq8btpBs/9jMtOZaz15DWVUhZQR7XynBh/wMZbWRt8P+MKvsfdINs/w+xKtLs",
	"7FATOBfIBugH8rHnk+kEO088Zif1vqQrZW9T2vn9/HlC2Ai8/gvGCgihatLrH9PcoMeGcy8XzFxKdZ4w",
	"vMw0WMBbnqBxafM+NaXK1BVFowoNPl8up3VIkxlAc5DpWqM/YMvjayetZOvK4tr+ABZqdTESwrB5Ulww",
	"5V5rpUuyi++ymLe7l8GOOPD2WVOKVF8xI9oox7m+TSmxzY2QuMUIoUH3V7FlL/Ju7DuZ52pTGXkMbaDJ",
	"sTaqzo1GP/Nmzh5W2o1Gd8vdNWK7IoWVBKTm6IFhZKbYBaNDD4ugcbFfa2YPGZwLbGMSBkgd7Fii3d1j",
	"HDu9tQBI7LyHYZ7oElxufPZgavd8RatPOMsvJCMfEOJQWwZ8iFd6Ue3va4pDpUDXtDTZoJbj5EtySksT",
	"ixGghaNnWsvakM7kjRJscvT8PlQOC9PVUdAumBXbxP3LK4j7g7QD5g2MAiWw9pW6cCaP8ejgjSR2kjtd",
	"x4dwY/tUIVrfuFXEmxKRhrRR2H/116kxsFJRkGh+TeBuJLyb4eoyYdTmKnnX+CLTpdxjead8cWo77NhS",
	"36y3p6W8ZCqz82454tI7R2CEILZs5dYPxa1wPPTtYgWxi9FX2wgceK+dcF1270UzdseNjpa5FFlr9rul",
	"OkgvM8CuLORl2bF7dNXevcrr1vtSLSASGy4W6VS4ltCfs83DsCUkYiR65wlOKcPGHFA0fgwuWNGz+KVz",
	"e0G3hrags6OsjlXXQNJ09cO23CvTvleNR+SK50pScB9rcvCzngTrlD3wvg67sc0lLv0chpUKsPPHTcVC",
	"GEG/9tiKVl7fAj3cCsFHt2m0Ih9CAEXfBz6XwlAOFcaSwj2GD7CyAkLVvOYdPSj0/TnizB3vuO37k68A",
	"gaKn9jjixP6/v2VGsXt48Tlnm6zkc2b4gAtNOfcvV77Z0Y3JFENZ3VouCmB5KDGKqUmER6TCLwv4Eufb",
	"I0hHIa2D9n9pUjDD1Mqi4lJeklWdL0F2pwvmU8LBEzPEwnQmao3uc+i08yW6iGZd0RwHwkQlJVULpojL",
	"HRIKNfkn6xXlcE+a+IVuRgFwbaUp94FdiereYfKSiHaBs0eUtS6RD8+Dcc42x+jLAL9fgZAMJ78bAAwy",
	"4d0iSNdKqBcnedyBr+ctNxCsfthKoBjAv0F3EAufMyHs6Q7ST185dnmwDrgOtWb9dY6PH4z3NqHiNmsb",
	"68vU39wBF6RdnkcDNaycgwrQcehLAD7yzy//SRSbMwV2qy++gOG/+GLqPKz++az92WLbF1+k3TCTN+fm",
	"PJ1CaRQ7hpsuiR3titidN1Rk8hoTAKCrrWVoUoCTeVl2gjRFQSA9CognFGLWWCkrlmwN1RtjDgopKxVb",
	"1CXF4EQuBFOtTmNyk6H6b9bCmbrgz49rkWobi5PQOtqOVMXkqCz91UqJd+prYma4HHKwXXXEJotbMyLm",
	"g7rOiK8xCVUY0cfEX2fMj26MHTVtz84+6YUAs5w3xnGf1wQEYDzhNjaFXCe+7q3PrRYCcNmvNS1dgLGA",
	"cN6PkGgsP2cCS9paKufKkRMmdK2cSdDCCuNZUNwwMmbmumly1eK2wxUSz84+qRytvy4Gx6WvgVx52NWK",
	"GYU9HLm9ypRtb1XMofSZVrKldi7X0GdEAO/2XaoXoLFaDb/hd9Lnx7FwkCPW9x8YvinoFC7hQPbUJg1u",
	"hzNjQZDHb149IVA8ZqiMR6Ro7V52XFNqHESYE6kHSzdb7j5QzBkbCkDshEKTORswBW+tZ2THAq0QCxtB",
	"q27QyE4oR+aB+Z5qKFvkmje5Px5i8pcWkOTNq6Sc0UoXvneNnOlkoWSdzjWxUPA01PVet0oACFiowKM7",
	"7PGzb74lBV8wbY7I3yEdKDLffqHI9mkS3hSgbNU2JgBYSCmNYpALn47mXLoD7aUz4C6MGoa5B49A7+B3",
	"RbYWvH4Hq5rsqP4wnYCQk5l1Kr/Hm54ARCoXwA6plSPi1Yr6uYmsHlwYRZGSZxJccPvwoWtu42OhPIFX",
	"rI9CI0j8OdsodlVB6AfoHAo4D5OxEsgYVDK7GhUrGR0InCrXibv41bOsuY5H5K3tTZiYS2VV9FUNz4Zs",
	"DXlJ3etdLPJC9k7TFN+HxJ3iN6YkWCAEke6VvHthw2ZDkDnNQTnQLomChSHkFQ9WzsenIBpNEcgnqOD2",
	"7y2pheEoS9lt/DnaxcpyMQv035e8TGBBJe13HcMxJUISCZ5GcUvM6tIknUWYXVaMFiLdLc2IizUUab8B",
	"iwkQDv42qlzUmDfyJRULNr7gTR8nx1W875V8S1zzdD0eu4AFLmBxI3Der9efkAPR8fYDyDSKYYLYYIq7",
	"41xodLNi4qpc6D32RkcHqBautqsTakCd8L13VVk/Z5vMyPTYDF+pUMwPehsYXZHaRmucDihRIcQYPbli",
	"QRhvkJU35jW8DkfvoN7o6vTD4Jx2zjaN60xciRV1sCuobMgW0yb1j3zFGiUHpcKUPMVHsUTUVdNKMqaE",
	"Q5L9aMtywjDbsUIPYAX23Y4Tox+NI7SNXo17ad6ucAsinyZIRbQlym1TsXZcM3g5BqtfK8cPGCCOyKuQ",
	"IwucGjHVSJM4C41jXddHTAgVksRz5Y1oVHnjN3hHgucc3JoEIXANUDaybfpSkmtC8zk0GLIq+WbrOVNN",
	"u5Rlx7ecq9+ahn2jkm9WVeCmMGAec620qeClaeCkXavlDBKBJuXyxge0opuJFxcn04lduP3HLsz+O1e/",
	"2X+qqoQq09V8Mp0sZ30/0PQ9d6iTwWSJRCCTtqbckjfDhW0wcIfVdWsxU5feYI6F0APz3dckGhvtsWhD",
	"88NLWpYf18L5HvaDg7d4e9IKA4TfOi/PQMgttXcuw95S5ohI/PpD89xKgkWTGCeC85Em3epSmC6nX19q",
	"iwfoTkLelRRiFKZqMbhuMJL1pVWeE6oWNSZpu4P17VjBgAJEK164tLX9aqJOskPqUStWEKlcwkM+d9ks",
	"h+rd7K4ViLtXOdGS540E2eTqGcD0qdWRWOVKUkiR5cGb3bJTq4gaSc7QC/xsckTeYGYtxWiBdFhxw1LF",
	"7FrrhxThlwxq63uMzsLpRqVIj+wtahU+1IDZioHPRqJO5R+yKCKcmK4HTmyIKqHw1T6kezihl/2KjlBS",
	"RUjzBzqnUeURz84+sQouVrs4UBy7UVWhYmLJ7L7/WkPQnSXYMOyAXVgqxhcio1U1RBDn1DMC3T2uJDto",
	"UymXlDU+eN3jEkFqvxoRhdceHAwTrdAik6LcbHMzT5DXsBdWJBpkDyElr27ifbRbZVQpaNwSPZl5H60Q",
	"ENtLvDe5vivUtbx2McvOAC2qsatvK6gpUZ8y5oXdoXdJZtHL6lbJDAvblHbhSJ8Uyzz/9BRLFFjzpm5i",
	"pM7Ec/IbU9LptGEoeyEae7wrluCySB8lOoXyU7rXrTvlnmW9cPFbpMPBMnlnZ5/WtCdlAEzXkC+uVulw",
	"5xm/Hii4FJ+xf55zlZauWS8NZ9yysU2cZ/8Vjhawr1GVmtivDIlMKLuCu+0qTwGy0MuBYk9bT3O+9TS3",
	"jN/KU3fplUhM0p4mn07pxIyAl37HsUcqlnQ4LrKpu9efeszlDw4Lo1DDK9LXRQ4/6xb0GH6+pxQ9U5/j",
	"w73VyrQTvDx8R8SRkHS5A83Kuadm/j3Qv1jHmGY5E/K1Fa1utMbmTuIRQTzs58AGvRya7I+OMScKPuAI",
	"jT+FlTX9C2hCZNxz7X709BHC127SPxrXztFLWZcFls9ZQcbKRsdMnI4rkxfkwqZsIbqOgKdHHNitoxni",
	"zSbkjR2Zlpd0o709t8Gs4eH8rmKRnYQtMU5pi0bo9N6oHF3TWc4rzoQJfj7xuVgkH7aCpgd21lRLdTDX",
	"Jr8IVgvn7E+bepPtFzr/QOdq6tGIQ0/dNtOybS7Agb3F2rZ56cf2KwpHGjG03WlMUlVHw5buIHrNc/ZW",
	"ghflxdmT1IWOSO7CfMOkbjnLtjHD5YwWmJvLs0NfodNdW7S8r9GDQcmLJmBBwB7LNKYsZ9k522QFL+vB",
	"cPnl7NzN/QPbvHIt8UhX1OTLCKjmUvr8oFGXK9CP5SwbFWjUzm7mUiANVXxZzrRbzyljRQs38RXD9gwS",
	"Z/dJ45EmYBVF8/c9eewsZ5j+lg+t8IK7Jf4sDXvzKj4tu6htJ4Y97jmPZnQd+kga4UVz0q1N2XH/nQvF",
	"9suPVvd9bz72wmuP0wzfeSFFO+nAwNutsI3scb6j6rx16x2zdgPYK69IZ9SWjhElHtGsxITtnbwHQ1F5",
	"mpXuxTPKzAeBJuH90UUZFeQDFYVckdc+5eHjnz+8fkIU03VpPJPx9R8s83GQ3G/RpcGFV2ruVn4aReiF",
	"5XPhHl4XXBuVeLi481XBLdjl5GgbzbVpPB3RrwWTYveSUHAnBaXFUJhwJx+xrZCTNIKphix7YDqD2gUz",
	"IFFy3gdBb5l6hyOUbVPiUsEb6rorHXdhYLnuxrRmqTr356Eh0A5TgvfC2E493QPvvuTTdUP66Wa6mn6I",
	"6mETmhWVS7Dn6cvGdQT/a2lZ0RQYG2q1D+1qNzfKVtuNvSmNLoI3evSQuNPNvT1e2tXd61kwCZSH5X2N",
	"y04I0r/jLY1mBP0LV9K9jJSfeS0K3dnCkKBgm5vGVt3HqT6+zVaPjyGlYKwm0ArUb0MCAp4LdGtyNGgt",
	"c9746kBFbqy9/TdRblzq3m7ds2YrQTR3GYq6WRIWPHdpO/d1LHnr+36eTlZ1afgVx3nn+6KnS5od8oVj",
	"haKgqiCsePbNN1/+5f6SvX4eecJvow3uewG6ZblXBmp43tZjw+pGEDF/lEcL2SdZg4/tatG8PYbH9VR6",
	"+/Fv5ADIcLoN/9Di/Mhmm1a+Z2nV9tLw5qep/W1J9bIhnfjwFqqIC0ocveo6B0NMY/TQf8cpLxxiZ9fy",
	"3+pcjyHC0VySh3A3YvKI+DCWJL6LKElvhSu3RHx3sfjiA71hr6uSWdmuoYGDqbv80SDL93Oe8kXv6sTj",
	"pXcdGoBflbSSCGavt8JkI3GBgbCB6gpBBL39OY3hSuXiXCqmLURpJ72lSmY32pbzt8m2mqg+s9fZnnb2",
	"tJMNCfZtUMKtzu8padY2HHgYmWPS/prbReah/C9kTDBwSIDXTXw3LD1Hmai3of5gjue2/jw+i1JjpWu5",
	"SA55serK+7F+jMLV46yA5A2if+P8DHKswBxZLs0nOn+4Mknt/bp+GpDPEEg0l5hRRRiam6YAy+S5G2ky",
	"ndSqnJxMlsZU+uT4+PLy8shPc5TL1fECIiszI+t8eewHgtS1rXSNrourEWrZbrkxPNfk+fs3ICRzUzKI",
	"q4Kji5J4n0yeHT3FdK9M0IpPTiZfHT09+hKvyBLw4hhTq09Ofv88nRxfPDuOnSMXqfioU0ZVvkQ0dm2P",
	"IHUpQ3X2TREavZbquR/OPXSDj8jk5FMvKyU8rUA0Gbd//1oztZlM/a5Gdv/G/aJPD3cn7UC7lMbAAFMr",
	"TIOiGMm91B75FoH7EGEXTBCOmFjyFRa6QGcrmi+dmJaAGdruCXBTMY4uWATvEflJs6hiqzyHOEfUL3yg",
	"ky84GjoNAGaHSMHV0Lh+xgrcNafbgJ84Ff6tdQGRvfBMLqKAhqNWyUP3NueLBKMBOt+QWpRgmhaRn4gO",
	"S4NqmJhCK6duB1xIsY+m0MMn4CfJHISZhXDPE3mD0R6gDIP04OI/wKzpdGWH49OQLTr2FJuiw4rcQL5N",
	"zWy7kH+586Q4dZ5edlj8HLkigg8S+pENLdiFpmS0LFPLjLwLusv869ots8F+XK2u8yX4JHYB7UKGGYRd",
	"9psQd+j2Zur6R35iPh48+IeFlqK1gSP62O1g66qUBZuczGmpWXp7GC6ytTVBIvRu+Lh3zhWuEwmv0QNf",
	"Z5E/2KQVxW9bCCnS+Zl7aVDNBki3ZTqTfW8dXJuHe+XsFNe6b97vPnKqMrJJZwHZn+0ldBnjklwj5OMY",
	"pnY7vem3fx4C3/MZ/7Lo/RRcSCmW3a+YgiFFDq/pGqiFN1Ujznt3yoJrOisxBzfYoVq+eMAfQA5qu6DG",
	"3ndzXsIdglNE3ofZaYL/gigsYcq4aBg7eQ297NCzDYnIS2uYLSPABgSyiM4bcMHDDD9KkblOKyrowsJo",
	"Uddy2DjUDl0OcFfBthkj7zaUDBW398DCOEn2sFDS9cTcZ4a/YzAdOlgEZ6aaTf2mQvHssI3BzbZdytjU",
	"ul2voCnAlYLYJZK0Q2/nD79MJ77MDhDHZ0+fenHXPQdEiz/+l0bFtRlwOOBmnyjfFM30NVa3pmMJlfNb",
	"SINi3qqqzbAz39pkIFz1R/5JO75W0QUXzgUWEHFFz1EHwXhv54HuCarPvmMltvB66mQ8d8lH2LobMbq9",
	"Ab8k1ZM25I/BE/WJXeDX1zrHwfpKw3WOOuvwDceA/cEhIEbRYH2mz9PJN3/0JVikpgsNBf1ATZr88rmj",
	"fB3/7kNAePF5UBN7K+V5XYU3nKjqal8hw7buXr3YAE3bqpCFlyHPJoGeQE2chgAGICfxHgEZ20e9GMs0",
	"b5DAH8T6g1h/N2L9rbDSPRjoLTLMNJM68KjJ10+/PrDZh8NmS2B+O9jscY8C7OK7InKo7NJRWSG5LTfe",
	"4O9jOdHdcgt3fl5VkGIHjOj6IfHp29eK/iRs+WCXvpJd+oZZaee+76GeNrM0N/WgrEYRqp2NPUgEB4ng",
	"jygRhHj4e5EDvGrycPj/rTzSHnj+geffGc8PN3oco4/LHR/4u+fvwYhyYOoHpv5HY+qJlPv7sXhvrUwb",
	"M6/F8l/i0M9j0A76/0EWOMgCt6P/twjAvqr/QSBIpKQ6iAUHseCPLRbsr/MHgaDzFnojosDBCHBg/AfG",
	"f+9GgAOzP2j/Bzb/x2fzcSDdWMe6dl60j63qoIo5ss0KItilvWxGEllaZrSDw8cD7WLwB75xM4FMUclC",
	"O8ucrx119onBXAn4xuVcSMOwwsUgFJAmBgbbO84AA/6HwgzC19+TE/tiDPGkN1xMIrWFfAGxmT6e4F92",
	"5zw21k1Kk+C76UuQhFheKA+i+YJkIbOE/WWFP0G08ilf2J9K/AnyJGCUeGofNF8Mb4SGbiv8x443apGO",
	"AkQLaaeImG2cBJ8+l7T4+yAdYP2U1EC0yBwD+eKpV1xkW6cPDW4EhBmbSxe5FMFA1ztg8A32DfS4VW3G",
	"ryxa04JbKmz4ih2Rd47oUEE+vH5Jvvrqq78QvPxWu0F0GVowDonlmmLgAvEoqAmfx5CiD69fAgCnwa91",
	"VKudhxow6qZWDiM+vIX/iWNk/5SBivcZIIGrdmYIp1li/brtokqocneHwV9/Ei15OumqFtcvWNvRlto7",
	"2ZnwEAj2b6W8jnmcjjNxtF9ghpJx7PGufPtvvRhajPpDq7ROuHQoMYTo4iYxYJKgY7OrCd4Hs/PBfHB4",
	"b/4zvjf/W4cTR/t0/HubWO8OK47qaw4ZMpsm6ZDilEjcZRk7xeI/3avhrZGdPYnN3UWOXvMp6fAO8wcR",
	"ZXtE6Hgm14OE6H+B+Ge1/5YsCtdwJtfE3iufLkV3cueGBtDa2RxeuN+aqurOyL+QrpJkbikJVQusm/8I",
	"BuNicQIDPMKsPRyoSe3kEGzIhTn58tlXX7smil6S2cYwPXXwAHTk268BGtv10ezbrx/5JwgKOfHtTyfP",
	"v/vOjVEpLgydlcxZGHpzaqNOlqwspevg5GPWa2g/nPz3//zj6Ojo0RhSLteWmj8XxY90xe6eqD9vzo4L",
	"OJrsRk+k3e6uNj0pgOL+jjcMXZczbCP+L+Q6dd3tnYkyixze7g884+Z4hq5XK6o2ltYzA9c+QjXnModG",
	"gI40emVmw/S+7KbhMFA0KrAQyE1L21KglspKmCVb81wuFK2W3HKUzdEom8wLAO/O6e3BOPCwjAPDFe4r",
	"XqzPzn5poRwXBVun9feA7qMsDS/k+pWbUiarKP8RzAF4G3DhYwjTi/g6t6/+gdMdON1tcjpEuxE8bi+r",
	"znEpF3oP0w6x7UcoBW/lQt+PjefAnm7G9e2eXZr+pP5FUCgqPNTHrqOO3UH2V6z+tf19C1tFlTJvJ6Px",
	"wxdrbvXNo5SLzHOM/XMBLV7Zrn9o2ekapthtRsDtUVXxSza03KYwjYqIOjzsHpjjHtyq5YuAWcrv0Ath",
	"9+x29B1WxBudrxbcDM1nv03uPmTwEAN2iAE7qKZ36T0Ah3z8u7+euz0G4JqPSUNuG47XJhvycPAVuGVf",
	"ASBzY2nhHWaWhikP5OZgzHvYrg5dink8oyUVOdtpkUPRWxswQ0c1X4CguKT4QGC2UlQ/2UE3OuhGh+J/",
	"h8CmsYFNNyZ03aw0EhPPUVraOy74IWVniuvNGtZwUNn+TALIPvkuWs8TYIt19Glb0gtMdWFZKqa/2Krz",
	"HVJeHFJeHFJeHFJeHFJe3OOT9CE5xSE5xUGH+/dOTjHG7cS9ZFpApWDoz9xqjDLAoChy254ovUW9lKsZ",
	"F6zRgvwKmmrZRtqDgkZLagIf9g2NJDq4GuxYV6ZkOcBfwRMHNOOc8Qv471wx9hvLDFVWwh7Db1ur8QBC",
	"kcxo/rhK5l5rs5IxWt2ITwriy2qrFSSkNSFrLaHEr2RqheWNrMklXJaSn0N/V2HTbvoKi1W3i5S72tVD",
	"O+q6ZwDPzvQj07t4BTpkUjlkUjlkUvkTmERmpczPsyWjBZgZdjugQQfiOhyRF/GfbdMHt6w/ZwIeTgCV",
	"iFQFUwlziZDGE5mgZsvaVLXZ4ukGU3/vID9YS+7EWnLQEQ864p9UR3zu351XVJ2jYGgJvdRMeZIV08ZH",
	"IAAanvMKH3PrqoCHXPKxLRzSPGeV3Ugrgawo0cx+gzhJ/+Ltg6jHVnz3cOl0zfc9tZDt9dvH7BNbV5aX",
	"PbRtcmA9kE2iM82EeWh7hFDdwRbd8Nuo3b49gjtt88NzaHgOxd2bHhLP/Bv7r+IhH/8OZ5uhYLzThxU6",
	"Db1h4i3aIYnjlcHp0llhY4Cuac5A7YBIUW7IvKSLI/J3e4XgjkBkmfG2mWmjtyDpLSRD4d69/3Wtf3pA",
	"ekGSndkpb9f4MYKeHa7nH1cxH+WZEOnlY6twdB0SvKE+bTDmGgzxXXN9EP73q+8RVPeDo8PB0eHg6HBw",
	"dDg4OhxqexxMYwf3iYP7xMF94uA+cXCfuBv3ift0eZjeeiGJg1PFwaniYLu5V9NqfLTHv1udaHdyAGLV",
	"x7LFIYfsrDHWjckQ4JSyu8ujfIckJNquvS7r+Mt5iKM/kJeHYhr+PJ1opi78Xa9VOTmZLI2p9MnxMVvT",
	"VVWyo1yujuE91fX/Pcj9crUCRhV+cSNHvzhSZruvM6m45b1lpi/pYsFUZmdGmJ8dPZ18/n8BAAD//5xC",
	"D6HRmgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
