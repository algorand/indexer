// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
