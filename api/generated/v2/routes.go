// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
