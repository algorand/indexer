// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"OqaUiR0BAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
