// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
