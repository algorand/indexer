// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//5mehGYn2AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
