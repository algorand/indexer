// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"uAxuqgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
